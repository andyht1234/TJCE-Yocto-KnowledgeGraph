[
    "* [auh][PATCH v2] upgrade-helper.py: Add layer command line option\n@ 2023-10-20 14:02 David Pierret\n  0 siblings, 0 replies; only message in thread\nFrom: David Pierret @ 2023-10-20 14:02 UTC (permalink / raw)\n  To: yocto; +Cc: Alex Kanavin, David Pierret, Yoann Congal\n\n- Layer options can be defined as command line arguments\n- multiple layers can be defined in a single command\n\neach layer is analyzed 1 by 1 to check if upgrades are available.\n\nSigned-off-by: David Pierret <david.pierret@smile.fr>\nReviewed-by: Yoann Congal <yoann.congal@smile.fr>\n---\n upgrade-helper.py | 75 +++++++++++++++++++++++++++++------------------\n weeklyjob-oe.sh   | 55 ++++++++++++++++++++++++++++++++++\n 2 files changed, 101 insertions(+), 29 deletions(-)\n create mode 100755 weeklyjob-oe.sh\n\ndiff --git a/upgrade-helper.py b/upgrade-helper.py\nindex 4f0b6b7..5093ff9 100755\n--- a/upgrade-helper.py\n+++ b/upgrade-helper.py\n@@ -105,6 +105,12 @@ def parse_cmdline():\n                         help=\"do not compile, just change the checksums, remove PR, and commit\")\n     parser.add_argument(\"-c\", \"--config-file\", default=None,\n                         help=\"Path to the configuration file. Default is $BUILDDIR/upgrade-helper/upgrade-helper.conf\")\n+    parser.add_argument(\"-l\", \"--layer-names\", nargs='*', action=\"store\", default='',\n+                        help=\"layers to include in the upgrade research\")\n+    parser.add_argument(\"-L\", \"--layer-dir\", action=\"store\", default='',\n+                        help=\"the layers root directory\")\n+    parser.add_argument(\"-m\", \"--layer-machines\", nargs='*', action=\"store\", default='',\n+                        help=\"machine to build for the layers\")\n     return parser.parse_args()\n \n def parse_config_file(config_file):\n@@ -440,8 +446,8 @@ class Updater(object):\n         pkgs_ctx = {}\n \n         I(\" ########### The list of recipes to be upgraded #############\")\n-        for p, ov, nv, m, r in pkgs_to_upgrade:\n-            I(\" %s, %s, %s, %s, %s\" % (p, ov, nv, m, r))\n+        for l, p, ov, nv, m, r in pkgs_to_upgrade:\n+            I(\" %s, %s, %s, %s, %s, %s\" % (l, p, ov, nv, m, r))\n \n             pkgs_ctx[p] = {}\n             pkgs_ctx[p]['PN'] = p\n@@ -471,7 +477,7 @@ class Updater(object):\n         succeeded_pkgs_ctx = []\n         failed_pkgs_ctx = []\n         attempted_pkgs = 0\n-        for pn, _, _, _, _ in pkgs_to_upgrade:\n+        for l, pn, _, _, _, _ in pkgs_to_upgrade:\n             pkg_ctx = pkgs_ctx[pn]\n             pkg_ctx['error'] = None\n \n@@ -577,21 +583,24 @@ class UniverseUpdater(Updater):\n         if len(args.recipe) == 1 and args.recipe[0] == \"all\":\n             self.recipes = []\n         else:\n-            self.recipes = args.recipe\n+            self.recipes = ('', args.recipe)\n \n         # to filter recipes in upgrade\n         if not self.recipes and self.opts['layer_mode'] == 'yes':\n             # when layer mode is enabled and no recipes are specified\n             # we need to figure out what recipes are provided by the\n             # layer to try upgrade\n-            self.recipes = self._get_recipes_by_layer()\n+            for layer in self.opts['layer_name'].split(' '):\n+                recipes_for_layer = self._get_recipes_by_layer(layer)\n+                I(\"layer %s => Receipes %s\", layer, recipes_for_layer)\n+                self.recipes.append((layer, recipes_for_layer))\n \n         if args.to_version:\n             if len(self.recipes) != 1:\n                 E(\" -t is only supported when upgrade one recipe\\n\")\n                 exit(1)\n \n-    def _get_recipes_by_layer(self):\n+    def _get_recipes_by_layer(self, layer=''):\n         recipes = []\n \n         recipe_regex = re.compile('^(?P<name>.*):$')\n@@ -611,7 +620,7 @@ class UniverseUpdater(Updater):\n             if not 'skipped' in line:\n                 s = layer_regex.search(line)\n                 if s:\n-                    if s.group('name').strip() == self.opts['layer_name']:\n+                    if s.group('name').strip() == layer:\n                         recipes.append(name)\n \n         return recipes\n@@ -662,31 +671,31 @@ class UniverseUpdater(Updater):\n         return True\n \n     def _get_packages_to_upgrade(self, packages=None):\n+        pkgs_list = []\n+        for layer_name, layer_recipes in self.recipes:\n+            pkgs = oe.recipeutils.get_recipe_upgrade_status(layer_recipes)\n \n-        pkgs = oe.recipeutils.get_recipe_upgrade_status(self.recipes)\n+            for pkg in pkgs:\n+                pn, status, cur_ver, next_ver, maintainer, revision, no_upgrade_reason = pkg\n \n-        pkgs_list = []\n-        for pkg in pkgs:\n-            pn, status, cur_ver, next_ver, maintainer, revision, no_upgrade_reason = pkg\n-\n-            if self.args.to_version:\n-                 next_ver = self.args.to_version\n-\n-            if status == 'UPDATE' and not no_upgrade_reason:\n-                # Always do the upgrade if recipes are specified\n-                if self.recipes and pn in self.recipes:\n-                    pkgs_list.append((pn, cur_ver, next_ver, maintainer, revision))\n-                elif self._pkg_upgradable(pn, next_ver, maintainer):\n-                    pkgs_list.append((pn, cur_ver, next_ver, maintainer, revision))\n-            else:\n-                if no_upgrade_reason:\n-                    I(\" Skip package %s (status = %s, current version = %s,\" \\\n-                        \" next version = %s, no upgrade reason = %s)\" %\n-                         (pn, status, cur_ver, next_ver, no_upgrade_reason))\n+                if self.args.to_version:\n+                     next_ver = self.args.to_version\n+\n+                if status == 'UPDATE' and not no_upgrade_reason:\n+                    # Always do the upgrade if recipes are specified\n+                    if layer_recipes and pn in layer_recipes:\n+                        pkgs_list.append((layer_name, pn, cur_ver, next_ver, maintainer, revision))\n+                    elif self._pkg_upgradable(pn, next_ver, maintainer):\n+                        pkgs_list.append((layer_name, pn, cur_ver, next_ver, maintainer, revision))\n                 else:\n-                    I(\" Skip package %s (status = %s, current version = %s,\" \\\n-                        \" next version = %s)\" %\n-                        (pn, status, cur_ver, next_ver))\n+                    if no_upgrade_reason:\n+                        I(\" Skip package %s/%s (status = %s, current version = %s,\" \\\n+                            \" next version = %s, no upgrade reason = %s)\" %\n+                             (layer_name, pn, status, cur_ver, next_ver, no_upgrade_reason))\n+                    else:\n+                        I(\" Skip package %s/%s (status = %s, current version = %s,\" \\\n+                            \" next version = %s)\" %\n+                            (layer_name, pn, status, cur_ver, next_ver))\n \n         return pkgs_list\n \n@@ -731,6 +740,14 @@ if __name__ == \"__main__\":\n     log.basicConfig(format='%(levelname)s:%(message)s',\n                     level=debug_levels[args.debug_level - 1])\n     settings, maintainer_override = parse_config_file(args.config_file)\n+    if args.layer_names != '' and args.layer_dir == '':\n+        E(\"layer-dir is mandatory if layers are defined\")\n+        exit(1)\n+    elif args.layer_names != '':\n+        settings['layer_mode'] = 'yes'\n+        settings['layer_dir'] = args.layer_dir\n+        settings['layer_name'] = ' '.join(args.layer_names)\n+        settings['layer_machines'] = ' '.join(args.layer_machines)\n \n     updater = UniverseUpdater(args)\n     updater.run()\ndiff --git a/weeklyjob-oe.sh b/weeklyjob-oe.sh\nnew file mode 100755\nindex 0000000..53dc850\n--- /dev/null\n+++ b/weeklyjob-oe.sh\n@@ -0,0 +1,55 @@\n+#!/bin/bash\n+\n+# Cronjob which can be run weekly to run the upgrade helper script.\n+# Add the job in /etc/crontab like below.\n+#\n+# It will execute weekly at the same hour (8 AM).\n+#\n+# 00 8   * * 6   auh  /home/auh/bin/weeklyjob-oe.sh\n+\n+# Re-assign these to match your setup!\n+auh_dir=~/auto-upgrade-helper\n+poky_dir=~/poky\n+openembedded_dir=~/meta-openembedded\n+build_dir=~/build-tmp-auh-upgrades\n+sstate_dir=~/sstate-cache\n+\n+meta_list=\"${openembedded_dir}/meta-*\"\n+machine_list=\"qemux86 qemux86-64 qemuarm qemumips qemuppc qemux86_musl\"\n+\n+pushd $poky_dir\n+# Base the upgrades on meta_openembedded master\n+git fetch origin\n+git checkout -B tmp-auh-upgrades origin/master\n+popd\n+\n+pushd $openembedded_dir || exit 1\n+# Base the upgrades on meta_openembedded master\n+git fetch origin\n+git checkout -B tmp-auh-upgrades origin/master\n+\n+# enter the build environment\n+source $poky_dir/oe-init-build-env $build_dir\n+\n+# upgrade helper need to use ?= for MACHINE\n+sed -i.bak -E 's|^(MACHINE[[:space:]]*)[?+=]+([[:space:]]*.*)$|\\1?=\\2|' $build_dir/conf/local.conf\n+\n+mkdir -p $build_dir/upgrade-helper/\n+\n+# Add all the meta to the current build\n+bitbake-layers add-layer ${meta_list}\n+\n+# build the layer_names variable to be used in the command line\n+layer_names=\"\"\n+for m in $meta_list; do\n+  layer_names+=\" $(basename ${m})\"\n+done\n+\n+python3 $auh_dir/upgrade-helper.py -e --layer-dir ${openembedded_dir} --layer-names ${layer_names} --layer-machines ${machine_list} -- all\n+\n+# clean up to avoid the disk filling up\n+rm -rf $build_dir/tmp/\n+rm -rf $build_dir/workspace/sources/*\n+find $sstate_dir -atime +10 -delete\n+\n+popd || exit 1\n-- \n2.39.2\n\n\n\n^ permalink raw reply related\t[flat|nested] only message in thread",
    "only message in thread, other threads:[~2023-10-20 14:02 UTC | newest]\n\nThread overview: (only message) (download: mbox.gz / follow: Atom feed)\n-- links below jump to the message on this page --\n2023-10-20 14:02 [auh][PATCH v2] upgrade-helper.py: Add layer command line option David Pierret\n"
]