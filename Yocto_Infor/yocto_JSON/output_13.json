[
    "* [CROPS][PATCH] crops: Archive crops repository\n@ 2023-01-12 13:26 Eilís 'pidge' Ní Fhlannagáin\n  2023-10-19 21:42 ` [yocto] \" Tim Orling\n  0 siblings, 1 reply; 2+ messages in thread\nFrom: Eilís 'pidge' Ní Fhlannagáin @ 2023-01-12 13:26 UTC (permalink / raw)\n  To: yocto; +Cc: Eilís Ní Fhlannagáin\n\nFrom: Eilís Ní Fhlannagáin <pidge@baylibre.com>\n\nThis repository is depreciated and is no longer maintained so we should\narchive it and make note that development for crops is currently at\nhttps://github.com/crops\n\nSigned-off-by: Eilís Ní Fhlannagáin <pidge@baylibre.com>\n---\n .dockerignore                          |   1 -\n .gitignore                             |   9 -\n .travis.yml                            |  44 ----\n LICENSE                                | 339 ------------------------\n Makefile                               |  15 --\n README.md                              | 154 +----------\n TODO                                   |  10 -\n ceed/Makefile                          |  42 ---\n ceed/ceed.c                            |  70 -----\n ceed/ceed_api.c                        | 157 -----------\n ceed/ceed_api.h                        |  22 --\n codi/Makefile                          |  19 --\n codi/codi.c                            | 126 ---------\n codi/codi_api.c                        | 134 ----------\n codi/codi_api.h                        |  25 --\n codi/codi_db.c                         | 137 ----------\n codi/codi_db.h                         |  28 --\n codi/codi_launcher.c                   | 146 ----------\n codi/codi_launcher.h                   |  58 ----\n codi/codi_list.c                       | 100 -------\n codi/codi_list.h                       |  33 ---\n confs/ostro/ostro.conf                 |  16 --\n confs/ostro/ostro.layers               |   0\n dockerfiles/Dockerfile.ceed.deps       |  16 --\n dockerfiles/Dockerfile.ceed.linux      |  19 --\n dockerfiles/Dockerfile.ceed.win        |  19 --\n dockerfiles/Dockerfile.codi            |  34 ---\n dockerfiles/Dockerfile.codi.deps       |  31 ---\n dockerfiles/Dockerfile.ostro           |  24 --\n dockerfiles/Dockerfile.ostro.deps      |  33 ---\n dockerfiles/Dockerfile.toolchain       |  49 ----\n dockerfiles/Dockerfile.toolchain.deps  |  18 --\n dockerfiles/Dockerfile.zephyr          |  59 -----\n dockerfiles/Dockerfile.zephyr.deps     |  24 --\n globals.c                              |  47 ----\n globals.h                              |  69 -----\n helpers/runbitbake.py                  | 148 -----------\n helpers/startOstroScript.sh            |  42 ---\n installers/ostro-installer.sh          | 108 --------\n installers/zephyr-installer.sh         | 225 ----------------\n scripts/bitbake.ostro                  |  12 -\n scripts/build_ceed                     |  11 -\n scripts/build_containers               |  73 -----\n scripts/build_containers.ostro         |  35 ---\n scripts/gdb.zephyr                     |   8 -\n scripts/make.zephyr                    |  21 --\n scripts/run_containers                 |  59 -----\n scripts/stop_containers                |  33 ---\n tests.py                               |  32 ---\n tests/functional/test_ceed_basic.py    | 104 --------\n tests/functional/test_ceed_commands.py | 121 ---------\n tests/functional/test_zephyr_build.py  | 101 -------\n tests/functional/utils/__init__.py     |   0\n tests/functional/utils/ceedutil.py     |  20 --\n tests/unit/test_basic.py               |  19 --\n tests/unit/test_runbitbake.py          | 130 ---------\n turff/Makefile                         |  19 --\n turff/turff.c                          | 128 ---------\n turff/turff_api.c                      | 255 ------------------\n turff/turff_api.h                      |  24 --\n turff/turff_launcher                   |  43 ---\n utils.c                                | 351 -------------------------\n utils.h                                |  30 ---\n 63 files changed, 5 insertions(+), 4274 deletions(-)\n delete mode 100644 .dockerignore\n delete mode 100644 .gitignore\n delete mode 100644 .travis.yml\n delete mode 100644 LICENSE\n delete mode 100755 Makefile\n mode change 100755 => 100644 README.md\n delete mode 100755 TODO\n delete mode 100755 ceed/Makefile\n delete mode 100755 ceed/ceed.c\n delete mode 100755 ceed/ceed_api.c\n delete mode 100755 ceed/ceed_api.h\n delete mode 100644 codi/Makefile\n delete mode 100644 codi/codi.c\n delete mode 100644 codi/codi_api.c\n delete mode 100644 codi/codi_api.h\n delete mode 100644 codi/codi_db.c\n delete mode 100644 codi/codi_db.h\n delete mode 100644 codi/codi_launcher.c\n delete mode 100644 codi/codi_launcher.h\n delete mode 100644 codi/codi_list.c\n delete mode 100644 codi/codi_list.h\n delete mode 100644 confs/ostro/ostro.conf\n delete mode 100644 confs/ostro/ostro.layers\n delete mode 100644 dockerfiles/Dockerfile.ceed.deps\n delete mode 100644 dockerfiles/Dockerfile.ceed.linux\n delete mode 100644 dockerfiles/Dockerfile.ceed.win\n delete mode 100644 dockerfiles/Dockerfile.codi\n delete mode 100644 dockerfiles/Dockerfile.codi.deps\n delete mode 100644 dockerfiles/Dockerfile.ostro\n delete mode 100644 dockerfiles/Dockerfile.ostro.deps\n delete mode 100644 dockerfiles/Dockerfile.toolchain\n delete mode 100644 dockerfiles/Dockerfile.toolchain.deps\n delete mode 100644 dockerfiles/Dockerfile.zephyr\n delete mode 100644 dockerfiles/Dockerfile.zephyr.deps\n delete mode 100755 globals.c\n delete mode 100755 globals.h\n delete mode 100644 helpers/runbitbake.py\n delete mode 100644 helpers/startOstroScript.sh\n delete mode 100644 installers/ostro-installer.sh\n delete mode 100755 installers/zephyr-installer.sh\n delete mode 100755 scripts/bitbake.ostro\n delete mode 100755 scripts/build_ceed\n delete mode 100755 scripts/build_containers\n delete mode 100755 scripts/build_containers.ostro\n delete mode 100644 scripts/gdb.zephyr\n delete mode 100755 scripts/make.zephyr\n delete mode 100755 scripts/run_containers\n delete mode 100755 scripts/stop_containers\n delete mode 100644 tests.py\n delete mode 100644 tests/functional/test_ceed_basic.py\n delete mode 100644 tests/functional/test_ceed_commands.py\n delete mode 100644 tests/functional/test_zephyr_build.py\n delete mode 100644 tests/functional/utils/__init__.py\n delete mode 100644 tests/functional/utils/ceedutil.py\n delete mode 100644 tests/unit/test_basic.py\n delete mode 100644 tests/unit/test_runbitbake.py\n delete mode 100755 turff/Makefile\n delete mode 100755 turff/turff.c\n delete mode 100755 turff/turff_api.c\n delete mode 100755 turff/turff_api.h\n delete mode 100755 turff/turff_launcher\n delete mode 100755 utils.c\n delete mode 100755 utils.h\n\ndiff --git a/.dockerignore b/.dockerignore\ndeleted file mode 100644\nindex 191381e..0000000\n--- a/.dockerignore\n+++ /dev/null\n@@ -1 +0,0 @@\n-.git\n\\ No newline at end of file\ndiff --git a/.gitignore b/.gitignore\ndeleted file mode 100644\nindex bf35249..0000000\n--- a/.gitignore\n+++ /dev/null\n@@ -1,9 +0,0 @@\n-*~\n-*.o\n-ceed/ceed\n-codi/codi\n-turff/turff\n-outdir\n-*.pyc\n-*#\n-.#*\ndiff --git a/.travis.yml b/.travis.yml\ndeleted file mode 100644\nindex 72bda2e..0000000\n--- a/.travis.yml\n+++ /dev/null\n@@ -1,44 +0,0 @@\n-language: python\n-python:\n-  - \"2.7\"\n-\n-\n-sudo: required\n-services:\n-  - docker\n-\n-services:\n-    - docker\n-\n-env:\n-    global:\n-        - DOCKER_VERSION=1.10.1-0~trusty\n-\n-\n-compiler:\n-  - gcc\n-  - clang\n-\n-before_install:\n-  # list docker-engine versions\n-  - apt-cache madison docker-engine\n-\n-  # upgrade docker-engine to specific version\n-  - sudo apt-get -o Dpkg::Options::=\"--force-confnew\" install -y docker-engine=${DOCKER_VERSION}\n-\n-\n-script:\n-  - ./scripts/build_ceed\n-  - docker version\n-  - ./scripts/build_containers\n-  - docker images | grep codi | grep -q test\n-  - docker images | grep toolchain | grep -q test\n-  - docker images | grep zephyr | grep -q test\n-  - ./scripts/run_containers\n-  - python tests.py\n-\n-notifications:\n-  email:\n-    recipients:\n-    on_success: change\n-    on_failure: always\ndiff --git a/LICENSE b/LICENSE\ndeleted file mode 100644\nindex d159169..0000000\n--- a/LICENSE\n+++ /dev/null\n@@ -1,339 +0,0 @@\n-                    GNU GENERAL PUBLIC LICENSE\n-                       Version 2, June 1991\n-\n- Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n- 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n- Everyone is permitted to copy and distribute verbatim copies\n- of this license document, but changing it is not allowed.\n-\n-                            Preamble\n-\n-  The licenses for most software are designed to take away your\n-freedom to share and change it.  By contrast, the GNU General Public\n-License is intended to guarantee your freedom to share and change free\n-software--to make sure the software is free for all its users.  This\n-General Public License applies to most of the Free Software\n-Foundation's software and to any other program whose authors commit to\n-using it.  (Some other Free Software Foundation software is covered by\n-the GNU Lesser General Public License instead.)  You can apply it to\n-your programs, too.\n-\n-  When we speak of free software, we are referring to freedom, not\n-price.  Our General Public Licenses are designed to make sure that you\n-have the freedom to distribute copies of free software (and charge for\n-this service if you wish), that you receive source code or can get it\n-if you want it, that you can change the software or use pieces of it\n-in new free programs; and that you know you can do these things.\n-\n-  To protect your rights, we need to make restrictions that forbid\n-anyone to deny you these rights or to ask you to surrender the rights.\n-These restrictions translate to certain responsibilities for you if you\n-distribute copies of the software, or if you modify it.\n-\n-  For example, if you distribute copies of such a program, whether\n-gratis or for a fee, you must give the recipients all the rights that\n-you have.  You must make sure that they, too, receive or can get the\n-source code.  And you must show them these terms so they know their\n-rights.\n-\n-  We protect your rights with two steps: (1) copyright the software, and\n-(2) offer you this license which gives you legal permission to copy,\n-distribute and/or modify the software.\n-\n-  Also, for each author's protection and ours, we want to make certain\n-that everyone understands that there is no warranty for this free\n-software.  If the software is modified by someone else and passed on, we\n-want its recipients to know that what they have is not the original, so\n-that any problems introduced by others will not reflect on the original\n-authors' reputations.\n-\n-  Finally, any free program is threatened constantly by software\n-patents.  We wish to avoid the danger that redistributors of a free\n-program will individually obtain patent licenses, in effect making the\n-program proprietary.  To prevent this, we have made it clear that any\n-patent must be licensed for everyone's free use or not licensed at all.\n-\n-  The precise terms and conditions for copying, distribution and\n-modification follow.\n-\n-                    GNU GENERAL PUBLIC LICENSE\n-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n-\n-  0. This License applies to any program or other work which contains\n-a notice placed by the copyright holder saying it may be distributed\n-under the terms of this General Public License.  The \"Program\", below,\n-refers to any such program or work, and a \"work based on the Program\"\n-means either the Program or any derivative work under copyright law:\n-that is to say, a work containing the Program or a portion of it,\n-either verbatim or with modifications and/or translated into another\n-language.  (Hereinafter, translation is included without limitation in\n-the term \"modification\".)  Each licensee is addressed as \"you\".\n-\n-Activities other than copying, distribution and modification are not\n-covered by this License; they are outside its scope.  The act of\n-running the Program is not restricted, and the output from the Program\n-is covered only if its contents constitute a work based on the\n-Program (independent of having been made by running the Program).\n-Whether that is true depends on what the Program does.\n-\n-  1. You may copy and distribute verbatim copies of the Program's\n-source code as you receive it, in any medium, provided that you\n-conspicuously and appropriately publish on each copy an appropriate\n-copyright notice and disclaimer of warranty; keep intact all the\n-notices that refer to this License and to the absence of any warranty;\n-and give any other recipients of the Program a copy of this License\n-along with the Program.\n-\n-You may charge a fee for the physical act of transferring a copy, and\n-you may at your option offer warranty protection in exchange for a fee.\n-\n-  2. You may modify your copy or copies of the Program or any portion\n-of it, thus forming a work based on the Program, and copy and\n-distribute such modifications or work under the terms of Section 1\n-above, provided that you also meet all of these conditions:\n-\n-    a) You must cause the modified files to carry prominent notices\n-    stating that you changed the files and the date of any change.\n-\n-    b) You must cause any work that you distribute or publish, that in\n-    whole or in part contains or is derived from the Program or any\n-    part thereof, to be licensed as a whole at no charge to all third\n-    parties under the terms of this License.\n-\n-    c) If the modified program normally reads commands interactively\n-    when run, you must cause it, when started running for such\n-    interactive use in the most ordinary way, to print or display an\n-    announcement including an appropriate copyright notice and a\n-    notice that there is no warranty (or else, saying that you provide\n-    a warranty) and that users may redistribute the program under\n-    these conditions, and telling the user how to view a copy of this\n-    License.  (Exception: if the Program itself is interactive but\n-    does not normally print such an announcement, your work based on\n-    the Program is not required to print an announcement.)\n-\n-These requirements apply to the modified work as a whole.  If\n-identifiable sections of that work are not derived from the Program,\n-and can be reasonably considered independent and separate works in\n-themselves, then this License, and its terms, do not apply to those\n-sections when you distribute them as separate works.  But when you\n-distribute the same sections as part of a whole which is a work based\n-on the Program, the distribution of the whole must be on the terms of\n-this License, whose permissions for other licensees extend to the\n-entire whole, and thus to each and every part regardless of who wrote it.\n-\n-Thus, it is not the intent of this section to claim rights or contest\n-your rights to work written entirely by you; rather, the intent is to\n-exercise the right to control the distribution of derivative or\n-collective works based on the Program.\n-\n-In addition, mere aggregation of another work not based on the Program\n-with the Program (or with a work based on the Program) on a volume of\n-a storage or distribution medium does not bring the other work under\n-the scope of this License.\n-\n-  3. You may copy and distribute the Program (or a work based on it,\n-under Section 2) in object code or executable form under the terms of\n-Sections 1 and 2 above provided that you also do one of the following:\n-\n-    a) Accompany it with the complete corresponding machine-readable\n-    source code, which must be distributed under the terms of Sections\n-    1 and 2 above on a medium customarily used for software interchange; or,\n-\n-    b) Accompany it with a written offer, valid for at least three\n-    years, to give any third party, for a charge no more than your\n-    cost of physically performing source distribution, a complete\n-    machine-readable copy of the corresponding source code, to be\n-    distributed under the terms of Sections 1 and 2 above on a medium\n-    customarily used for software interchange; or,\n-\n-    c) Accompany it with the information you received as to the offer\n-    to distribute corresponding source code.  (This alternative is\n-    allowed only for noncommercial distribution and only if you\n-    received the program in object code or executable form with such\n-    an offer, in accord with Subsection b above.)\n-\n-The source code for a work means the preferred form of the work for\n-making modifications to it.  For an executable work, complete source\n-code means all the source code for all modules it contains, plus any\n-associated interface definition files, plus the scripts used to\n-control compilation and installation of the executable.  However, as a\n-special exception, the source code distributed need not include\n-anything that is normally distributed (in either source or binary\n-form) with the major components (compiler, kernel, and so on) of the\n-operating system on which the executable runs, unless that component\n-itself accompanies the executable.\n-\n-If distribution of executable or object code is made by offering\n-access to copy from a designated place, then offering equivalent\n-access to copy the source code from the same place counts as\n-distribution of the source code, even though third parties are not\n-compelled to copy the source along with the object code.\n-\n-  4. You may not copy, modify, sublicense, or distribute the Program\n-except as expressly provided under this License.  Any attempt\n-otherwise to copy, modify, sublicense or distribute the Program is\n-void, and will automatically terminate your rights under this License.\n-However, parties who have received copies, or rights, from you under\n-this License will not have their licenses terminated so long as such\n-parties remain in full compliance.\n-\n-  5. You are not required to accept this License, since you have not\n-signed it.  However, nothing else grants you permission to modify or\n-distribute the Program or its derivative works.  These actions are\n-prohibited by law if you do not accept this License.  Therefore, by\n-modifying or distributing the Program (or any work based on the\n-Program), you indicate your acceptance of this License to do so, and\n-all its terms and conditions for copying, distributing or modifying\n-the Program or works based on it.\n-\n-  6. Each time you redistribute the Program (or any work based on the\n-Program), the recipient automatically receives a license from the\n-original licensor to copy, distribute or modify the Program subject to\n-these terms and conditions.  You may not impose any further\n-restrictions on the recipients' exercise of the rights granted herein.\n-You are not responsible for enforcing compliance by third parties to\n-this License.\n-\n-  7. If, as a consequence of a court judgment or allegation of patent\n-infringement or for any other reason (not limited to patent issues),\n-conditions are imposed on you (whether by court order, agreement or\n-otherwise) that contradict the conditions of this License, they do not\n-excuse you from the conditions of this License.  If you cannot\n-distribute so as to satisfy simultaneously your obligations under this\n-License and any other pertinent obligations, then as a consequence you\n-may not distribute the Program at all.  For example, if a patent\n-license would not permit royalty-free redistribution of the Program by\n-all those who receive copies directly or indirectly through you, then\n-the only way you could satisfy both it and this License would be to\n-refrain entirely from distribution of the Program.\n-\n-If any portion of this section is held invalid or unenforceable under\n-any particular circumstance, the balance of the section is intended to\n-apply and the section as a whole is intended to apply in other\n-circumstances.\n-\n-It is not the purpose of this section to induce you to infringe any\n-patents or other property right claims or to contest validity of any\n-such claims; this section has the sole purpose of protecting the\n-integrity of the free software distribution system, which is\n-implemented by public license practices.  Many people have made\n-generous contributions to the wide range of software distributed\n-through that system in reliance on consistent application of that\n-system; it is up to the author/donor to decide if he or she is willing\n-to distribute software through any other system and a licensee cannot\n-impose that choice.\n-\n-This section is intended to make thoroughly clear what is believed to\n-be a consequence of the rest of this License.\n-\n-  8. If the distribution and/or use of the Program is restricted in\n-certain countries either by patents or by copyrighted interfaces, the\n-original copyright holder who places the Program under this License\n-may add an explicit geographical distribution limitation excluding\n-those countries, so that distribution is permitted only in or among\n-countries not thus excluded.  In such case, this License incorporates\n-the limitation as if written in the body of this License.\n-\n-  9. The Free Software Foundation may publish revised and/or new versions\n-of the General Public License from time to time.  Such new versions will\n-be similar in spirit to the present version, but may differ in detail to\n-address new problems or concerns.\n-\n-Each version is given a distinguishing version number.  If the Program\n-specifies a version number of this License which applies to it and \"any\n-later version\", you have the option of following the terms and conditions\n-either of that version or of any later version published by the Free\n-Software Foundation.  If the Program does not specify a version number of\n-this License, you may choose any version ever published by the Free Software\n-Foundation.\n-\n-  10. If you wish to incorporate parts of the Program into other free\n-programs whose distribution conditions are different, write to the author\n-to ask for permission.  For software which is copyrighted by the Free\n-Software Foundation, write to the Free Software Foundation; we sometimes\n-make exceptions for this.  Our decision will be guided by the two goals\n-of preserving the free status of all derivatives of our free software and\n-of promoting the sharing and reuse of software generally.\n-\n-                            NO WARRANTY\n-\n-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\n-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\n-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\n-PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\n-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\n-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\n-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\n-REPAIR OR CORRECTION.\n-\n-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\n-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\n-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\n-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\n-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\n-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\n-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\n-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGES.\n-\n-                     END OF TERMS AND CONDITIONS\n-\n-            How to Apply These Terms to Your New Programs\n-\n-  If you develop a new program, and you want it to be of the greatest\n-possible use to the public, the best way to achieve this is to make it\n-free software which everyone can redistribute and change under these terms.\n-\n-  To do so, attach the following notices to the program.  It is safest\n-to attach them to the start of each source file to most effectively\n-convey the exclusion of warranty; and each file should have at least\n-the \"copyright\" line and a pointer to where the full notice is found.\n-\n-    <one line to give the program's name and a brief idea of what it does.>\n-    Copyright (C) <year>  <name of author>\n-\n-    This program is free software; you can redistribute it and/or modify\n-    it under the terms of the GNU General Public License as published by\n-    the Free Software Foundation; either version 2 of the License, or\n-    (at your option) any later version.\n-\n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU General Public License for more details.\n-\n-    You should have received a copy of the GNU General Public License along\n-    with this program; if not, write to the Free Software Foundation, Inc.,\n-    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-Also add information on how to contact you by electronic and paper mail.\n-\n-If the program is interactive, make it output a short notice like this\n-when it starts in an interactive mode:\n-\n-    Gnomovision version 69, Copyright (C) year name of author\n-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n-    This is free software, and you are welcome to redistribute it\n-    under certain conditions; type `show c' for details.\n-\n-The hypothetical commands `show w' and `show c' should show the appropriate\n-parts of the General Public License.  Of course, the commands you use may\n-be called something other than `show w' and `show c'; they could even be\n-mouse-clicks or menu items--whatever suits your program.\n-\n-You should also get your employer (if you work as a programmer) or your\n-school, if any, to sign a \"copyright disclaimer\" for the program, if\n-necessary.  Here is a sample; alter the names:\n-\n-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n-  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n-\n-  <signature of Ty Coon>, 1 April 1989\n-  Ty Coon, President of Vice\n-\n-This General Public License does not permit incorporating your program into\n-proprietary programs.  If your program is a subroutine library, you may\n-consider it more useful to permit linking proprietary applications with the\n-library.  If this is what you want to do, use the GNU Lesser General\n-Public License instead of this License.\ndiff --git a/Makefile b/Makefile\ndeleted file mode 100755\nindex 97dabae..0000000\n--- a/Makefile\n+++ /dev/null\n@@ -1,15 +0,0 @@\n-SUBDIRS = turff ceed codi\n-\n-.PHONY: subdirs $(SUBDIRS)\n-\n-all: TARGET = all\n-\n-clean: TARGET = clean\n-\n-debug: TARGET = debug\n-\n-all clean debug: subdirs $(SUBDIRS)\n-\n-$(SUBDIRS):\n-\t$(MAKE) -C $@ $(TARGET)\n-\ndiff --git a/README.md b/README.md\nold mode 100755\nnew mode 100644\nindex 555f7e2..ddd9cba\n--- a/README.md\n+++ b/README.md\n@@ -1,153 +1,9 @@\n-## What is CROPS (CROssPlatformS)?\n+This repository is depreciated and is no longer maintained. \n \n-CROPS is an open source, cross-platform development framework that leverages Docker containers to provide an easily managed, extensible environment which allows developers to build binaries for a variety of architectures of Windows, Linux and Mac OS X hosts.\n+Current CROPS development occurs at:\n \n-### CROPS components\n-* **CEED** - runs on the development host and exposes an API to Integrated\n-Development Environments (IDEs) or CLI callers\n-* **TURFF** - runs in a container and services requests from CODI\n-* **CODI** - COntainer DIspatcher runs in a container and keeps track of all available TURFF instances\n-in its internal table. CODI also redirects CEED requests to the corresponding TURFF instance\n+https://github.com/crops\n \n-## USING CROPS FOR [ZEPHYR OS](https://www.zephyrproject.org/) DEVELOPMENT\n+The last functional commit for this repo was:\n \n-Please refer to the [GitHub Wiki](https://github.com/todorez/crops/wiki)\n-\n-## USING CROPS WITH YOUR OWN TOOLCHAIN\n-\n- 1. **Install [Docker (Linux)](https://docs.docker.com/linux/step_one/) or [Docker Toolbox (Windows/Mac)](https://www.docker.com/products/docker-toolbox)**\n-\n- 2. **Build CODI dependencies container**\n-\n-  Execute the following command from within the dockerfiles directory:\n-\n-  ```\n-  docker build -t crops/codi:deps -f Dockerfile.codi.deps .\n-  ```\n- 3. **Build CODI container**\n-\n-  Execute the following command from within the dockerfiles directory:\n-\n-  ```\n-  docker build -t crops/codi:version -f Dockerfile.codi ../\n-  ```\n-\n- 4. **Build toolchain dependencies container**\n-\n-  Execute the following command from within the dockerfiles directory:\n-\n-  ```\n-  docker build -t crops/toolchain:deps -f Dockerfile.toolchain.deps .\n-  ```\n-\n- 5. **Open the Dockerfile.toolchain file and provide the URL to your toolchain**\n-\n-  Example:\n-\n-  ```\n-  ENV TOOLCHAIN_NAME poky-glibc-x86_64-core-image-sato-i586-toolchain-2.0.sh\n-  ENV TOOLCHAIN_PATH http://downloads.yoctoproject.org/releases/yocto/yocto-2.0/toolchain/x86_64/\n-  ```\n-\n- 6. **Build your toolchain container**\n-\n-  ```\n-  docker build -t crops/toolchain:my_toolchain -f Dockerfile.toolchain ../\n-  ```\n-\n- 7. **Start CODI container**\n-\n-  ```\n-  docker run -d --name codi-test -v /var/run/docker.sock:/var/run/docker.sock --net=host crops/codi:version\n-  ```\n-\n- 8. **Start toolchain container**\n-\n-  ```\n-  mkdir -p $HOME/crops-workspace && docker run -d --name crops-toolchain-my_toolchain -v $HOME/crops-workspace/:/crops/   --env TURFFID=crops-toolchain-my_toolchain --net=host crops/toolchain:my_toolchain\n-  ```\n-\n- 9. **Run the Zephyr installer and answer \"Yes\" when prompted to install CEED. Answer \"No\" to all other questions**\n-\n-  ```\n-  curl -kOs https://raw.githubusercontent.com/todorez/crops/master/installers/zephyr-installer.sh && source   ./zephyr-installer.sh\n-  ```\n-\n- 10. **Place your project in the shared workspace**\n-\n-  Example:\n-  ```\n-  $HOME/crops-workspace/my_project/\n-  ```\n-\n- 11. **Build your project**\n-\n-  Example:\n-  ```\n-  $HOME/.crops/ceed/ceed -d crops-toolchain-my_toolchain -g \"make -C /crops/my_project/\"\n-  ```\n- 12. **Share your toolchain with other developers by pushing it to Docker Hub**\n-\n-  Example:\n-  ```\n-  $docker push crops/toolchain:my_toolchain\"\n-  ```\n-\n-## CONTRIBUTING TO CROPS\n-\n-#### COMPILE CEED, TURFF AND CODI ON LINUX\n-\n-**Required Prerequisites**\n-\n-* **libsqlite3-dev** - \"SQLite is a C library that implements an SQL database engine.\"\n-* **libcurl4-openssl-dev (7.40 or later)** - \"libcurl is an easy-to-use client-side URL transfer library, supporting DICT, FILE, FTP, FTPS, GOPHER, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, TELNET and TFTP.\"\n-* **libjansson-dev** - \"Jansson is a C library for encoding, decoding and manipulating JSON data.\"\n-\n-\n-1. **Install Prerequisites On Debian / Ubuntu**\n-\n-  ```\n-  apt-get install libsqlite3-dev libcurl4-openssl-dev libjansson-dev\n-  ```\n-\n-2. **Compile**\n-\n-  * GCC\n-\n-  ```\n-  CC=gcc make all\n-  ```\n-\n-  * CLANG\n-\n-  ```\n-  CC=clang make all\n-  ```\n-\n-3. **Debug Compile**\n-\n-  * GCC\n-\n-  ```\n-  CC=gcc make debug\n-  ```\n-\n-  * CLANG\n-\n-  ```\n-  CC=clang make debug\n-  ```\n-\n-#### RUNNING A CLANG STATIC ANALYSYS\n-\n-1. **Run the static analyzer**\n-\n-  ```\n-  scan-build -V make\n-  ```\n-\n-2. **Point your browser at the following URL to view the static analysis results**\n-\n-  ```\n-  http://127.0.0.1:8181\n-  ```\n+https://git.yoctoproject.org/crops/commit/?id=b719d15fe0e17e5ac05c440680ec3706bcd2cab5\ndiff --git a/TODO b/TODO\ndeleted file mode 100755\nindex 6014c97..0000000\n--- a/TODO\n+++ /dev/null\n@@ -1,10 +0,0 @@\n-* rewrite eclipse plugin for all platforms Windows, Linux, Mac\n-* create Docker image installers for Windows/Linux/Mac\n-* create container launchers\n-* document installation/configuration/usage\n-* document APIs\n-* implement bitbake operations\n-* fix all bugs.. :)\n-\n-\n-\ndiff --git a/ceed/Makefile b/ceed/Makefile\ndeleted file mode 100755\nindex 58205ed..0000000\n--- a/ceed/Makefile\n+++ /dev/null\n@@ -1,42 +0,0 @@\n-CFLAGS =-g -I. -I../\n-LDFLAGS =-lm\n-\n-ifeq ($(CC),x86_64-w64-mingw32-gcc)\n-LDFLAGS += -lws2_32\n-endif\n-\n-DEPS = ceed_api.h ../globals.h ../utils.h\n-OBJ = ceed.o ceed_api.o ../utils.o ../globals.o\n-\n-all: ceed\n-\n-debug: DFLAGS = -DDBG\n-debug: clean ceed\n-\n-%.o: %.c $(DEPS)\n-\t$(CC) -c -o $@ $< $(CFLAGS) $(DFLAGS)\n-\n-ceed: $(OBJ)\n-\t$(CC) -o $@ $^ $(CFLAGS) $(LDFLAGS)\n-\n-.PHONY: clean\n-clean:\n-\trm -f $(OBJ) ceed *.exe\n-\n-windows:\n-\tdocker ps -a -q --filter \"name=ceed-windows\" | awk '{print $1}' | xargs -I {} docker rm -f {}\n-\tdocker images -q --filter \"label=name=ceed-windows\" | awk '{print $1}' | xargs -I {} docker rmi {}\n-\tcd ../dockerfiles; docker build -t crops/ceed:windows -f Dockerfile.ceed.win ../\n-\tdocker run --name=ceed-windows crops/ceed:windows; mkdir -p ../outdir\n-\tdocker cp ceed-windows:/usr/local/crops/ceed/ceed ../outdir/ceed.exe\n-\tdocker ps -a -q --filter \"name=ceed-windows\" | awk '{print $1}' | xargs -I {} docker rm -f {}\n-\tdocker images -q --filter \"label=name=ceed-windows\" | awk '{print $1}' | xargs -I {} docker rmi {}\n-\n-linux:\n-\tdocker ps -a -q --filter \"name=ceed-linux\" | awk '{print $1}' | xargs -I {} docker rm -f {}\n-\tdocker images -q --filter \"label=name=ceed-linux\" | awk '{print $1}' | xargs -I {} docker rmi {}\n-\tcd ../dockerfiles; docker build -t crops/ceed:linux -f Dockerfile.ceed.linux ../\n-\tdocker run --name=ceed-linux crops/ceed:linux; mkdir -p ../outdir\n-\tdocker cp ceed-linux:/usr/local/crops/ceed/ceed ../outdir/ceed\n-\tdocker ps -a -q --filter \"name=ceed-linux\" | awk '{print $1}' | xargs -I {} docker rm -f {}\n-\tdocker images -q --filter \"label=name=ceed-linux\" | awk '{print $1}' | xargs -I {} docker rmi {}\ndiff --git a/ceed/ceed.c b/ceed/ceed.c\ndeleted file mode 100755\nindex f0fa0cc..0000000\n--- a/ceed/ceed.c\n+++ /dev/null\n@@ -1,70 +0,0 @@\n-/*\n- * Copyright (C) 2016 Intel Corporation\n- *\n- * Author: Todor Minchev <todor.minchev@linux.intel.com>\n- *\n- * This program is free software; you can redistribute it and/or modify it\n- * under the terms and conditions of the GNU General Public License,\n- * version 2, or (at your option) any later version, as published by\n- * the Free Software Foundation.\n- *\n- * This program is distributed in the hope it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n- * more details.\n- */\n-\n-#include <stdlib.h>\n-#include \"globals.h\"\n-#include \"ceed_api.h\"\n-#include \"utils.h\"\n-\n-extern char *ceed_ops[];\n-\n-int main(int argc, char *argv[]) {\n-  int i, done, sock_fd;\n-  char *turff_nodes[KEY_ARR_SZ];\n-  struct addrinfo *addr_p;\n-  void *ceed_out;\n-\n-  parse_ceed_params(argc, argv);\n-\n-  addr_p = connect_to_socket(ceed_ops[KEY('i')], ceed_ops[KEY('s')], &sock_fd);\n-\n-  if(addr_p == NULL) {\n-    ERR(\"Could not connect to CODI\\n\");\n-  } else {\n-    INFO(\"Connected to CODI on %s port : %s\\n\",\n-      ceed_ops[KEY('i')], ceed_ops[KEY('s')]);\n-  }\n-\n-  INFO(\"Host Architecture : %s\\n\", ceed_ops[KEY('a')]);\n-  send_args(sock_fd, ceed_ops);\n-\n-  if(ceed_ops[KEY('l')] == NULL) { /* this was a service request */\n-    INFO(\" ==========  CEED OUTPUT BEGIN  ==========\\n\");\n-    ceed_out = calloc(1, BUFSIZ);\n-    done = 0;\n-\n-    while(!done) {\n-      memset(ceed_out, 0, BUFSIZ);\n-      receive_data(sock_fd, ceed_out, BUFSIZ, 1, &done);\n-    }\n-    free(ceed_out);\n-\n-    INFO(\" ==========  CEED OUTPUT END  ==========\\n\");\n-  } else { /* this was nodes request, receive turff nodes */\n-    do {\n-      for(i = 0; i <  KEY_ARR_SZ; i++)\n-        turff_nodes[i] = NULL;\n-\n-      receive_args(sock_fd, turff_nodes);\n-      if(turff_nodes[KEY('e')] == NULL) {\n-        INFO(\"TURFF Node ID: %s \\n\", turff_nodes[KEY('d')]);\n-      }\n-    }while (turff_nodes[KEY('e')] == NULL);\n-  }\n-\n-  close(sock_fd);\n-  return 0;\n-}\ndiff --git a/ceed/ceed_api.c b/ceed/ceed_api.c\ndeleted file mode 100755\nindex 973c050..0000000\n--- a/ceed/ceed_api.c\n+++ /dev/null\n@@ -1,157 +0,0 @@\n-/*\n- * Copyright (C) 2016 Intel Corporation\n- *\n- * Author: Todor Minchev <todor.minchev@linux.intel.com>\n- *\n- * This program is free software; you can redistribute it and/or modify it\n- * under the terms and conditions of the GNU General Public License,\n- * version 2, or (at your option) any later version, as published by\n- * the Free Software Foundation.\n- *\n- * This program is distributed in the hope it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n- * more details.\n- */\n-\n-#include \"globals.h\"\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <unistd.h>\n-#include <ctype.h>\n-\n-char *ceed_ops[KEY_ARR_SZ];\n-\n-void print_ceed_usage(int argc, char *argv[]) {\n-\n-  printf(\"Usage: %s -p prj -i 192.168.99.100 -s 10000 -b\\n\", argv[0]);\n-  printf(\"\t-i CODI ip address [default: 127.0.0.1 (linux) or 192.168.99.100 (win/mac)]\\n\");\n-  printf(\"\t-s CODI listening port [default: 10000]\\n\");\n-  printf(\"\t-l list available build containers\\n\");\n-  printf(\"\t-d container_id. Send command to container_id\\n\");\n-  printf(\"\t-p prj_name [required]\\n\");\n-  printf(\"\t-b build project [NOTE: -b and -c are mutually exclusive]\\n\");\n-  printf(\"\t-c clean project [NOTE: -c and -b are mutually exclusive]\\n\");\n-  printf(\"\t-t autotools project [NOTE: -t and -k and -m are mutually exclusive]\\n\");\n-  printf(\"\t-k cmake project [NOTE: -k and -t and -m are mutually exclusive]\\n\");\n-  printf(\"\t-m target make makefile_target [NOTE: -m and -t and -k are mutually exclusive]\\n\");\n-  printf(\"\t-g gen_cmd execute generic command\\n\");\n-  printf(\"\t-r args generic command arguments\\n\");\n-  printf(\"\t-e env environment variables\\n\");\n-  printf(\"\t-h print this help menu\\n\");\n-  printf(\"\t-v show ceed version\\n\");\n-  exit(EXIT_FAILURE);\n-}\n-\n-void init_ceed_params(){\n-#if defined(_WIN32) || defined(__CYGWIN__)\n-  ceed_ops[KEY('a')] = \"win\";\n-  ceed_ops[KEY('i')] = CODI_IP_VIRT;\n-#elif __APPLE__\n-  ceed_ops[KEY('a')] = \"mac\";\n-  ceed_ops[KEY('i')] = CODI_IP_VIRT;\n-#elif __linux\n-  ceed_ops[KEY('a')] = \"linux\";\n-  ceed_ops[KEY('i')] = CODI_IP_NATIVE;\n-#endif\n-  ceed_ops[KEY('p')] = NULL;\n-  ceed_ops[KEY('s')] = CODI_PORT;\n-  ceed_ops[KEY('v')] = VERSION;\n-  ceed_ops[KEY('r')] = \" \";\n-  ceed_ops[KEY('z')] = CEED_NAME;\n-}\n-\n-void parse_ceed_params(int argc, char *argv[]) {\n-  int c, b_flg = 0, c_flg = 0, t_flg = 0, m_flg = 0, k_flg = 0;\n-\n-  init_ceed_params();\n-\n-  while((c = getopt(argc, argv, \"hvltm:kbcp:i:s:g:r:d:\")) != -1) {\n-    switch (c) {\n-    case 'h':\n-      print_ceed_usage(argc, argv);\n-      exit(EXIT_SUCCESS);\n-      break;\n-    case 'v':\n-      INFO(\"ceed version : %s\\n\", VERSION);\n-      exit(EXIT_SUCCESS);\n-      break;\n-    case 'p':\n-      ceed_ops[KEY('p')] = optarg;\n-      break;\n-    case 'i':\n-      ceed_ops[KEY('i')] = optarg;\n-      break;\n-    case 's':\n-      ceed_ops[KEY('s')] = optarg;\n-      break;\n-    case 'g':\n-      ceed_ops[KEY('g')] = optarg;\n-      break;\n-    case 'r':\n-      ceed_ops[KEY('r')] = optarg;\n-      break;\n-    case 'd':\n-      ceed_ops[KEY('d')] = optarg;\n-      break;\n-    case 'l':\n-        asprintf(&ceed_ops[KEY('l')] , \"set\");\n-      break;\n-    case 'b':\n-      if(c_flg) {\n-        print_ceed_usage(argc, argv);\n-      } else {\n-        b_flg++;\n-        asprintf(&ceed_ops[KEY('b')] , \"set\");\n-      }\n-      break;\n-    case 'c':\n-      if(b_flg) {\n-        print_ceed_usage(argc, argv);\n-      } else {\n-        c_flg++;\n-        asprintf(&ceed_ops[KEY('c')] , \"set\");\n-      }\n-      break;\n-    case 't':\n-      if(m_flg || k_flg) {\n-        print_ceed_usage(argc, argv);\n-      } else {\n-        t_flg++;\n-        asprintf(&ceed_ops[KEY('t')] , \"set\");\n-      }\n-      break;\n-    case 'm':\n-      if(t_flg || k_flg)\n-        print_ceed_usage(argc, argv);\n-      else {\n-        m_flg++;\n-        ceed_ops[KEY('m')] = optarg;\n-      }\n-      break;\n-    case 'k':\n-      if(t_flg || m_flg)\n-        print_ceed_usage(argc, argv);\n-      else {\n-        k_flg++;\n-        asprintf(&ceed_ops[KEY('k')] , \"set\");\n-      }\n-      break;\n-    case '?':\n-      if (optopt == 'p' || optopt == 'i' || optopt == 's' || optopt == 'm')\n-        ERR(\"Option -%c requires an argument.\\n\", optopt);\n-      else if (isprint(optopt))\n-        ERR(\"Unknown option `-%c'.\\n\", optopt);\n-      else\n-        ERR(\"Unknown option character `\\\\x%x'.\\n\", optopt);\n-    default:\n-      print_ceed_usage(argc, argv);\n-    }\n-  }\n-\n-  if ((ceed_ops[KEY('l')] == NULL && ceed_ops[KEY('p')] == NULL && ceed_ops[KEY('g')] == NULL )\n-    || (ceed_ops[KEY('i')] == NULL || ceed_ops[KEY('s')] == NULL)) {\n-    print_ceed_usage(argc, argv);\n-  }\n-}\n-\ndiff --git a/ceed/ceed_api.h b/ceed/ceed_api.h\ndeleted file mode 100755\nindex a66e6e6..0000000\n--- a/ceed/ceed_api.h\n+++ /dev/null\n@@ -1,22 +0,0 @@\n-/*\n- * Copyright (C) 2016 Intel Corporation\n- *\n- * Author: Todor Minchev <todor.minchev@linux.intel.com>\n- *\n- * This program is free software; you can redistribute it and/or modify it\n- * under the terms and conditions of the GNU General Public License,\n- * version 2, or (at your option) any later version, as published by\n- * the Free Software Foundation.\n- *\n- * This program is distributed in the hope it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n- * more details.\n- */\n-\n-#ifndef CEED_API_H\n-#define CEED_API_H\n-\n-void parse_ceed_params(int argc, char *argv[]);\n-\n-#endif\ndiff --git a/codi/Makefile b/codi/Makefile\ndeleted file mode 100644\nindex 0b8135c..0000000\n--- a/codi/Makefile\n+++ /dev/null\n@@ -1,19 +0,0 @@\n-CFLAGS=-g -I. -I../\n-LDFLAGS=-lsqlite3 -lm -ljansson -lcurl -lpthread\n-DEPS = ../globals.h ../utils.h codi_api.h codi_db.h codi_launcher.h codi_list.h\n-OBJ = codi.o codi_db.o codi_list.o codi_launcher.o codi_api.o ../utils.o ../globals.o\n-\n-all: codi\n-\n-debug: DFLAGS = -DDBG\n-debug: clean codi\n-\n-%.o: %.c $(DEPS)\n-\t$(CC) -c -o $@ $< $(CFLAGS) $(DFLAGS)\n-\n-codi: $(OBJ)\n-\t$(CC) -o $@ $^ $(CFLAGS) $(LDFLAGS)\n-\n-.PHONY: clean\n-clean:\n-\trm -rf $(OBJ) codi\ndiff --git a/codi/codi.c b/codi/codi.c\ndeleted file mode 100644\nindex e24a03c..0000000\n--- a/codi/codi.c\n+++ /dev/null\n@@ -1,126 +0,0 @@\n-/*\n- * Copyright (C) 2016 Intel Corporation\n- *\n- * Author: Todor Minchev <todor.minchev@linux.intel.com>\n- *\n- * This program is free software; you can redistribute it and/or modify it\n- * under the terms and conditions of the GNU General Public License,\n- * version 2, or (at your option) any later version, as published by\n- * the Free Software Foundation.\n- *\n- * This program is distributed in the hope it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n- * more details.\n- */\n-\n-#include \"globals.h\"\n-#include <stdlib.h>\n-#include <signal.h>\n-#include <netdb.h>\n-#include <arpa/inet.h>\n-#include <pthread.h>\n-#include \"utils.h\"\n-#include \"codi_db.h\"\n-#include \"codi_api.h\"\n-#include \"codi_list.h\"\n-#include \"codi_launcher.h\"\n-\n-extern char *codi_ops[];\n-int codi_sock_fd;\n-/*\n-pthread_mutex_t lock;\n-*/\n-\n-/*TODO - close sockets on CTRL+C. Get rid of this when running as a daemon */\n-void close_sockets(int dummy) {\n-  close(codi_sock_fd);\n-  INFO(\"\\nClosed CODI socket. Exiting!\\n\") ;\n-  exit(0);\n-}\n-\n-int main(int argc, char *argv[]) {\n-  struct addrinfo *addr_p;\n-  int i, cli_sock_fd;\n-  const char *codi_port = (const char*) CODI_PORT;\n-  turff_node *req_node = NULL;\n-  char *cli_params[KEY_ARR_SZ], *ip, *docker_url, *tmp_str;\n-  socklen_t cli_len;\n-  struct sockaddr cli_addr;\n-  struct sockaddr_in *cli_ip;\n-\n-  parse_codi_params(argc, argv);\n-\n-  for (i = 0; i <  KEY_ARR_SZ; i++)\n-    cli_params[i] = NULL;\n-\n-  addr_p = bind_to_socket(NULL, codi_port, &codi_sock_fd);\n-\n-  if (addr_p == NULL) {\n-    ERR(\"Could not bind CODI to socket\\n\");\n-  } else {\n-    INFO(\"CODI listening on port: %s\\n\", codi_port);\n-\n-  }\n-\n-  listen(codi_sock_fd,1);\n-  cli_len = sizeof(cli_addr);\n-\n-  signal(SIGINT, close_sockets);\n-\n-  while(1) {\n-    cli_sock_fd = accept(codi_sock_fd, &cli_addr, &cli_len);\n-\n-    if (cli_sock_fd < 0)\n-      ERR(\"ERROR on accept\");\n-\n-    free_params(cli_params);\n-    receive_args(cli_sock_fd, cli_params);\n-\n-    /*turff registration*/\n-    if (!strcmp(cli_params[KEY('z')], TURFF_NAME)) {\n-      cli_ip = (struct sockaddr_in*) &cli_addr;\n-      asprintf(&ip, \"%s\", inet_ntoa(cli_ip->sin_addr));\n-      cli_params[KEY('c')] = ip;\n-      db_insert_node(cli_params[KEY('n')], cli_params[KEY('c')],  cli_params[KEY('s')]);\n-      INFO(\"\\nToolchain registration received: %s : %s : %s \\n\", cli_params[KEY('n')],\n-      cli_params[KEY('c')], cli_params[KEY('s')]) ;\n-    } else if (!strcmp(cli_params[KEY('z')], CEED_NAME) && (cli_params[KEY('l')] != NULL )) {\n-      /* ceed request for available toolchains */\n-      return_turff_nodes(cli_sock_fd);\n-    } else if (!strcmp(cli_params[KEY('z')], CEED_NAME) && (cli_params[KEY('d')] != NULL )) {\n-      /* must be a command from ceed*/\n-      req_node = find_turff_node(cli_params[KEY('d')]);\n-      if (req_node != NULL) {\n-\n-        /* check if docker engine is listening on a unix socket or tcp*/\n-        if (codi_ops[KEY('i')] == NULL || codi_ops[KEY('p')] == NULL) {\n-          asprintf(&docker_url, \"%s\", codi_ops[KEY('u')]);\n-        } else {\n-          asprintf(&docker_url, \"%s:%s\", codi_ops[KEY('i')], codi_ops[KEY('p')]);\n-        }\n-\n-        if (is_container_running(docker_url, cli_params[KEY('d')])) {\n-          process_ceed_cmd(req_node, cli_sock_fd, cli_params);\n-        } else {\n-          asprintf(&tmp_str, \"Container %s is not running\\n%s\",\n-            cli_params[KEY('d')], TURFF_EOM);\n-          send_data(cli_sock_fd, tmp_str, strlen(tmp_str));\n-          free(tmp_str);\n-        }\n-        free(docker_url);\n-      } else {\n-        asprintf(&tmp_str, \"Container %s not found in database\\n%s\",\n-          cli_params[KEY('d')], TURFF_EOM);\n-        send_data(cli_sock_fd, tmp_str, strlen(tmp_str));\n-        free(tmp_str);\n-      }\n-    } else {\n-      asprintf(&tmp_str, \"Invalid command sent to CODI\\n%s\", TURFF_EOM);\n-      send_data(cli_sock_fd, tmp_str, strlen(tmp_str));\n-      free(tmp_str);\n-    }\n-\n-    free_params(cli_params);\n-  }\n-}\ndiff --git a/codi/codi_api.c b/codi/codi_api.c\ndeleted file mode 100644\nindex b9eff56..0000000\n--- a/codi/codi_api.c\n+++ /dev/null\n@@ -1,134 +0,0 @@\n-/*\n- * Copyright (C) 2016 Intel Corporation\n- *\n- * Author: Todor Minchev <todor.minchev@linux.intel.com>\n- *\n- * This program is free software; you can redistribute it and/or modify it\n- * under the terms and conditions of the GNU General Public License,\n- * version 2, or (at your option) any later version, as published by\n- * the Free Software Foundation.\n- *\n- * This program is distributed in the hope it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n- * more details.\n- */\n-\n-#include \"globals.h\"\n-#include <stdlib.h>\n-#include <ctype.h>\n-#include \"utils.h\"\n-#include \"codi_api.h\"\n-#include \"codi_list.h\"\n-#include \"codi_launcher.h\"\n-\n-char *codi_ops[KEY_ARR_SZ];\n-\n-void print_codi_usage(int argc, char *argv[])\n-{\n-  printf(\"Usage: %s \\n\", argv[0]);\n-  printf(\" -s port number on which CODI is listening [default: 10000]\\n\");\n-  printf(\" -u unix socket path of Docker engine [default: /var/lib/docker.sock]\\n\");\n-  printf(\" -i ip address of Docker engine [default: 127.0.0.1]\\n\");\n-  printf(\" -p port number of Docker engine [default: 2376]\\n\");\n-  printf(\" -h print this help menu\\n\");\n-  printf(\" -v show CODI version\\n\");\n-}\n-\n-void init_codi_params()\n-{\n-  int i;\n-\n-  for (i = 0; i <  KEY_ARR_SZ; i++)\n-    codi_ops[i] = NULL;\n-\n-  codi_ops[KEY('s')] = CODI_PORT;\n-  codi_ops[KEY('v')] = VERSION;\n-  codi_ops[KEY('i')] = NULL;\n-  codi_ops[KEY('p')] = NULL;\n-  codi_ops[KEY('u')] = DOCKER_UNIX_SOCKET;\n-  codi_ops[KEY('z')] = CODI_NAME;\n-}\n-\n-void parse_codi_params(int argc, char *argv[])\n-{\n-  int c, i_flg = 0, p_flg = 0, u_flg = 0;\n-\n-  init_codi_params() ;\n-\n-  while ((c = getopt(argc, argv, \"hvs:i:p:u:\")) != -1) {\n-    switch (c) {\n-    case 'h':\n-      print_codi_usage(argc, argv);\n-      exit(EXIT_SUCCESS);\n-      break;\n-    case 'v':\n-      INFO(\"CODI version : %s\\n\", VERSION);\n-      exit(EXIT_SUCCESS);\n-      break;\n-    case 's':\n-      codi_ops[KEY('s')]  = optarg;\n-      break;\n-    case 'i':\n-      if(u_flg) {\n-        print_codi_usage(argc, argv);\n-      } else {\n-        i_flg++;\n-        codi_ops[KEY('i')]  = optarg;\n-      }\n-      break;\n-    case 'p':\n-      if(u_flg) {\n-        print_codi_usage(argc, argv);\n-      } else {\n-        p_flg++;\n-        codi_ops[KEY('p')]  = optarg;\n-      }\n-      break;\n-    case 'u':\n-      if(i_flg || p_flg) {\n-        print_codi_usage(argc, argv);\n-      } else {\n-        u_flg++;\n-        codi_ops[KEY('u')]  = optarg;\n-      }\n-      break;\n-    case '?':\n-      if (optopt == 's' || optopt == 'i' || optopt == 'p' || optopt == 'u')\n-        INFO(\"Option -%c requires an argument.\\n\", optopt);\n-      else if (isprint (optopt))\n-        INFO(\"Unknown option `-%c'.\\n\", optopt);\n-      else\n-        INFO(\"Unknown option character `\\\\x%x'.\\n\", optopt);\n-    default:\n-      print_codi_usage(argc, argv);\n-      exit(EXIT_FAILURE);\n-    }\n-  }\n-}\n-\n-int process_ceed_cmd(turff_node *t_node, int ceed_sock_fd, char *ceed_params[])\n-{\n-  struct addrinfo *addr_p;\n-  int turff_sock_fd;\n-\n-  addr_p = connect_to_socket(t_node->ip, t_node->port, &turff_sock_fd);\n-\n-  if (addr_p == NULL) {\n-    INFO(\"Could not connect to node id: %s ip: %s port: %s\\n\",\n-    t_node->id, t_node->ip, t_node->port);\n-    return 1;\n-  } else {\n-    INFO(\"Connected to node id: %s ip: %s port: %s\\n\",\n-      t_node->id, t_node->ip, t_node->port);\n-\n-    /* change the source signature of the param array */\n-    asprintf(&(ceed_params[KEY('z')]), \"%s\", CODI_NAME);\n-\n-    /* forward parameters to turff */\n-    send_args(turff_sock_fd, ceed_params);\n-    redirect_sockets(turff_sock_fd, ceed_sock_fd);\n-  }\n-  close(turff_sock_fd);\n-  return 0;\n-}\ndiff --git a/codi/codi_api.h b/codi/codi_api.h\ndeleted file mode 100644\nindex c5813dd..0000000\n--- a/codi/codi_api.h\n+++ /dev/null\n@@ -1,25 +0,0 @@\n-/*\n- * Copyright (C) 2016 Intel Corporation\n- *\n- * Author: Todor Minchev <todor.minchev@linux.intel.com>\n- *\n- * This program is free software; you can redistribute it and/or modify it\n- * under the terms and conditions of the GNU General Public License,\n- * version 2, or (at your option) any later version, as published by\n- * the Free Software Foundation.\n- *\n- * This program is distributed in the hope it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n- * more details.\n- */\n-\n-#ifndef CODI_API_H\n-#define CODI_API_H\n-\n-#include \"codi_list.h\"\n-\n-int process_ceed_cmd(turff_node *t_node, int ceed_sock_fd, char *ceed_params[]);\n-void parse_codi_params(int argc, char *argv[]);\n-\n-#endif\ndiff --git a/codi/codi_db.c b/codi/codi_db.c\ndeleted file mode 100644\nindex 91ab5bd..0000000\n--- a/codi/codi_db.c\n+++ /dev/null\n@@ -1,137 +0,0 @@\n-/*\n- * Copyright (C) 2016 Intel Corporation\n- *\n- * Author: Todor Minchev <todor.minchev@linux.intel.com>\n- *\n- * This program is free software; you can redistribute it and/or modify it\n- * under the terms and conditions of the GNU General Public License,\n- * version 2, or (at your option) any later version, as published by\n- * the Free Software Foundation.\n- *\n- * This program is distributed in the hope it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n- * more details.\n- */\n-\n-#include \"globals.h\"\n-#include <stdlib.h>\n-#include <sqlite3.h>\n-#include \"codi_db.h\"\n-#include \"codi_list.h\"\n-\n-static sqlite3 *codi_db;\n-\n-/* connect */\n-int db_connect(void)\n-{\n-  int result;\n-  result = sqlite3_open(CODI_DB, &codi_db);\n-\n-  if (result != SQLITE_OK ) {\n-    INFO(\"SQL error: %s\\n\", sqlite3_errmsg(codi_db));\n-    sqlite3_close(codi_db);\n-    return -1;\n-  }\n-\n-  return init_db();\n-}\n-\n-int init_db(void)\n-{\n-  int result;\n-  char *err = 0;\n-  char *qry = \"CREATE TABLE IF NOT EXISTS nodes(id TEXT UNIQUE NOT NULL \\\n-    CHECK(id <> ''), ip TEXT NOT NULL CHECK(ip <> ''), port TEXT NOT NULL \\\n-    CHECK(port <> ''), date TEXT NOT NULL CHECK(date <> ''));\";\n-\n-  result = sqlite3_exec(codi_db, qry, 0, 0, &err);\n-\n-  if (result != SQLITE_OK) {\n-    INFO(\"SQL error: %s\\n\", err);\n-    sqlite3_free(err);\n-    sqlite3_close(codi_db);\n-    return 1;\n-  }\n-\n-  return 0;\n-}\n-\n-/* insert node */\n-int db_insert_node(char *id, char *ip, char *port)\n-{\n-  int result;\n-  char *qry, *err = 0;\n-  turff_node *node;\n-\n-  node = find_turff_node(id);\n-\n-  /* if a node with this id exists just update it*/\n-  if (node != NULL) {\n-    asprintf(&qry, \"UPDATE nodes SET ip = '%s', port = '%s', date = \\\n-    datetime(CURRENT_TIMESTAMP, 'localtime') WHERE ID = '%s';\", ip, port, id);\n-  }\n-  else {\n-    asprintf(&qry, \"INSERT INTO nodes (id, ip, port, date) VALUES ('%s','%s', \\\n-    '%s', datetime(CURRENT_TIMESTAMP, 'localtime'));\", id, ip, port);\n-  }\n-\n-  result = exec_db_query(qry, 0, 0, &err);\n-  free(qry);\n-\n-  return result;\n-}\n-\n-int exec_db_query(const char *sql, int (*callback)(void*, int, char**, char**), \\\n-  void *callback_arg, char **errmsg)\n-{\n-  int result;\n-\n-  if (db_connect() != 0)\n-    return -1;\n-\n-  result = sqlite3_exec(codi_db, sql, callback, callback_arg, errmsg);\n-\n-  if (result != SQLITE_OK) {\n-    INFO(\"SQL insert error: %s\\n\", *errmsg);\n-    sqlite3_free(*errmsg);\n-    sqlite3_close(codi_db);\n-    return result;\n-  }\n-  sqlite3_close(codi_db);\n-  return SQLITE_OK;\n-}\n-\n-static int find_node_callback(void *dummy, int argc, char **argv, char **col_name)\n-{\n-  int i;\n-\n-  /* no records were found */\n-  if(argc == 0)\n-    return 1;\n-\n-  add_turff_node(argv[0], argv[1], argv[2], argv[3]);\n-\n-  return 0;\n-}\n-\n-/* find node(s) - gets all nodes if id is NULL */\n-int get_db_nodes(char *id)\n-{\n-  int result;\n-  char *qry, *err = 0;\n-\n-  /* remove all nodes from the list before reading them from the db*/\n-  free_turff_nodes_list();\n-\n-  /* get all nodes */\n-  if (id == NULL)\n-    asprintf(&qry, \"SELECT * FROM nodes;\");\n-  else\n-    asprintf(&qry, \"SELECT * from nodes WHERE id='%s';\", id);\n-\n-  result = exec_db_query(qry, find_node_callback, 0, &err);\n-  free(qry);\n-\n-  return result;\n-}\ndiff --git a/codi/codi_db.h b/codi/codi_db.h\ndeleted file mode 100644\nindex c6fd586..0000000\n--- a/codi/codi_db.h\n+++ /dev/null\n@@ -1,28 +0,0 @@\n-/*\n- * Copyright (C) 2016 Intel Corporation\n- *\n- * Author: Todor Minchev <todor.minchev@linux.intel.com>\n- *\n- * This program is free software; you can redistribute it and/or modify it\n- * under the terms and conditions of the GNU General Public License,\n- * version 2, or (at your option) any later version, as published by\n- * the Free Software Foundation.\n- *\n- * This program is distributed in the hope it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n- * more details.\n- */\n-\n-#ifndef CODI_DB_H\n-#define CODI_DB_H\n-\n-#define CODI_DB      \"codi.db\"\n-\n-int init_db(void);\n-int db_insert_node(char *id, char *ip, char *port);\n-int exec_db_query(const char *sql, int (*callback)(void*, int, char**, char**), \\\n-  void *callback_arg, char **errmsg);\n-int get_db_nodes(char *id);\n-\n-#endif\ndiff --git a/codi/codi_launcher.c b/codi/codi_launcher.c\ndeleted file mode 100644\nindex 1087761..0000000\n--- a/codi/codi_launcher.c\n+++ /dev/null\n@@ -1,146 +0,0 @@\n-/*\n- * Copyright (C) 2016 Intel Corporation\n- *\n- * Author: Todor Minchev <todor.minchev@linux.intel.com>\n- *\n- * This program is free software; you can redistribute it and/or modify it\n- * under the terms and conditions of the GNU General Public License,\n- * version 2, or (at your option) any later version, as published by\n- * the Free Software Foundation.\n- *\n- * This program is distributed in the hope it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n- * more details.\n- */\n-\n-#include \"globals.h\"\n-#include <jansson.h>\n-#include <string.h>\n-#include <curl/curl.h>\n-#include <ctype.h>\n-#include \"codi_launcher.h\"\n-\n-/* execute the request and return an array of json objects */\n-json_t *request_json(char *request_method, char *url, char *api, char *data)\n-{\n-  char *in = 0, *j_start;\n-  json_t *root;\n-  json_error_t err;\n-\n-  in = curl_request(request_method, url, api, data);\n-\n-  /* skip the header and move to the json array */\n-  j_start = strchr(in, '[');\n-  root = json_loads(j_start, 0, &err);\n-  free(in);\n-  return root;\n-}\n-\n-/* execute the request and return the raw server reply */\n-char *curl_request(char *http_method, char *url, char *api,  char *data)\n-{\n-\n-  CURL *curl = NULL;\n-  CURLcode res;\n-  struct curl_slist *api_hdr = NULL;\n-  curl_mem_chunk_t srv_reply ;\n-  char *request_str ;\n-\n-  srv_reply.mem = calloc(1, 1) ;\n-\n-  if (srv_reply.mem == NULL)\n-    ERR(\"ERROR: Unable to allocate memory\");\n-\n-  srv_reply.size = 0 ;\n-  curl = curl_easy_init();\n-\n-  if (curl) {\n-    /* check if url is a unix socket*/\n-    if (url[0] == '/') {\n-      /* map the unix socket as a connection endpoint */\n-      curl_easy_setopt(curl, CURLOPT_UNIX_SOCKET_PATH, url);\n-      asprintf(&request_str, \"%s%s\", \"http:\", api);\n-    } else {\n-        asprintf(&request_str, \"%s%s%s\",  \"http://\", url, api);\n-    }\n-\n-    curl_easy_setopt(curl, CURLOPT_URL, request_str);\n-\n-    if (!strcmp(http_method, POST_REQUEST)) {\n-      curl_easy_setopt(curl, CURLOPT_POST, 1L);\n-      api_hdr = curl_slist_append(api_hdr, \"Content-Type: application/json\");\n-      api_hdr = curl_slist_append(api_hdr, \"Expect:\");\n-      curl_easy_setopt(curl, CURLOPT_HTTPHEADER, api_hdr);\n-\n-      if (data == NULL)\n-        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, \"\");\n-      else\n-        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, data);\n-    }\n-\n-    curl_easy_setopt(curl, CURLOPT_HEADER, 1);\n-    curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *) &srv_reply);\n-    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, process_srv_reply);\n-\n-#ifdef DBG\n-    curl_easy_setopt(curl, CURLOPT_VERBOSE, 1);\n-#endif\n-\n-    res = curl_easy_perform(curl);\n-\n-    if (res != CURLE_OK)\n-      INFO(\"curl_easy_perform() failed: %s\\n\", curl_easy_strerror(res));\n-\n-    if (!strcmp(http_method, POST_REQUEST))\n-      curl_slist_free_all(api_hdr);\n-\n-    free(request_str);\n-    curl_easy_cleanup(curl);\n-  }\n-\n-  return srv_reply.mem;\n-}\n-\n-size_t process_srv_reply(void *ptr, size_t size, size_t nmemb, void *reply_p)\n-{\n-  size_t chunk_size = size * nmemb;\n-\n-  curl_mem_chunk_t *mem_chunk = (curl_mem_chunk_t *)reply_p;\n-\n-  /* append chunk_size memory block to the original memory block */\n-  mem_chunk->mem = realloc(mem_chunk->mem, mem_chunk->size + chunk_size + 1);\n-  if (mem_chunk->mem == NULL)\n-    ERR(\"not enough memory (realloc returned NULL)\\n\");\n-\n-  INFO(\"%s\", ptr);\n-\n-  /* copy the data into the newly allocated chunk */\n-  memcpy(&(mem_chunk->mem[mem_chunk->size]), ptr, chunk_size);\n-  mem_chunk->size += chunk_size;\n-  mem_chunk->mem[mem_chunk->size] = 0;\n-  return chunk_size;\n-}\n-\n-bool is_container_running(char *url, char *cont_name)\n-{\n-  char *api_str = NULL;\n-  json_t *result;\n-\n-  asprintf(&api_str, RUNNING_NAMED_CONTAINER, cont_name);\n-  result = request_json(GET_REQUEST, url, api_str, NULL);\n-  free(api_str);\n-\n-  if (json_array_size(result)) {\n-    json_decref(result);\n-    return true;\n-  } else {\n-\n-#ifdef DBG\n-  INFO(\"Container : %s is not running\\n\", cont_name);\n-#endif\n-\n-    json_decref(result);\n-    return false;\n-  }\n-}\ndiff --git a/codi/codi_launcher.h b/codi/codi_launcher.h\ndeleted file mode 100644\nindex 1b81e49..0000000\n--- a/codi/codi_launcher.h\n+++ /dev/null\n@@ -1,58 +0,0 @@\n-/*\n- * Copyright (C) 2016 Intel Corporation\n- *\n- * Author: Todor Minchev <todor.minchev@linux.intel.com>\n- *\n- * This program is free software; you can redistribute it and/or modify it\n- * under the terms and conditions of the GNU General Public License,\n- * version 2, or (at your option) any later version, as published by\n- * the Free Software Foundation.\n- *\n- * This program is distributed in the hope it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n- * more details.\n- */\n-\n-#ifndef CODI_LAUNCHER_H\n-#define CODI_LAUNCHER_H\n-\n-#include <jansson.h>\n-#include \"globals.h\"\n-\n-\n-/* Docker Remote API requests */\n-#define GET_REQUEST              \"GET\"\n-#define POST_REQUEST             \"POST\"\n-#define DOCKER_UNIX_SOCKET       \"/var/run/docker.sock\"\n-#define DOCKER_ENG_IP            \"127.0.0.1\"\n-#define DOCKER_ENG_PORT       \t \"2376\"\n-#define GET_IMAGES               \"/images/json\"\n-#define ALL_CONTAINERS           \"/containers/json?all=true\"\n-#define START_CONTAINER          \"/containers/%s/start\"\n-#define CREATE_CONTAINER         \"/containers/create?name=%s\"\n-#define GET_IMAGE                \"/images/create?fromImage=%s&tag=%s\"\n-\n-#define NAMED_CONTAINER          \"/containers/json?all=true&filters=\" \\\n-                                 \"{%%22name%%22:[%%22%s%%22]}\"\n-\n-#define RUNNING_NAMED_CONTAINER  \"/containers/json?all=true&filters=\" \\\n-                                 \"{%%22name%%22:[%%22%s%%22],%%22status%%22:[%%22running%%22]}\"\n-\n-/* Docker Engine Responses */\n-#define PULL_COMPLETE      \"Pull complete\"\n-#define IMAGE_UP_TO_DATE   \"Image is up to date\"\n-#define NO_ERROR_204       \"204 No Content\"\n-#define NOT_MODIFIED_304   \"304 Not Modified\"\n-#define CREATED_201        \"201 Created\"\n-#define OK_200             \"200 OK\"\n-\n-#define CONTAINER_PARAMS(...) #__VA_ARGS__\n-\n-char *curl_request(char *http_method, char *url, char *api,  char *data);\n-size_t process_srv_reply(void *ptr, size_t size, size_t nmemb, void *reply_p);\n-json_t *request_json(char *request_method, char *url, char *api, char *data);\n-bool is_container_running(char *url, char *cont_name);\n-bool start_container(char *url, char *cont_name);\n-\n-#endif\ndiff --git a/codi/codi_list.c b/codi/codi_list.c\ndeleted file mode 100644\nindex 4a3f745..0000000\n--- a/codi/codi_list.c\n+++ /dev/null\n@@ -1,100 +0,0 @@\n-/*\n- * Copyright (C) 2016 Intel Corporation\n- *\n- * Author: Todor Minchev <todor.minchev@linux.intel.com>\n- *\n- * This program is free software; you can redistribute it and/or modify it\n- * under the terms and conditions of the GNU General Public License,\n- * version 2, or (at your option) any later version, as published by\n- * the Free Software Foundation.\n- *\n- * This program is distributed in the hope it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n- * more details.\n- */\n-\n-#include \"globals.h\"\n-#include <stdlib.h>\n-#include <stdint.h>\n-#include <stdio.h>\n-#include <string.h>\n-#include \"utils.h\"\n-#include \"codi_db.h\"\n-#include \"codi_list.h\"\n-\n-turff_node *head = NULL;\n-\n-turff_node *find_turff_node(char *id)\n-{\n-\n-  /* clear the list and read the nodes from the db*/\n-  get_db_nodes(id);\n-  turff_node *cur = head;\n-\n-  while (cur != NULL) {\n-    if(!strcmp(cur->id, id))\n-      return cur;\n-    else\n-      cur = cur->next;\n-  }\n-  return NULL;\n-}\n-\n-void free_turff_nodes_list()\n-{\n-  turff_node *tmp = NULL;\n-\n-  while (head != NULL) {\n-    free(head->id);\n-    free(head->ip);\n-    free(head->port);\n-    free(head->date);\n-    tmp = head ;\n-    head = head->next;\n-    free(tmp);\n-  }\n-}\n-\n-void add_turff_node(char *id, char *ip, char *port, char *date)\n-{\n-  int node_exists = 0;\n-  turff_node *node;\n-\n-  node = calloc(1, sizeof(turff_node));\n-  asprintf(&(node->id), \"%s\", id);\n-  asprintf(&(node->ip), \"%s\", ip);\n-  asprintf(&(node->port), \"%s\",  port);\n-  asprintf(&(node->date), \"%s\",  date);\n-  node->next = head;\n-  head = node;\n-}\n-\n-\n-/* send these to ceed*/\n-void return_turff_nodes(int sock_fd)\n-{\n-  int i;\n-  char *tmp_node[KEY_ARR_SZ];\n-\n-  /* clear the list and read the nodes from the db*/\n-  get_db_nodes(NULL);\n-  turff_node *cur = head;\n-\n-  for (i = 0; i <  KEY_ARR_SZ; i++)\n-    tmp_node[i] = NULL;\n-\n-  while (cur != NULL) {\n-    tmp_node[KEY('d')] = cur->id;\n-\n-#ifdef DBG\n-    DEBUG(\"Sent turff node id : %s ip: %s port %s\\n\", cur->id, cur->ip, cur->port);\n-#endif\n-\n-    send_args(sock_fd, tmp_node);\n-    cur = cur->next;\n-  }\n-\n-  tmp_node[KEY('e')] = \"set\";\n-  send_args(sock_fd, tmp_node);\n-}\ndiff --git a/codi/codi_list.h b/codi/codi_list.h\ndeleted file mode 100644\nindex 4ce5301..0000000\n--- a/codi/codi_list.h\n+++ /dev/null\n@@ -1,33 +0,0 @@\n-/*\n- * Copyright (C) 2016 Intel Corporation\n- *\n- * Author: Todor Minchev <todor.minchev@linux.intel.com>\n- *\n- * This program is free software; you can redistribute it and/or modify it\n- * under the terms and conditions of the GNU General Public License,\n- * version 2, or (at your option) any later version, as published by\n- * the Free Software Foundation.\n- *\n- * This program is distributed in the hope it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n- * more details.\n- */\n-\n-#ifndef CODI_LIST_H\n-#define CODI_LIST_H\n-\n-typedef struct list_node{\n-  char *id;\n-  char *ip;\n-  char *port;\n-  char *date;\n-  struct list_node *next;\n-} turff_node;\n-\n-turff_node *find_turff_node(char *id);\n-void add_turff_node(char *id, char *ip, char *port, char *date);\n-void return_turff_nodes();\n-void free_turff_nodes_list();\n-\n-#endif\ndiff --git a/confs/ostro/ostro.conf b/confs/ostro/ostro.conf\ndeleted file mode 100644\nindex 796104b..0000000\n--- a/confs/ostro/ostro.conf\n+++ /dev/null\n@@ -1,16 +0,0 @@\n-# allows a standard development build. Read the ostro docs for production settings.\n-require conf/distro/include/ostro-os-development.inc\n-# default ostro mirror, used for speedup!!!\n-SSTATE_MIRRORS ?= \"file://.* http://download.ostroproject.org/sstate/ostro-os/PATH\"\n-# puts results on the shared host folder\n-# windows can't do this due to lack of ln -s support on shared volumes\n-#DEPLOY_DIR_IMAGE = \"/ostro/ostro-shared/images\"\n-# windows hangs on this. Currently unsure why.\n-#SSTATE_DIR = \"/ostro/ostro-shared/sstate\"\n-DL_DIR = \"/ostro/ostro-shared/downloads\"\n-# lets bitbake ignore the odd inode settings of the shared directory\n-BB_DISKMON_DIRS = \"\\\n-    STOPTASKS,${TMPDIR},1G,100K \\\n-    ABORT,${TMPDIR},100M,1K \"\n-# keep workdir small\n-INHERIT+=\"rm_work\"\ndiff --git a/confs/ostro/ostro.layers b/confs/ostro/ostro.layers\ndeleted file mode 100644\nindex e69de29..0000000\ndiff --git a/dockerfiles/Dockerfile.ceed.deps b/dockerfiles/Dockerfile.ceed.deps\ndeleted file mode 100644\nindex f806613..0000000\n--- a/dockerfiles/Dockerfile.ceed.deps\n+++ /dev/null\n@@ -1,16 +0,0 @@\n-# This file describes the standard way to build the dependencies required for\n-# cross compiling ceed with mingw\n-#\n-# Usage:\n-#\n-# docker build -t crops/ceed:deps -f Dockerfile.ceed.deps .\n-\n-FROM debian:jessie\n-MAINTAINER Todor Minchev <todor.minchev@linux.intel.com>\n-\n-# Install dependencies\n-RUN apt-get update && apt-get install -y \\\n-  mingw-w64 \\\n-  gcc \\\n-  make\n-\ndiff --git a/dockerfiles/Dockerfile.ceed.linux b/dockerfiles/Dockerfile.ceed.linux\ndeleted file mode 100644\nindex 10fcf90..0000000\n--- a/dockerfiles/Dockerfile.ceed.linux\n+++ /dev/null\n@@ -1,19 +0,0 @@\n-# This file describes the standard way to cross compile ceed with mingw\n-#\n-# Example:\n-#\n-# docker build -t crops/ceed:0.1 -f Dockerfile.ceed.linux ../\n-\n-FROM crops/ceed:deps\n-MAINTAINER Todor Minchev <todor.minchev@linux.intel.com>\n-LABEL name=\"ceed-linux\"\n-\n-# Build and install CEED\n-RUN mkdir -p /usr/local/crops/ceed/\n-COPY ceed /usr/local/crops/ceed/\n-COPY utils.[ch] /usr/local/crops/\n-COPY globals.[ch] /usr/local/crops/\n-\n-RUN cd /usr/local/crops/ceed && \\\n-  CC=gcc make\n-\ndiff --git a/dockerfiles/Dockerfile.ceed.win b/dockerfiles/Dockerfile.ceed.win\ndeleted file mode 100644\nindex 7674c69..0000000\n--- a/dockerfiles/Dockerfile.ceed.win\n+++ /dev/null\n@@ -1,19 +0,0 @@\n-# This file describes the standard way to cross compile ceed with mingw\n-#\n-# Example:\n-#\n-# docker build -t crops/ceed:0.1 -f Dockerfile.ceed.win ../\n-\n-FROM crops/ceed:deps\n-MAINTAINER Todor Minchev <todor.minchev@linux.intel.com>\n-LABEL name=\"ceed-windows\"\n-\n-# Build and install CEED\n-RUN mkdir -p /usr/local/crops/ceed/\n-COPY ceed /usr/local/crops/ceed/\n-COPY utils.[ch] /usr/local/crops/\n-COPY globals.[ch] /usr/local/crops/\n-\n-RUN cd /usr/local/crops/ceed && \\\n-  CC=x86_64-w64-mingw32-gcc make\n-\ndiff --git a/dockerfiles/Dockerfile.codi b/dockerfiles/Dockerfile.codi\ndeleted file mode 100644\nindex cf6ef30..0000000\n--- a/dockerfiles/Dockerfile.codi\n+++ /dev/null\n@@ -1,34 +0,0 @@\n-# This file describes the standard way to build a CROPS dispatcher image\n-#\n-# Usage:\n-#\n-# # Build CODI image with the following command. Replace the \"version\" tag\n-# with the current codi version\n-#\n-# docker build -t crops/codi:version -f Dockerfile.codi ../\n-#\n-# Example: Build CODI version 0.1\n-#\n-# docker build -t crops/codi:0.1 -f Dockerfile.codi ../\n-\n-FROM crops/codi:deps\n-MAINTAINER Todor Minchev <todor.minchev@linux.intel.com>\n-\n-# Build and install CODI\n-RUN mkdir -p /usr/local/crops/codi/\n-COPY codi /usr/local/crops/codi/\n-COPY utils.[ch] /usr/local/crops/\n-COPY globals.[ch] /usr/local/crops/\n-ARG build_type\n-\n-RUN\tcd /usr/local/crops/codi && \\\n-\tmake $build_type && \\\n-\tmkdir -p /bin/codi && \\\n-\tcp /usr/local/crops/codi/codi /bin/codi/run && \\\n-\trm -rf /usr/local/crops\n-\n-# Monitor CODI and restart it on exit\n-ENTRYPOINT [\"supervise\", \"/bin/codi\"]\n-\n-# Default CODI port\n-EXPOSE 10000\ndiff --git a/dockerfiles/Dockerfile.codi.deps b/dockerfiles/Dockerfile.codi.deps\ndeleted file mode 100644\nindex dc563d0..0000000\n--- a/dockerfiles/Dockerfile.codi.deps\n+++ /dev/null\n@@ -1,31 +0,0 @@\n-# This file describes the standard way to build the dependencies for a CROPS\n-# dispatcher image\n-#\n-# Usage:\n-#\n-# # Build CODI dependencies image with the following command:\n-#\n-# docker build -t crops/codi:deps -f Dockerfile.codi.deps .\n-#\n-\n-FROM debian:wheezy\n-MAINTAINER Todor Minchev <todor.minchev@linux.intel.com>\n-\n-# Install dependencies\n-RUN apt-get update -qq && apt-get install -y -qq \\\n-\tlibsqlite3-dev \\\n-\tlibjansson-dev\t\\\n-\tgit\t\\\n-\twget \\\n-\tdaemontools \\\n-\tbuild-essential && \\\n-\tapt-get upgrade -y -qq\n-\n-#Install a version of curl with unix sockets support\n-RUN wget -q -P /tmp http://curl.haxx.se/download/curl-7.45.0.tar.gz && \\\n-\tcd /tmp && \\\n-\ttar xf curl-7.45.0.tar.gz && \\\n-\tcd curl-7.45.0 && \\\n-\t./configure --prefix=/usr --enable-unix-sockets && \\\n-\tmake && \\\n-\tmake install\ndiff --git a/dockerfiles/Dockerfile.ostro b/dockerfiles/Dockerfile.ostro\ndeleted file mode 100644\nindex b68e455..0000000\n--- a/dockerfiles/Dockerfile.ostro\n+++ /dev/null\n@@ -1,24 +0,0 @@\n-# This file describes the standard way to build an Ostro bitbake builder image\n-#\n-# Usage:\n-#\n-# docker build -t crops/ostro:builder -f Dockerfile.ostro ..\n-#\n-\n-FROM crops/ostro:deps\n-MAINTAINER Todor Minchev <todor.minchev@linux.intel.com>\n-\n-USER root\n-\n-RUN  mkdir -p /ostro/bin && \\\n-     mkdir -p /ostro/sample-conf && \\\n-     chmod -R a+rwx /ostro\n-COPY helpers/runbitbake.py /ostro/bin/runbitbake.py\n-COPY helpers/startOstroScript.sh /ostro/bin/startOstroScript.sh\n-COPY confs/ostro/ostro.conf /ostro/sample-conf/ostro.conf\n-\n-RUN   chmod +rx /ostro/bin/runbitbake.py && \\\n-      chmod +rx /ostro/bin/startOstroScript.sh && \\\n-      git clone https://github.com/ostroproject/ostro-os.git /ostro/ostro-os\n-\n-ENTRYPOINT [\"/ostro/bin/startOstroScript.sh\"]\ndiff --git a/dockerfiles/Dockerfile.ostro.deps b/dockerfiles/Dockerfile.ostro.deps\ndeleted file mode 100644\nindex d4da08f..0000000\n--- a/dockerfiles/Dockerfile.ostro.deps\n+++ /dev/null\n@@ -1,33 +0,0 @@\n-# This file describes the standard way to build the dependencies for Ostro bitbake build image\n-#\n-# Usage:\n-#\n-# docker build -t crops/ostro:deps -f Dockerfile.ostro.deps .\n-\n-FROM debian:jessie\n-MAINTAINER Todor Minchev <todor.minchev@linux.intel.com>\n-\n-# Install dependencies\n-RUN apt-get update && apt-get upgrade -y && apt-get install -y \\\n-  gawk \\\n-  wget \\\n-  git-core \\\n-  diffstat \\\n-  unzip \\\n-  sysstat \\\n-  texinfo \\\n-  gcc-multilib \\\n-  build-essential \\\n-  chrpath \\\n-  socat \\\n-  python \\\n-  libsdl1.2-dev  \\\n-  cpio \\\n-  sudo  \\\n-  rsync && \\\n-  apt-get clean && \\\n-  echo \"dash dash/sh boolean false\" | debconf-set-selections && \\\n-  DEBIAN_FRONTEND=noninteractive dpkg-reconfigure dash\n-\n-\n-CMD /bin/bash\ndiff --git a/dockerfiles/Dockerfile.toolchain b/dockerfiles/Dockerfile.toolchain\ndeleted file mode 100644\nindex c03fd90..0000000\n--- a/dockerfiles/Dockerfile.toolchain\n+++ /dev/null\n@@ -1,49 +0,0 @@\n-# This file describes the standard way to build a CROPS toolchain image\n-#\n-# Usage:\n-#\n-# 1) Replace the TOOLCHAIN_NAME and TOOLCHAIN_PATH environment variables below with\n-# the name and URL of your self-extracting toolchain\n-#\n-# Example:\n-#\n-# ENV TOOLCHAIN_NAME poky-glibc-x86_64-core-image-sato-i586-toolchain-2.0.sh\n-# ENV TOOLCHAIN_PATH http://downloads.yoctoproject.org/releases/yocto/yocto-2.0/toolchain/x86_64/\n-#\n-# 2) Build your toolchain image with the following command replacing my_tag with your target arch\n-# docker build -t crops/toolchain:my_tag -f Dockerfile.toolchain ../\n-#\n-# Example for i586 target:\n-# docker build -t crops/toolchain:i586 -f Dockerfile.toolchain ../\n-#\n-# The default configuration below will build an i586 toolchain for an x86_64 host\n-\n-FROM crops/toolchain:deps\n-MAINTAINER Todor Minchev <todor.minchev@linux.intel.com>\n-\n-ENV TOOLCHAIN_NAME poky-glibc-x86_64-core-image-sato-i586-toolchain-2.0.sh\n-ENV TOOLCHAIN_PATH http://downloads.yoctoproject.org/releases/yocto/yocto-2.0/toolchain/x86_64/\n-\n-# Build and install turff\n-RUN mkdir -p /usr/local/crops/turff/\n-COPY turff /usr/local/crops/turff/\n-COPY utils.[ch] /usr/local/crops/\n-COPY globals.[ch] /usr/local/crops/\n-\n-RUN cd /usr/local/crops/turff && \\\n-\tmake && \\\n-\tmkdir -p /bin/turff && \\\n-\tcp /usr/local/crops/turff/turff /bin/turff/run && \\\n-\tcp /usr/local/crops/turff/turff_launcher /bin/\n-\n-# Download and install toolchain\n-RUN wget -q -P /tmp ${TOOLCHAIN_PATH}${TOOLCHAIN_NAME} && \\\n-\tcd /tmp &&\t\\\n-\tchmod 755 ./${TOOLCHAIN_NAME} &&\t\\\n-\t./${TOOLCHAIN_NAME} -d /opt/poky/ -y\n-\n-# Make environment setup script executable and setup workspaces\n-RUN chmod 755 /opt/poky/environment-setup*\n-\n-# Container entry point\n-ENTRYPOINT [\"/bin/turff_launcher\", \"-f\", \"/opt/poky/environment-setup*\"]\ndiff --git a/dockerfiles/Dockerfile.toolchain.deps b/dockerfiles/Dockerfile.toolchain.deps\ndeleted file mode 100644\nindex ff809e6..0000000\n--- a/dockerfiles/Dockerfile.toolchain.deps\n+++ /dev/null\n@@ -1,18 +0,0 @@\n-# This file describes the standard way to build the dependencies for CROPS\n-# toolchain images\n-#\n-# Usage:\n-#\n-# docker build -t crops/toolchain:deps -f Dockerfile.toolchain.deps .\n-\n-FROM debian:wheezy\n-MAINTAINER Todor Minchev <todor.minchev@linux.intel.com>\n-\n-# Install dependencies\n-RUN apt-get update -qq && apt-get install -y -qq \\\n-\tpython\t\\\n-\tdaemontools \\\n-\tgit \\\n-\tbuild-essential \\\n-\twget\n-\ndiff --git a/dockerfiles/Dockerfile.zephyr b/dockerfiles/Dockerfile.zephyr\ndeleted file mode 100644\nindex 32068cb..0000000\n--- a/dockerfiles/Dockerfile.zephyr\n+++ /dev/null\n@@ -1,59 +0,0 @@\n-# This file describes the standard way to build a Zephyr toolchain image\n-#\n-# Usage:\n-#\n-# 1) Replace the TOOLCHAIN_NAME and TOOLCHAIN_PATH environment variables below with\n-# the name and URL of your self-extracting toolchain\n-#\n-# Example:\n-#\n-# ENV TOOLCHAIN_NAME zephyr-sdk-0.7.2-i686-setup.run\n-# ENV TOOLCHAIN_PATH https://nexus.zephyrproject.org/content/repositories/releases/org/zephyrproject/zephyr-sdk/0.7.2-i686/\n-#\n-# 2) Build your toolchain image with the following command replacing my_tag with your Zephyr's release\n-# docker build -t crops/zephyr:my_tag -f Dockerfile.zephyr ../\n-#\n-# Example for Zephyr SDK 0.7.2:\n-# docker build -t crops/zephyr:0.7.2-src -f Dockerfile.zephyr ../\n-#\n-\n-FROM crops/zephyr:deps\n-MAINTAINER Todor Minchev <todor.minchev@linux.intel.com>\n-\n-ENV TOOLCHAIN_NAME zephyr-sdk-0.7.2-i686-setup.run\n-ENV TOOLCHAIN_PATH https://nexus.zephyrproject.org/content/repositories/releases/org/zephyrproject/zephyr-sdk/0.7.2-i686/\n-\n-# Build and install turff\n-RUN mkdir -p /usr/local/crops/turff/\n-COPY turff /usr/local/crops/turff/\n-COPY utils.[ch] /usr/local/crops/\n-COPY globals.[ch] /usr/local/crops/\n-\n-RUN cd /usr/local/crops/turff && \\\n-\tmake && \\\n-\tmkdir -p /bin/turff && \\\n-\tcp /usr/local/crops/turff/turff /bin/turff/run && \\\n-\tcp /usr/local/crops/turff/turff_launcher /bin/\n-\n-# Download and install Zephyr toolchain\n-RUN wget -q -P /tmp ${TOOLCHAIN_PATH}${TOOLCHAIN_NAME} && \\\n-\tcd /tmp &&\t\\\n-\tchmod 755 ./${TOOLCHAIN_NAME} && \\\n-\t./${TOOLCHAIN_NAME} && \\\n-\trm -rf ./${TOOLCHAIN_NAME}\n-\n-#Linkups\n-# /bin/sh to bash\n-# easy to use gdb to various architectures\n-# NOTE: in future we will probably split these into separate toolchain containers\n-RUN rm /bin/sh && ln -s /bin/bash /bin/sh && \\\n-    ln -s /opt/zephyr-sdk/sysroots/i686-pokysdk-linux/usr/bin/i586-poky-elf/i586-poky-elf-gdb /usr/bin/zephyr-i586-gdb && \\\n-    ln -s /opt/zephyr-sdk/sysroots/i686-pokysdk-linux/usr/bin/arm-poky-eabi/arm-poky-eabi-gdb /usr/bin/zephyr-arm-gdb && \\\n-    ln -s /opt/zephyr-sdk/sysroots/i686-pokysdk-linux/usr/bin/arc-poky-elf/arc-poky-elf-gdb /usr/bin/zephyr-arc-gdb && \\\n-    ln -s /opt/zephyr-sdk/sysroots/i686-pokysdk-linux/usr/bin/mips-poky-elf/mips-poky-elf-gdb /usr/bin/zephyr-mips-gdb\n-\n-#Create Zephyr bare clone\n-RUN git clone --bare https://gerrit.zephyrproject.org/r/zephyr /zephyr-src\n-\n-# Container entry point\n-ENTRYPOINT [\"/bin/turff_launcher\"]\ndiff --git a/dockerfiles/Dockerfile.zephyr.deps b/dockerfiles/Dockerfile.zephyr.deps\ndeleted file mode 100644\nindex 4c5aa4f..0000000\n--- a/dockerfiles/Dockerfile.zephyr.deps\n+++ /dev/null\n@@ -1,24 +0,0 @@\n-# This file describes the standard way to build the dependencies for Zephyr\n-# toolchain images\n-#\n-# Usage:\n-#\n-# docker build -t crops/zephyr:deps -f Dockerfile.zephyr.deps .\n-\n-FROM debian:wheezy\n-MAINTAINER Todor Minchev <todor.minchev@linux.intel.com>\n-\n-# Install dependencies\n-RUN apt-get update && apt-get install -y \\\n-\tpython\t\\\n-\tdaemontools \\\n-\tgit \\\n-\tmake \\\n-\tgcc \\\n-\tgcc-multilib \\\n-\tg++ \\\n-\tlibc6-dev-i386 \\\n-\tg++-multilib\t\\\n-\tbzip2\t\\\n-\twget\n-\ndiff --git a/globals.c b/globals.c\ndeleted file mode 100755\nindex 2716495..0000000\n--- a/globals.c\n+++ /dev/null\n@@ -1,47 +0,0 @@\n-/*\n- * Copyright (C) 2016 Intel Corporation\n- *\n- * Author: Todor Minchev <todor.minchev@linux.intel.com>\n- *\n- * This program is free software; you can redistribute it and/or modify it\n- * under the terms and conditions of the GNU General Public License,\n- * version 2, or (at your option) any later version, as published by\n- * the Free Software Foundation.\n- *\n- * This program is distributed in the hope it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n- * more details.\n- */\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include \"globals.h\"\n-\n-void info(const char *file, int line, const char *func, const char* fmt, ...) {\n-  va_list args;\n-\n-  printf(\"[INFO] \");\n-  va_start(args, fmt);\n-  vprintf(fmt, args);\n-  va_end(args);\n-}\n-\n-void debug(const char *file, int line, const char *func, const char* fmt, ...) {\n-  va_list args;\n-\n-  printf(\"[DEBUG] %s:%d: [%s] \", file, line, func);\n-  va_start(args, fmt);\n-  vprintf(fmt, args);\n-  va_end(args);\n-}\n-\n-void error(const char *file, int line, const char *func, const char* fmt, ...) {\n-  va_list args;\n-\n-  printf(\"[ERROR] %s:%d: [%s] \", file, line, func);\n-  va_start(args, fmt);\n-  vprintf(fmt, args);\n-  va_end(args);\n-  exit(EXIT_FAILURE);\n-}\ndiff --git a/globals.h b/globals.h\ndeleted file mode 100755\nindex c928166..0000000\n--- a/globals.h\n+++ /dev/null\n@@ -1,69 +0,0 @@\n-/*\n- * Copyright (C) 2016 Intel Corporation\n- *\n- * Author: Todor Minchev <todor.minchev@linux.intel.com>\n- *\n- * This program is free software; you can redistribute it and/or modify it\n- * under the terms and conditions of the GNU General Public License,\n- * version 2, or (at your option) any later version, as published by\n- * the Free Software Foundation.\n- *\n- * This program is distributed in the hope it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n- * more details.\n- */\n-\n-#ifndef GLOBALS_H\n-#define GLOBALS_H\n-#ifdef __linux\n-#define _GNU_SOURCE\n-#endif\n-\n-\n-#include <math.h>\n-#include <stdarg.h>\n-#include <stdint.h>\n-#include <stdio.h>\n-#include <string.h>\n-#include <unistd.h>\n-\n-#define KEY_ARR_SZ 'z' -'a' + 1\n-#define KEY(var) abs('a'- #var[1])\n-\n-\n-#define CODI_PORT      \"10000\"\n-#define CODI_IP_NATIVE \"127.0.0.1\"\n-#define CODI_IP_VIRT   \"192.168.99.100\"\n-#define TURFF_PORT     \"9999\"\n-#define MSG_TERM       \"EOM\"\n-#define VERSION        \"0.1\"\n-#define TURFF_EOM      \"TEOM\"\n-#define CEED_NAME      \"ceed\"\n-#define TURFF_NAME     \"turff\"\n-#define CODI_NAME      \"codi\"\n-#define TURFFID        \"TURFFID\"\n-\n-void info(const char *file, int line, const char *func, const char* fmt, ...);\n-void debug(const char *file, int line, const char *func, const char* fmt, ...);\n-void error(const char *file, int line, const char *func, const char* fmt, ...);\n-\n-#define INFO(...)  info(__FILE__, __LINE__, __func__, __VA_ARGS__)\n-#define ERR(...) error(__FILE__, __LINE__, __func__, __VA_ARGS__)\n-#define DEBUG(...) debug(__FILE__, __LINE__, __func__, __VA_ARGS__)\n-\n-typedef enum { false, true } bool;\n-\n-/* parameter chunk*/\n-typedef struct chunk{\n-  uint32_t op_code;\n-  char arg[20];\n-  struct chunk *next;\n-} msg_chunk;\n-\n-typedef struct{\n-  char  *mem;\n-  size_t size;\n-} curl_mem_chunk_t;\n-\n-#endif\ndiff --git a/helpers/runbitbake.py b/helpers/runbitbake.py\ndeleted file mode 100644\nindex 96c55dc..0000000\n--- a/helpers/runbitbake.py\n+++ /dev/null\n@@ -1,148 +0,0 @@\n-#!/usr/bin/python\n-\n-# runbitbake.py\n-#\n-# Copyright (C) 2016 Intel Corporation\n-#\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License version 2 as\n-# published by the Free Software Foundation.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License along\n-# with this program; if not, write to the Free Software Foundation, Inc.,\n-# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-import argparse\n-import subprocess\n-import os\n-import tempfile\n-import shutil\n-import sys\n-import signal\n-\n-bitbake_process = None\n-\n-old_handler = {}\n-old_handler[str(signal.SIGINT)] = signal.getsignal(signal.SIGINT)\n-old_handler[str(signal.SIGTERM)] = signal.getsignal(signal.SIGTERM)\n-\n-\n-def addextra(tempdir, builddir, name, extralist):\n-    myf = \"{}/conf/{}\".format(builddir, name)\n-    myf_orig = \"{}/{}.orig\".format(tempdir, name)\n-    tmpfile = \"{}/{}.orig.tmp\".format(tempdir, name)\n-\n-    # copy isn't atomic so make sure that orig is created atomically so that\n-    # file.orig is always correct even if file gets hosed. So that\n-    # means if a user ever sees file.orig, they can be assured that it\n-    # is the same as the original file with no corruption.\n-    shutil.copyfile(myf, tmpfile)\n-    with open(tmpfile, \"r\") as f:\n-        fd = f.fileno()\n-        os.fdatasync(fd)\n-\n-    # Remember first sync the file AND directory to make sure data\n-    # is written out\n-    fd = os.open(os.path.dirname(tmpfile), os.O_RDONLY)\n-    os.fsync(fd)\n-    os.close(fd)\n-\n-    # Rename should be atomic with respect to disk, yes all of this assumes\n-    # linux and possibly non-network filesystems.\n-    os.rename(tmpfile, myf_orig)\n-\n-    with open(myf, \"a\") as f:\n-        if extralist:\n-            for conf in extralist:\n-                with open(conf) as f2:\n-                    content = f2.readlines()\n-                for l in content:\n-                    f.write(\"%s\\n\" % format(l.strip()))\n-\n-\n-def restore_files(tempdir, builddir, conffiles):\n-    for f in conffiles:\n-        dest = os.path.join(builddir, \"conf\", f)\n-        src = os.path.join(tempdir, f + \".orig\")\n-\n-        if os.path.exists(src):\n-            os.rename(src, dest)\n-\n-\n-# If bitbake is around let it do all the signal handling\n-def handler(signum, frame):\n-    if bitbake_process:\n-        # SIGINT is special if there is a tty. Because with a tty SIGINT will\n-        # automatically get sent to all processes in the process group. So we\n-        # don't need to send it ourselves.\n-        if signum == signal.SIGINT and sys.stdin.isatty():\n-            pass\n-        else:\n-            # If there is a bitbake process we want to let it tear down all\n-            # its children itself so send the signal to bitbake.\n-            bitbake_process.send_signal(signum)\n-    else:\n-        old_handler[str(signum)](signum, frame)\n-\n-\n-if __name__ == '__main__':\n-    signal.signal(signal.SIGINT, handler)\n-    signal.signal(signal.SIGTERM, handler)\n-\n-    parser = argparse.ArgumentParser()\n-\n-    parser.add_argument(\"--extraconf\", action='append', help=\"File containing\"\n-                        \"extra configuration\")\n-    parser.add_argument(\"--extralayers\", action='append',\n-                        help=\"File containing extra bblayers\")\n-\n-    parser.add_argument(\"--pokydir\", default=\"/home/yoctouser/poky\",\n-                        required=True, help=\"Directory containing poky\")\n-    parser.add_argument(\"--target\", \"-t\", required=True,\n-                        help=\"What bitbake should build\")\n-    parser.add_argument(\"--builddir\", \"-b\", required=True,\n-                        help=\"Directory to build in\")\n-\n-    args = parser.parse_args()\n-\n-    builddir = args.builddir\n-\n-    if not os.path.isdir(builddir):\n-        os.makedirs(builddir)\n-\n-    # tempdir is a subdirectory of builddir in case builddir and local.conf\n-    # already existed. Then if something goes wrong with local.conf the user\n-    # can restore it by using builddir/tempdir/local.conf.orig\n-    tempdir = tempfile.mkdtemp(prefix=\"runbitbake-tmpdir\", dir=builddir)\n-\n-    # Have to use bash since the default on ubuntu is dash which is garbage\n-    try:\n-        cmd = 'bash -c \". {}/oe-init-build-env {}\"'.format(args.pokydir,\n-                                                           builddir)\n-        subprocess.check_call(cmd, stdout=sys.stdout, stderr=sys.stderr,\n-                              shell=True)\n-\n-        try:\n-            addextra(tempdir, builddir, \"local.conf\", args.extraconf)\n-            addextra(tempdir, builddir, \"bblayers.conf\", args.extralayers)\n-\n-            cmd = '. {}/oe-init-build-env {} && '.format(args.pokydir,\n-                                                         builddir)\n-            cmd += 'exec bitbake {}'.format(args.target)\n-            bitbake_process = subprocess.Popen(['/bin/bash', '-c', cmd],\n-                                               stdout=sys.stdout,\n-                                               stderr=sys.stderr, shell=False)\n-            bitbake_process.wait()\n-        finally:\n-            restore_files(tempdir, builddir, [\"local.conf\", \"bblayers.conf\"])\n-\n-    except subprocess.CalledProcessError as e:\n-        print e\n-\n-    finally:\n-        shutil.rmtree(tempdir, ignore_errors=True)\ndiff --git a/helpers/startOstroScript.sh b/helpers/startOstroScript.sh\ndeleted file mode 100644\nindex 49a1dd1..0000000\n--- a/helpers/startOstroScript.sh\n+++ /dev/null\n@@ -1,42 +0,0 @@\n-#!/bin/bash\n-POKY_DIR=/ostro/ostro-os/\n-EXTRA_CONF=/ostro/ostro-shared/conf/ostro.conf\n-BUILD_DIR=/ostro/build/\n-EXTRA_LAYERS=/ostro/ostro-shared/conf/ostro.layers\n-\n-H_UID=$(ls -al /ostro/ostro-shared/ | egrep \"\\.\"|egrep -v \"\\.\\.\" | awk '{print $3}')\n-H_USER=$(getent passwd \"$H_UID\" | cut -d: -f1)\n-if [ \"$H_USER\" == \"\" ]; then\n-    H_USER=\"yoctobuilder\"\n-    /usr/sbin/useradd -m -u ${H_UID} ${H_USER}\n-fi\n-\n-# provide the ostro.conf if there isn't one yet\n-if [ ! -f ${EXTRA_CONF} ]; then\n-    mkdir -p /ostro/ostro-shared/conf\n-    cp /ostro/sample-conf/ostro.conf ${EXTRA_CONF}\n-fi\n-\n-# provide ostro.layers if there isn't one yet\n-if [ ! -f ${EXTRA_LAYERS} ]; then\n-    mkdir -p /ostro/ostro-shared/conf\n-    cp /ostro/sample-conf/ostro.layers ${EXTRA_LAYERS}\n-fi\n-\n-mkdir -p /ostro/ostro-shared/images/\n-chmod a+rwx /ostro/ostro-shared/images/\n-chmod a+rwx /ostro/ostro-shared/conf\n-chmod a+rw  ${EXTRA_CONF}\n-\n-\n-# switch into user to build\n-sudo  --user ${H_USER} /ostro/bin/runbitbake.py --pokydir $POKY_DIR --extraconf $EXTRA_CONF --extralayers $EXTRA_LAYERS -b $BUILD_DIR -t $*\n-echo \"copying images to shared folder\"\n-\n-# we need to source the bitbake env in order to use the bitbake script to find the images\n-cd ${BUILD_DIR}\n-source ${POKY_DIR}/oe-init-build-env >> /dev/null\n-CON_DIR=`bitbake -e | egrep \"DEPLOY_DIR_IMAGE\\=\"|tr \"\\=\" \" \" | tr -d \"\\\"\"| awk '{print $2}'`\n-rsync -a ${CON_DIR} /ostro/ostro-shared/images/ > /dev/null 2>&1\n-\n-\ndiff --git a/installers/ostro-installer.sh b/installers/ostro-installer.sh\ndeleted file mode 100644\nindex 05eca6a..0000000\n--- a/installers/ostro-installer.sh\n+++ /dev/null\n@@ -1,108 +0,0 @@\n-#!/bin/bash\n-\n-if [[ \"$(basename -- \"$0\")\" == \"ostro-installer.sh\" ]]; then\n-  echo -e \"$0 has to be sourced not run\" >&2;\n-  echo -e \"\\nExample:\\nsource $0\\n\"; exit 1\n-fi\n-\n-OSTRO_IMG=crops/ostro:builder\n-OSTRO_CONTAINER=ostro-builder\n-OSTRO_CONF=$HOME/ostro-workspace/shared/conf/ostro.conf\n-BITBAKE_WRAPPER=$HOME/.crops/bitbake.ostro\n-WIN_PLATFORM=\"msys\"\n-LINUX_PLATFORM=\"linux\"\n-MAC_PLATFORM=\"darwin\"\n-unset MY_PLATFORM\n-\n-# establish platform\n-if [[ \"echo \"${OSTYPE}\" | tr '[:upper:]' '[:lower:]'\" = *$LINUX_PLATFORM* ]]; then\n-  MY_PLATFORM=$LINUX_PLATFORM\n-elif [[ \"echo \"${OSTYPE}\" | tr '[:upper:]' '[:lower:]'\" == *$MAC_PLATFORM* ]]; then\n-  MY_PLATFORM=$MAC_PLATFORM\n-elif [[ \"echo \"${OSTYPE}\" | tr '[:upper:]' '[:lower:]'\" == *$WIN_PLATFORM* ]]; then\n-  MY_PLATFORM=$WIN_PLATFORM\n-else\n-  echo \"Unknown platform: $OSTYPE. Exiting\"; return 1\n-fi\n-echo -e \"\\nPlatform is $MY_PLATFORM\"\n-\n-if [ \"`which docker`\" = \"\" ]; then\n-  echo -e \"\\nPlease install docker first, then run this installer\"\n-  if [[ $MY_PLATFORM = $LINUX_PLATFORM ]]; then\n-    echo -e \"\\nFrom: https://docs.docker.com/linux/step_one/\"\n-  else\n-    echo -e \"\\nFrom: https://www.docker.com/products/docker-toolbox\"\n-  fi\n-  return 1\n-fi\n-\n-echo -e \"\\n\"\n-read -p \"This will remove existing OSTRO build containers. Answering No will exit the installer. Proceed? Y/N \" -r\n-echo\n-if [[ ! $REPLY =~ ^[Yy]$ ]]\n-then\n-  echo \"There is nothing for me to do. Exiting\"; return 1\n-else\n-  echo -e \"\\nRemove existing OSTRO build containers\"\n-  docker ps -a | awk '{ print $1,$2 }' | grep $OSTRO_IMG | awk '{print $1 }' | xargs -I {} docker rm -f {}\n-  echo -e \"Done\"\n-fi\n-\n-if [[ \"$(docker images -q $OSTRO_IMG 2> /dev/null)\" != \"\" ]]; then\n-  read -p \"OSTRO build image found. Download latest OSTRO build image? Y/N \" -r; echo\n-  if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n-    if [[ \"$(docker images -q $OSTRO_IMG 2> /dev/null)\" == \"\" ]]; then\n-      echo \"OSTRO build image not found. Exiting installer\"; return 1\n-    fi\n-  else\n-    echo -e \"\\nRemove existing OSTRO build image\"\n-    docker rmi $OSTRO_IMG 2> /dev/null\n-    echo -e \"Done\"\n-\n-    echo -e \"\\nDownloading OSTRO build image. Please wait\"\n-    docker pull $OSTRO_IMG\n-    echo -e \"Done\"\n-  fi\n-else\n-  read -p \"Download OSTRO build image? Y/N \" -r\n-  echo\n-  if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n-    if [[ \"$(docker images -q $OSTRO_IMG 2> /dev/null)\" == \"\" ]]; then\n-      echo \"OSTRO build image not found. Exiting installer\"; return 1\n-    fi\n-  else\n-    echo -e \"\\nDownloading OSTRO build image. Please wait\"\n-    docker pull $OSTRO_IMG\n-    echo -e \"Done\"\n-  fi\n-fi\n-\n-if [[ \"$(docker images -q $OSTRO_IMG 2> /dev/null)\" == \"\" ]]; then\n-  echo \"OSTRO build image not found. Exiting installer\"; return 1\n-fi\n-\n-mkdir -p $HOME/.crops\n-\n-if [[ -f \"$BITBAKE_WRAPPER\" ]]; then\n-  read -p \"OSTRO bitbake wrapper found. Do you want to reinstall bitbake wrapper? Y/N \" -r; echo\n-  if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n-    echo -e \"\\nOSTRO bitbake wrapper was not updated\"\n-  else\n-    rm -rf $BITBAKE_WRAPPER\n-\t  echo -e \"Downloading default OSTRO bitbake wrapper\"\n-    curl -k -s -o $BITBAKE_WRAPPER https://raw.githubusercontent.com/crops/crops/master/scripts/bitbake.ostro\n-    chmod 755 $BITBAKE_WRAPPER\n-    echo -e \"Done.\"\n-  fi\n-else\n-  echo -e \"Downloading OSTRO bitbake wrapper\"\n-  curl -k -s -o $BITBAKE_WRAPPER https://raw.githubusercontent.com/crops/crops/master/scripts/bitbake.ostro\n-  chmod 755 $BITBAKE_WRAPPER\n-  echo -e \"Done.\"\n-fi\n-export PATH=$PATH:$HOME/.crops\n-\n-echo -e \"\\n\\nTHE OSTRO BUILD ENVIRONMENT HAS BEEN SET UP\"\n-\n-echo -e \"\\nYou can now build ostro-os from the CLI\\n\"\n-echo -e \"Example :\\nbitbake.ostro ostro-image-noswupd\\n\"\ndiff --git a/installers/zephyr-installer.sh b/installers/zephyr-installer.sh\ndeleted file mode 100755\nindex 2afb4cf..0000000\n--- a/installers/zephyr-installer.sh\n+++ /dev/null\n@@ -1,225 +0,0 @@\n-#!/bin/bash\n-\n-if [[ \"$(basename -- \"$0\")\" == \"zephyr-installer.sh\" ]]; then\n-  echo -e \"$0 has to be sourced not run\" >&2;\n-  echo -e \"\\nExample:\\nsource $0\\n\"; exit 1\n-fi\n-\n-CODI_IMG=crops/codi:latest\n-CODI_CONTAINER=codi\n-ZEPHYR_IMG=crops/zephyr:latest\n-ZEPHYR_CONTAINER=crops-zephyr-0-7-2-src\n-VM_NAME=default\n-CEED_EXE=$HOME/.crops/ceed/ceed\n-MAKE_PATH=$HOME/.crops\n-WIN_PLATFORM=\"msys\"\n-LINUX_PLATFORM=\"linux\"\n-MAC_PLATFORM=\"darwin\"\n-unset MY_PLATFORM\n-\n-# establish platform\n-if [[ \"echo \"${OSTYPE}\" | tr '[:upper:]' '[:lower:]'\" = *$LINUX_PLATFORM* ]]; then\n-  MY_PLATFORM=$LINUX_PLATFORM\n-elif [[ \"echo \"${OSTYPE}\" | tr '[:upper:]' '[:lower:]'\" == *$MAC_PLATFORM* ]]; then\n-  MY_PLATFORM=$MAC_PLATFORM\n-elif [[ \"echo \"${OSTYPE}\" | tr '[:upper:]' '[:lower:]'\" == *$WIN_PLATFORM* ]]; then\n-  MY_PLATFORM=$WIN_PLATFORM\n-else\n-  echo \"Unknown platform: $OSTYPE. Exiting\"; return 1\n-fi\n-echo -e \"\\nPlatform is $MY_PLATFORM\"\n-\n-if [ \"`which docker`\" = \"\" ]; then\n-  echo -e \"\\nPlease install docker first, then run this installer\"\n-  if [[ $MY_PLATFORM = $LINUX_PLATFORM ]]; then\n-    echo -e \"\\nFrom: https://docs.docker.com/linux/step_one/\"\n-  else\n-    echo -e \"\\nFrom: https://www.docker.com/products/docker-toolbox\"\n-  fi\n-  return 1\n-fi\n-\n-echo -e \"\\n\"\n-read -p \"This will remove existing CROPS containers. Answering No will exit the installer. Proceed? Y/N \" -r\n-echo\n-if [[ ! $REPLY =~ ^[Yy]$ ]]\n-then\n-  echo \"There is nothing for me to do. Exiting\"; return 1\n-else\n-  echo -e \"\\nRemove existing CODI containers\"\n-  docker ps -a | awk '{ print $1,$2 }' | grep $CODI_IMG | awk '{print $1 }' | xargs -I {} docker rm -f {}\n-  echo -e \"Done\"\n-\n-  echo -e \"\\nRemove existing Zephyr container\"\n-  docker ps -a | awk '{ print $1,$2 }' | grep $ZEPHYR_IMG | awk '{print $1 }' | xargs -I {} docker rm -f {}\n-  echo -e \"Done\"\n-fi\n-\n-if [[ \"$(docker images -q $CODI_IMG 2> /dev/null)\" != \"\" ]]; then\n-  read -p \"CODI image found. Download latest CODI image? Y/N \" -r; echo\n-  if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n-    if [[ \"$(docker images -q $CODI_IMG 2> /dev/null)\" == \"\" ]]; then\n-      echo \"CODI image not found. Exiting installer\"; return 1\n-    fi\n-  else\n-    echo -e \"\\nRemove existing CODI image\"\n-    docker rmi $CODI_IMG 2> /dev/null\n-    echo -e \"Done\"\n-\n-    echo -e \"\\nDownloading CODI image. Please wait\"\n-    docker pull $CODI_IMG\n-    echo -e \"Done\"\n-  fi\n-else\n-  read -p \"Download CODI image? Y/N \" -r\n-  echo\n-  if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n-    if [[ \"$(docker images -q $CODI_IMG 2> /dev/null)\" == \"\" ]]; then\n-      echo \"CODI image not found. Exiting installer\"; return 1\n-    fi\n-  else\n-    echo -e \"\\nDownloading CODI image. Please wait\"\n-    docker pull $CODI_IMG\n-    echo -e \"Done\"\n-  fi\n-fi\n-\n-if [[ \"$(docker images -q $ZEPHYR_IMG 2> /dev/null)\" != \"\" ]]; then\n-  read -p \"Zephyr toolchain found. Download latest Zephyr toolchain? Y/N \" -r; echo\n-  if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n-    if [[ \"$(docker images -q $ZEPHYR_IMG 2> /dev/null)\" == \"\" ]]; then\n-      echo \"Zephyr toolchain not found. Exiting installer\"; return 1\n-    fi\n-  else\n-    echo -e \"\\nRemove existing Zephyr toolchain\"\n-    docker rmi $ZEPHYR_IMG 2> /dev/null\n-    echo -e \"Done\"\n-\n-    echo -e \"\\nDownloading Zephyr toolchain. Please wait\"\n-    docker pull $ZEPHYR_IMG\n-    echo -e \"Done\"\n-  fi\n-else\n-  read -p \"Download Zephyr toolchain? Y/N \" -r; echo\n-  if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n-    if [[ \"$(docker images -q $ZEPHYR_IMG 2> /dev/null)\" == \"\" ]]; then\n-      echo \"Zephyr toolchain not found. Exiting installer\"; return 1\n-    fi\n-  else\n-    echo -e \"\\nDownloading Zephyr toolchain. Please wait\"\n-    docker pull $ZEPHYR_IMG\n-    echo -e \"Done\"\n-  fi\n-fi\n-\n-echo -e \"\\nLaunching CODI container\"\n-docker run -d --name $CODI_CONTAINER -v //var//run//docker.sock://var//run//docker.sock \\\n-  --net=host $CODI_IMG || { echo 'Couldn't start $CODI_CONTAINER\\' ; return 1; }\n-echo -e \"Done\"\n-\n-echo -e \"\\nLaunching Zephyr toolchain\"\n-docker run -d --name $ZEPHYR_CONTAINER  -e TURFFID=$ZEPHYR_CONTAINER -v $HOME/crops-workspace:/crops \\\n-  --net=host $ZEPHYR_IMG || { echo 'Couldn't start $ZEPHYR_CONTAINER\\' ; return 1; }\n-echo -e \"Done\"\n-\n-mkdir -p $HOME/crops-workspace;\n-\n-if [[ $MY_PLATFORM == $MAC_PLATFORM ]]; then\n-  if [[ ! -f \"$CEED_EXE\" ]]; then\n-    echo -e \"Downloading CEED executable for Mac...\"\n-    mkdir -p $HOME/.crops/ceed/\n-    curl -s -o $CEED_EXE http://crops.minchev.co.uk/ceed/mac/ceed\n-    chmod 755 $CEED_EXE\n-    echo -e \"Done.\"\n-  fi\n-\n-  if [[ ! -f \"$MAKE_PATH/make.zephyr\" ]]; then\n-    echo -e \"Downloading Zephyr CLI make utility...\"\n-    curl -s -o $MAKE_PATH/make.zephyr https://raw.githubusercontent.com/todorez/crops/master/scripts/make.zephyr\n-    chmod 755 $MAKE_PATH/make.zephyr\n-    echo -e \"Done.\"\n-  fi\n-else\n-  if [[ -f \"$CEED_EXE\" ]]; then\n-    read -p \"CEED found. Do you want to reinstall CEED? Y/N \" -r; echo\n-    if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n-      echo -e \"\\nCEED executable was not updated\"\n-    else\n-      echo -e \"\\nRemove existing CEED executable\"\n-      rm -rf $CEED_EXE\n-      echo -e \"Done\"\n-\n-      git clone https://github.com/todorez/crops.git; cd crops/dockerfiles;\n-      if [[ $MY_PLATFORM == $WIN_PLATFORM ]]; then\n-        echo -e \"\\nBuilding CEED executable\"\n-        docker ps -a -q --filter \"name=ceed-windows\" | awk '{print $1}' | xargs -I {} docker rm -f {}\n-        docker images -q --filter \"label=name=ceed-windows\" | awk '{print $1}' | xargs -I {} docker rmi {}\n-        docker build -t crops/ceed:windows -f Dockerfile.ceed.win ../\n-        docker run --name=ceed-windows crops/ceed:windows;\n-        docker-machine ssh default \"docker cp ceed-windows:/usr/local/crops/ceed/ceed $CEED_EXE\";\n-        docker ps -a -q --filter \"name=ceed-windows\" | awk '{print $1}' | xargs -I {} docker rm -f {}\n-        docker images -q --filter \"label=name=ceed-windows\" | awk '{print $1}' | xargs -I {} docker rmi {}\n-        echo -e \"Done\"\n-      else\n-        echo -e \"\\nBuilding CEED executable\"\n-        docker ps -a -q --filter \"name=ceed-linux\" | awk '{print $1}' | xargs -I {} docker rm -f {}\n-        docker images -q --filter \"label=name=ceed-linux\" | awk '{print $1}' | xargs -I {} docker rmi {}\n-        docker build -t crops/ceed:linux -f Dockerfile.ceed.linux ../\n-        docker run --name=ceed-linux crops/ceed:linux;\n-        docker cp ceed-linux:/usr/local/crops/ceed/ceed $CEED_EXE;\n-        docker ps -a -q --filter \"name=ceed-linux\" | awk '{print $1}' | xargs -I {} docker rm -f {}\n-        docker images -q --filter \"label=name=ceed-linux\" | awk '{print $1}' | xargs -I {} docker rmi {}\n-      fi\n-      cd ../../; cp -fp ./crops/scripts/make.zephyr $MAKE_PATH/\n-      cp -fp ./crops/scripts/gdb.zephyr $MAKE_PATH/; rm -rf ./crops\n-    fi\n-  else\n-    read -p \"Do you want to install CEED? Y/N \" -r; echo\n-    if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n-      echo -e \"\\nExiting installer. Your install is incomplete.\"; return 1\n-    else\n-      mkdir -p $HOME/.crops/ceed\n-      git clone https://github.com/todorez/crops.git; cd crops/dockerfiles;\n-      if [[ $MY_PLATFORM == $WIN_PLATFORM ]]; then\n-        echo -e \"\\nBuilding CEED executable\"\n-        docker ps -a -q --filter \"name=ceed-windows\" | awk '{print $1}' | xargs -I {} docker rm -f {}\n-        docker images -q --filter \"label=name=ceed-windows\" | awk '{print $1}' | xargs -I {} docker rmi {}\n-        docker build -t crops/ceed:windows -f Dockerfile.ceed.win ../\n-        docker run --name=ceed-windows crops/ceed:windows;\n-        docker-machine ssh default \"docker cp ceed-windows:/usr/local/crops/ceed/ceed $CEED_EXE\";\n-        docker ps -a -q --filter \"name=ceed-windows\" | awk '{print $1}' | xargs -I {} docker rm -f {}\n-        docker images -q --filter \"label=name=ceed-windows\" | awk '{print $1}' | xargs -I {} docker rmi {}\n-        echo -e \"Done\"\n-      else\n-        echo -e \"\\nBuilding CEED executable\"\n-        docker ps -a -q --filter \"name=ceed-linux\" | awk '{print $1}' | xargs -I {} docker rm -f {}\n-        docker images -q --filter \"label=name=ceed-linux\" | awk '{print $1}' | xargs -I {} docker rmi {}\n-        docker build -t crops/ceed:linux -f Dockerfile.ceed.linux ../\n-        docker run --name=ceed-linux crops/ceed:linux;\n-        docker cp ceed-linux:/usr/local/crops/ceed/ceed $CEED_EXE;\n-        docker ps -a -q --filter \"name=ceed-linux\" | awk '{print $1}' | xargs -I {} docker rm -f {}\n-        docker images -q --filter \"label=name=ceed-linux\" | awk '{print $1}' | xargs -I {} docker rmi {}\n-        echo -e \"Done\"\n-      fi\n-      cd ../../; cp -fp ./crops/scripts/make.zephyr $MAKE_PATH/;\n-      cp -fp ./crops/scripts/gdb.zephyr $MAKE_PATH/; rm -rf ./crops\n-    fi\n-  fi\n-fi\n-\n-echo -e \"\\n\\nTHE CROPS ENVIRONMENT HAS BEEN SET UP\"\n-\n-if [[ $MY_PLATFORM != $LINUX_PLATFORM ]]; then\n-  MACHINE=`docker-machine active`\n-  IP=`docker-machine ip $MACHINE`\n-  CEED_EXE=\"$CEED_EXE -i $IP\"\n-fi\n-\n-echo -e \"\\nInitialize Zephyr environment for CLI use\"\n-echo -e \"Example :\\n${CEED_EXE} -d ${ZEPHYR_CONTAINER} -g \\\"git clone --branch v1.0.0 /zephyr-src /crops/zephyr-project/\\\"\"\n-\n-echo -e \"\\nYou can now build Zephyr applications from the CLI\"\n-echo -e \"Example :\\n$MAKE_PATH/make.zephyr BOARD=arduino_101 -C /crops/zephyr-project/samples/nanokernel/apps/hello_world/\"\n-\n-export CEED_EXE=$CEED_EXE\n-export ZEPHYR_CONTAINER=$ZEPHYR_CONTAINER\ndiff --git a/scripts/bitbake.ostro b/scripts/bitbake.ostro\ndeleted file mode 100755\nindex a7fba2a..0000000\n--- a/scripts/bitbake.ostro\n+++ /dev/null\n@@ -1,12 +0,0 @@\n-#!/usr/bin/env bash\n-\n-OSTRO_CONTAINER=ostro-builder\n-OSTRO_IMG=crops/ostro:builder\n-\n-DOCKER_CMD=\"docker run --rm --name $OSTRO_CONTAINER -v `pwd`/ostro-shared:/ostro/ostro-shared --net=host $OSTRO_IMG\"\n-PARAMS=$1\n-\n-# make sure the shared directory exists\n-mkdir -p `pwd`/ostro-shared\n-${DOCKER_CMD} ${PARAMS} || { echo -e \"\\nCouldn't start $OSTRO_CONTAINER container\\n\" ; exit 1; }\n-\ndiff --git a/scripts/build_ceed b/scripts/build_ceed\ndeleted file mode 100755\nindex a181b2d..0000000\n--- a/scripts/build_ceed\n+++ /dev/null\n@@ -1,11 +0,0 @@\n-#!/usr/bin/env bash\n-set -e\n-set -o pipefail\n-\n-# This is a convenience script to build the host side ceed for travis testing.\n-# this is probably a more travisy way to do this so if you know it, speak up!\n-\n-TOPDIR=`git rev-parse --show-toplevel`\n-\n-cd ${TOPDIR}/ceed\n-make\ndiff --git a/scripts/build_containers b/scripts/build_containers\ndeleted file mode 100755\nindex 4335d8b..0000000\n--- a/scripts/build_containers\n+++ /dev/null\n@@ -1,73 +0,0 @@\n-#!/usr/bin/env bash\n-set -e\n-set -o pipefail\n-\n-# This is a sanity test script for the CODI and toolchain Docker images.\n-# This removes the old test containers, and builds a new codi and new toolchains.\n-# If you do not have the deps containers, it will build them but this takes awhile\n-#\n-# Example:\n-#\n-# ./tests/build_containers\n-\n-TOPDIR=`git rev-parse --show-toplevel`\n-\n-# remove codi test image as we will rebuild it\n-Q=`docker images  -q crops/codi:test`\n-if [ \"$Q\"  != \"\" ]; then\n-    echo \"Removing codi image\"\n-    docker rmi -f $Q\n-fi\n-\n-Q=`docker images  -q crops/codi:testdebug`\n-if [ \"$Q\"  != \"\" ]; then\n-    echo \"Removing codi debug image\"\n-    docker rmi -f $Q\n-fi\n-\n-# remove toolchain test image as we will rebuild it\n-Q=`docker images  -q crops/toolchain:test`\n-if [ \"$Q\"  != \"\" ]; then\n-    echo \"Removing toolchain image\"\n-    docker rmi -f   $Q\n-fi\n-\n-# remove Zephyr toolchain image as we will rebuild it\n-Q=`docker images  -q crops/zephyr:test`\n-if [ \"$Q\"  != \"\" ]; then\n-    echo \"Removing Zephyr toolchain image\"\n-    docker rmi -f   $Q\n-fi\n-\n-cd ${TOPDIR}/dockerfiles;\n-\n-Q=`docker images  -q crops/codi:deps`\n-if [ \"$Q\"  == \"\" ]; then\n-    echo \"Build CODI deps image\"\n-    docker build -t crops/codi:deps -f Dockerfile.codi.deps --rm=true ..\n-fi\n-\n-\n-echo \"Build CODI test image\"\n-docker build -t crops/codi:test -f Dockerfile.codi --rm=true ..\n-\n-echo \"Build CODI debug test image\"\n-docker build -t crops/codi:testdebug --build-arg build_type=debug -f Dockerfile.codi --rm=true ..\n-\n-Q=`docker images  -q crops/toolchain:deps`\n-if [ \"$Q\"  == \"\" ]; then\n-    echo \"Build toolchain deps image\"\n-    docker build -t crops/toolchain:deps -f Dockerfile.toolchain.deps  --rm=true ..\n-fi\n-\n-echo \"Build toolchain test image\"\n-docker build -t crops/toolchain:test -f Dockerfile.toolchain --rm=true ..\n-\n-Q=`docker images  -q crops/zephyr:deps`\n-if [ \"$Q\"  == \"\" ]; then\n-    echo \"Build Zephyr deps image\"\n-    docker build -t crops/zephyr:deps -f Dockerfile.zephyr.deps  --rm=true ..\n-fi\n-\n-echo \"Build Zephyr toolchain image\"\n-docker build -t crops/zephyr:test -f Dockerfile.zephyr --rm=true ..\ndiff --git a/scripts/build_containers.ostro b/scripts/build_containers.ostro\ndeleted file mode 100755\nindex 15019bc..0000000\n--- a/scripts/build_containers.ostro\n+++ /dev/null\n@@ -1,35 +0,0 @@\n-#!/usr/bin/env bash\n-set -e\n-set -o pipefail\n-\n-\n-# This removes the old test containers, and builds a new ostro container.\n-# If you do not have the deps containers, it will build them but this takes awhile\n-# it does NOT remove the deps images\n-#\n-# Example:\n-#\n-# ./scripts/build_containers.ostro\n-\n-TOPDIR=`git rev-parse --show-toplevel`\n-\n-# remove ostro builder image as we will rebuild it\n-Q=`docker images  -q crops/ostro:builder`\n-if [ \"$Q\"  != \"\" ]; then\n-    echo \"Removing ostro image\"\n-    docker rmi -f $Q\n-fi\n-\n-cd ${TOPDIR}/dockerfiles;\n-\n-Q=`docker images  -q crops/ostro:deps`\n-if [ \"$Q\"  == \"\" ]; then\n-    echo \"Build ostro deps image\"\n-    docker build -t crops/ostro:deps -f Dockerfile.ostro.deps --rm=true ..\n-fi\n-Q=`docker images  -q crops/ostro:builder`\n-if [ \"$Q\"  == \"\" ]; then\n-    echo \"Build ostro builder image\"\n-    docker build -t crops/ostro:builder -f Dockerfile.ostro --rm=true ..\n-fi\n-\ndiff --git a/scripts/gdb.zephyr b/scripts/gdb.zephyr\ndeleted file mode 100644\nindex dfb128e..0000000\n--- a/scripts/gdb.zephyr\n+++ /dev/null\n@@ -1,8 +0,0 @@\n-#!/usr/bin/env bash\n-\n-DOCKER_EXEC_TTY=\"docker exec -it\"\n-CONTAINER=crops-zephyr-0-7-2-src\n-GDB_PATH=//opt//zephyr-sdk//sysroots//i686-pokysdk-linux//usr//bin//i586-poky-elf//i586-poky-elf-gdb\n-IMAGE=$1\n-\n- ${DOCKER_EXEC_TTY} ${CONTAINER} ${GDB_PATH} ${IMAGE}\ndiff --git a/scripts/make.zephyr b/scripts/make.zephyr\ndeleted file mode 100755\nindex 55f0cef..0000000\n--- a/scripts/make.zephyr\n+++ /dev/null\n@@ -1,21 +0,0 @@\n-#!/usr/bin/env bash\n-\n-echo $CEED_EXE\n-\n-if [ -z \"$CEED_EXE\" ]; then\n-  CEED_EXE=./ceed/ceed\n-fi\n-\n-if [ -z \"$ZEPHYR_CONTAINER\" ]; then\n-  ZEPHYR_CONTAINER=zephyr-test\n-fi\n-\n-ZEPHYR_ENV=\"ZEPHYR_GCC_VARIANT=zephyr ZEPHYR_SDK_INSTALL_DIR=/opt/zephyr-sdk ZEPHYR_BASE=/crops/zephyr-project/\"\n-ALL_PARAMS=$*\n-\n-if [ \"$#\" -eq 0 ]; then\n-    echo $0: No parameters found\n-    exit 1\n-fi\n-\n-${CEED_EXE} -d ${ZEPHYR_CONTAINER} -g \"${ZEPHYR_ENV} make ${ALL_PARAMS}\"\ndiff --git a/scripts/run_containers b/scripts/run_containers\ndeleted file mode 100755\nindex d2c8066..0000000\n--- a/scripts/run_containers\n+++ /dev/null\n@@ -1,59 +0,0 @@\n-#!/usr/bin/env bash\n-\n-# This is a sanity test script for the CODI and toolchain Docker images.\n-# This runs the test containers.\n-# Then it runs ceed -l to talk to codi to list the 4 test toolchains\n-#\n-# Example:\n-#\n-# ./tests/run_containers [NUM_TOOLCHAIN CONATINERS TO START DEFAULT:4]\n-\n-TOPDIR=`git rev-parse --show-toplevel`\n-# note, currently the turff node and the container name MUST match exactly or have matching formats\n-# Example: TURFFID=repo/image:tag and container name repo-image-tag\n-# The Docker API does not allow special characters in container names except '-'\n-NAME_BASE=\"crops-toolchain-test\"\n-NUM_TOOLCHAINS=4\n-if [ \"$1\" != \"\" ]; then\n-  NUM_TOOLCHAINS=$1\n-fi\n-\n-\n-if [ \"$DEBUG\" == \"\" ]; then\n-    echo \"Start CODI container\"\n-    docker run -d --name codi-test -v /var/run/docker.sock:/var/run/docker.sock --net=host crops/codi:test || \\\n-\t{ echo 'docker run codi failed' ; exit 1; }\n-else\n-    echo \"Start DEBUG CODI container\"\n-    docker run -d --name codi-test-debug -v /var/run/docker.sock:/var/run/docker.sock --net=host crops/codi:testdebug || \\\n-\t{ echo 'docker run codi failed' ; exit 1; }\n-fi\n-II=0\n-while [ $II -lt $NUM_TOOLCHAINS ]; do\n-  echo \"Start toolchain container $II\"\n-  sleep 2;\n-  docker run -d --name ${NAME_BASE}${II} -v /crops/:/crops/ --env TURFFID=${NAME_BASE}${II} --net=host crops/toolchain:test || \\\n-  { echo 'docker run toolchain-test${II} failed' ; exit 1; }\n-  let II=$II+1\n-done\n-\n-echo \"Start Zephyr toolchain container\"\n-sleep 2;\n-mkdir -p $HOME/crops-test-workspace\n-docker run -d --name zephyr-test -v $HOME/crops-test-workspace/:/crops/ --env TURFFID=zephyr-test --net=host crops/zephyr:test || \\\n-  { echo 'docker run zephyr-test failed' ; exit 1; }\n-\n-echo \"List containers known to CODI\"\n-sleep 5;\n-cd ${TOPDIR}/ceed\n-\n-# if docker-machine exists then we are on a mac/windows and use the address of the vm we are running in\n-# else localhost\n-if [ -x \"$(command -v docker-machine)\" ]; then\n-  NAME=`docker-machine active`\n-  ADDRESS=`docker-machine ip ${NAME}`\n-else\n-  # linux can run over unix sockets rather than ip but ip is more cross platform\n-  ADDRESS=127.0.0.1\n-fi\n-./ceed -i $ADDRESS -s 10000 -l\ndiff --git a/scripts/stop_containers b/scripts/stop_containers\ndeleted file mode 100755\nindex b8d0cb7..0000000\n--- a/scripts/stop_containers\n+++ /dev/null\n@@ -1,33 +0,0 @@\n-#!/usr/bin/env bash\n-\n-# This is a sanity test script for the CODI and toolchain Docker images.\n-# This stops the test containers.\n-#\n-# Example:\n-#\n-# ./scripts/stop_containers\n-\n-NAME_BASE=\"crops-toolchain-test\"\n-\n-II=0\n-Q=`docker ps -a | egrep ${NAME_BASE}${II} | awk '{print $1}'`\n-while [ \"$Q\" != \"\"  ]; do\n-    echo \"Stop and Remove toolchain container $II\"\n-    docker rm -f $Q || { echo 'docker rm $Q failed' ; exit 1; };\n-    let II=$II+1\n-    Q=`docker ps -a | egrep ${NAME_BASE}${II} | awk '{print $1}'`\n-done\n-\n-echo \"Stop and remove Zephyr test container\"\n-Q=`docker ps -a | egrep zephyr-test | awk '{print $1}'`\n-if [ \"$Q\"  != \"\" ]; then\n-    echo \"Removing Zephyr container\"\n-    docker rm -f $Q || { echo 'docker rm $Q failed' ; exit 1; };\n-fi\n-\n-echo \"Stop and remove CODI test container\"\n-Q=`docker ps -a | egrep codi-test | awk '{print $1}'`\n-if [ \"$Q\"  != \"\" ]; then\n-    echo \"Removing codi container\"\n-    docker rm -f $Q || { echo 'docker rm $Q failed' ; exit 1; };\n-fi\ndiff --git a/tests.py b/tests.py\ndeleted file mode 100644\nindex f574c29..0000000\n--- a/tests.py\n+++ /dev/null\n@@ -1,32 +0,0 @@\n-''' CROPS test runner '''\n-\n-import unittest\n-import sys\n-\n-def run_unittests():\n-    ''' Execute Unit Tests '''\n-    tests = unittest.TestLoader().discover('tests/unit')\n-    result = unittest.TextTestRunner(verbosity=2).run(tests)\n-    return result.wasSuccessful()\n-\n-def run_functional_tests():\n-    ''' Execute Functional Tests '''\n-    tests = unittest.TestLoader().discover('tests/functional')\n-    result = unittest.TextTestRunner(verbosity=2).run(tests)\n-    return result.wasSuccessful()\n-\n-if __name__ == '__main__':\n-    print \"#\" * 70\n-    print \"Test Runner: Unit tests\"\n-    print \"#\" * 70\n-    unit_results = run_unittests()\n-\n-    print \"#\" * 70\n-    print \"Test Runner: Functional tests\"\n-    print \"#\" * 70\n-    functional_results = run_functional_tests()\n-\n-    if unit_results and functional_results:\n-        sys.exit(0)\n-    else:\n-        sys.exit(1)\ndiff --git a/tests/functional/test_ceed_basic.py b/tests/functional/test_ceed_basic.py\ndeleted file mode 100644\nindex ed7a7a9..0000000\n--- a/tests/functional/test_ceed_basic.py\n+++ /dev/null\n@@ -1,104 +0,0 @@\n-''' Test Basic ceed/codi api'''\n-\n-import unittest\n-import re\n-import subprocess\n-import utils.ceedutil as ceedutil\n-\n-\n-# This test set ASSUMES the initial scripts have been run and therefore we have\n-# 1) 1 codi container named codi-test\n-# 2) 4 toolchain containers named test-toolchain-test[0-3]\n-\n-\n-\n-\n-class CeedBasicTests(unittest.TestCase):\n-    ''' Base class for testing ceed '''\n-\n-    def setUp(self):\n-        ''' Define some unique data for validation '''\n-        self.dockerAddress = ceedutil.getDockerAddress().strip()\n-        self.tbase=ceedutil.ToolchainNameBase\n-        self.tnum=ceedutil.ToolchainNumber\n-        self.cPort=ceedutil.CodiPort\n-\n-    def tearDown(self):\n-        ''' Destroy unique data '''\n-        self.dockerAddress = None\n-\n-    def test_connect(self):\n-        ''' Connect to codi'''\n-        SUBSTRING=\"Connected to CODI on\"\n-        try:\n-            p = subprocess.Popen([\"ceed/ceed\",\"-i\",self.dockerAddress,\"-l\"],stdout=subprocess.PIPE)\n-        except subprocess.CalledProcessError as e:\n-            print e.output\n-            self.assertTrue(False)\n-\n-        success=False\n-        output=p.communicate()[0]\n-\n-        for line in output.split('\\n'):\n-            if line.find(SUBSTRING) >= 0:\n-                success=True\n-                break\n-        self.assertTrue(success)\n-\n-    def test_connect_with_port(self):\n-        ''' Connect to codi'''\n-        SUBSTRING=\"Connected to CODI on\"\n-        try:\n-            p = subprocess.Popen([\"ceed/ceed\",\"-i\",self.dockerAddress,\"-s\",str(self.cPort),\"-l\"],stdout=subprocess.PIPE)\n-        except subprocess.CalledProcessError as e:\n-            print e.output\n-            self.assertTrue(False)\n-\n-        success=False\n-        output=p.communicate()[0]\n-\n-        for line in output.split('\\n'):\n-            if line.find(SUBSTRING) >= 0:\n-                success=True\n-                break\n-        self.assertTrue(success)\n-\n-    def test_connect_with_badport_shouldfail(self):\n-        ''' Connect to codi'''\n-        SUBSTRING=\"Connected to CODI on\"\n-        try:\n-            p = subprocess.Popen([\"ceed/ceed\",\"-i\",self.dockerAddress,\"-s\",str(self.cPort+1),\"-l\"],stdout=subprocess.PIPE)\n-        except subprocess.CalledProcessError as e:\n-            print e.output\n-            self.assertTrue(False)\n-\n-        success=False\n-        output=p.communicate()[0]\n-\n-        for line in output.split('\\n'):\n-            if line.find(SUBSTRING) >= 0:\n-                success=True\n-                break\n-        self.assertFalse(success)\n-\n-\n-    def test_listContainers(self):\n-        ''' List all the toolchain Containers'''\n-        SUBSTRING1=\"TURFF\"\n-        SUBSTRING2=self.tbase\n-        EXPECTED_COUNT=4\n-        try:\n-            p = subprocess.Popen([\"ceed/ceed\",\"-i\",self.dockerAddress,\"-l\"],stdout=subprocess.PIPE)\n-        except subprocess.CalledProcessError as e:\n-            print e.output\n-            self.assertTrue(False)\n-\n-\n-        count=0\n-        output=p.communicate()[0]\n-\n-        for line in output.split('\\n'):\n-            if line.find(SUBSTRING1) >= 0:\n-                if line.find(SUBSTRING2) >= 0:\n-                    count+=1\n-        self.assertEqual(count,EXPECTED_COUNT)\ndiff --git a/tests/functional/test_ceed_commands.py b/tests/functional/test_ceed_commands.py\ndeleted file mode 100644\nindex 72c22ea..0000000\n--- a/tests/functional/test_ceed_commands.py\n+++ /dev/null\n@@ -1,121 +0,0 @@\n-''' Test Basic ceed/codi api'''\n-\n-import unittest\n-import re\n-import subprocess\n-import utils.ceedutil as ceedutil\n-\n-\n-# This test set ASSUMES the initial scripts have been run and therefore we have\n-# 1) 1 codi container named codi-test\n-# 2) 4 toolchain containers named test-toolchain-test[0-3]\n-\n-\n-class CeedCommandsTests(unittest.TestCase):\n-    ''' Base class for testing ceed '''\n-\n-    def setUp(self):\n-        ''' Define some unique data for validation '''\n-        self.dockerAddress = ceedutil.getDockerAddress().strip()\n-        self.tbase=ceedutil.ToolchainNameBase\n-        self.tnum=ceedutil.ToolchainNumber\n-\n-    def tearDown(self):\n-        ''' Destroy unique data '''\n-        self.dockerAddress = None\n-\n-    def test_command(self):\n-        ''' Get Output from simple command'''\n-        SUBSTRING=\"/bin/bash\"\n-        try:\n-            p = subprocess.Popen([\"ceed/ceed\",\"-i\",self.dockerAddress,\"-d\",self.tbase+\"0\", \"-g\",\"which bash\"],stdout=subprocess.PIPE)\n-        except subprocess.CalledProcessError as e:\n-            print e.output\n-            self.assertTrue(False)\n-\n-        success=False\n-        output=p.communicate()[0]\n-\n-        for line in output.split('\\n'):\n-            if line.find(SUBSTRING) >= 0:\n-                success=True\n-                break\n-        self.assertTrue(success)\n-\n-    def test_command_all(self):\n-        ''' Get Output from simple command for all containers'''\n-        SUBSTRING=\"/bin/bash\"\n-        successAll=True\n-        for i in range(self.tnum):\n-            try:\n-                p = subprocess.Popen([\"ceed/ceed\",\"-i\",self.dockerAddress,\"-d\",self.tbase+str(i), \"-g\",\"which bash\"],stdout=subprocess.PIPE)\n-            except subprocess.CalledProcessError as e:\n-                print e.output\n-                self.assertTrue(False)\n-\n-            success=False\n-            output=p.communicate()[0]\n-\n-            for line in output.split('\\n'):\n-                if line.find(SUBSTRING) >= 0:\n-                    success=True\n-                    break\n-            successAll&=success\n-        self.assertTrue(successAll)\n-\n-\n-    def test_command_args_switch(self):\n-        ''' Get Output from simple command using argument switch'''\n-        SUBSTRING=\"/bin/bash\"\n-        try:\n-            p = subprocess.Popen([\"ceed/ceed\",\"-i\",self.dockerAddress,\"-d\",self.tbase+\"0\", \"-r\",\"bash\",\"-g\",\"which\"],stdout=subprocess.PIPE)\n-        except subprocess.CalledProcessError as e:\n-            print e.output\n-            self.assertTrue(False)\n-\n-        success=False\n-        output=p.communicate()[0]\n-\n-        for line in output.split('\\n'):\n-            if line.find(SUBSTRING) >= 0:\n-                success=True\n-                break\n-        self.assertTrue(success)\n-\n-\n-    def test_command_env_inline(self):\n-        ''' Pass env as Q=R cmd'''\n-        SUBSTRING=\"FROGS=FRIENDS\"\n-        try:\n-            p = subprocess.Popen([\"ceed/ceed\",\"-i\",self.dockerAddress,\"-d\",self.tbase+\"0\", \"-g\",\"FROGS=FRIENDS printenv\"],stdout=subprocess.PIPE)\n-        except subprocess.CalledProcessError as e:\n-            print e.output\n-            self.assertTrue(False)\n-\n-        success=False\n-        output=p.communicate()[0]\n-\n-        for line in output.split('\\n'):\n-            if line.find(SUBSTRING) >= 0:\n-                success=True\n-                break\n-        self.assertTrue(success)\n-\n-    # This will be added when the -e flag is fixed\n-    # def test_command_env_as_argument(self):\n-    #     ''' Pass env using the -e switch to cmd'''\n-    #     SUBSTRING=\"FROGS=FRIENDS\"\n-    #     try:\n-    #         p = subprocess.Popen([\"ceed/ceed\",\"-i\",self.dockerAddress,\"-d\",self.tbase+\"0\", \"-e\",\"FROGS=FRIENDS\",\"-g\",\"printenv\"],stdout=subprocess.PIPE)\n-    #     except subprocess.CalledProcessError as e:\n-    #         print e.output\n-    #         self.assertTrue(False)\n-\n-    #     success=False\n-    #     output=p.communicate()[0]\n-\n-    #     for line in output.split('\\n'):\n-    #         if line.find(SUBSTRING) >= 0:\n-    #             success=True\n-    #             break\n-    #     self.assertTrue(success)\ndiff --git a/tests/functional/test_zephyr_build.py b/tests/functional/test_zephyr_build.py\ndeleted file mode 100644\nindex 97fedf7..0000000\n--- a/tests/functional/test_zephyr_build.py\n+++ /dev/null\n@@ -1,101 +0,0 @@\n-''' Test Zephyr Build'''\n-import unittest\n-import re\n-import subprocess\n-import os.path\n-import utils.ceedutil as ceedutil\n-\n-\n-# This test set ASSUMES the initial scripts have been run and therefore we have\n-# 1) 1 codi container named codi-test\n-# 2) 1 zephyr toolchain container named zephyr-test\n-\n-\n-class ZephyrBuildTest(unittest.TestCase):\n-    ''' Base class for testing Zephyr builds '''\n-\n-    def setUp(self):\n-        ''' Define some unique data for validation '''\n-        self.dockerAddress = ceedutil.getDockerAddress().strip()\n-        self.codiPort=ceedutil.CodiPort\n-        self.zephyrName=\"zephyr-test\"\n-        self.zephyrHostPath=os.environ['HOME']+\"/crops-test-workspace/\"\n-        self.zephyrContainerPath=\"/crops/\"\n-        self.zephyrPrjPath=\"zephyr-project/samples/nanokernel/apps/hello_world/\"\n-        self.zephyrBin=\"outdir/zephyr.bin\"\n-        self.devnull=open(os.devnull, 'w')\n-\n-    def tearDown(self):\n-        ''' Destroy unique data '''\n-        self.dockerAddress = None\n-\n-    def test_a_git_clone(self):\n-        ''' Checkout Zephyr source'''\n-        SUBSTRING=\"Note: checking out\"\n-        try:\n-            subprocess.call([\"rm\",\"-rf\",os.environ['HOME']+\"/crops-test-workspace/zephyr-project\"],stdout=self.devnull)\n-            subprocess.call([\"ceed/ceed\",\"-i\",self.dockerAddress,\"-d\",self.zephyrName, \"-s\",str(self.codiPort),\n-                \"-g\",\"git clone --branch v1.0.0 /zephyr-src /crops/zephyr-project\"],stdout=self.devnull)\n-        except subprocess.CalledProcessError as e:\n-            print e.output\n-            self.assertTrue(False)\n-\n-        success=False\n-\n-        if os.path.isdir(self.zephyrHostPath+self.zephyrPrjPath):\n-            success=True\n-\n-        self.assertTrue(success)\n-\n-    def test_x86_build(self):\n-        ''' Build X86 hello world application\\n'''\n-        BOARD=\"arduino_101\"\n-        try:\n-            subprocess.call([\"scripts/make.zephyr\",\"pristine\",\"BOARD=\"+BOARD,\"-C\",self.zephyrContainerPath+self.zephyrPrjPath],stdout=self.devnull)\n-            subprocess.call([\"scripts/make.zephyr\",\"BOARD=\"+BOARD,\"-C\",self.zephyrContainerPath+self.zephyrPrjPath],stdout=self.devnull)\n-        except subprocess.CalledProcessError as e:\n-            print e.output\n-            self.assertTrue(False)\n-\n-        success=False\n-\n-        if os.path.isfile(self.zephyrHostPath+self.zephyrPrjPath + self.zephyrBin):\n-            success=True\n-\n-        self.assertTrue(success)\n-\n-\n-    def test_arm_build(self):\n-        ''' Build ARM hello world application\\n'''\n-        BOARD=\"arduino_due\"\n-        try:\n-            subprocess.call([\"scripts/make.zephyr\",\"pristine\",\"BOARD=\"+BOARD,\"-C\",self.zephyrContainerPath+self.zephyrPrjPath],stdout=self.devnull)\n-            subprocess.call([\"scripts/make.zephyr\",\"BOARD=\"+BOARD,\"-C\",self.zephyrContainerPath+self.zephyrPrjPath],stdout=self.devnull)\n-        except subprocess.CalledProcessError as e:\n-            print e.output\n-            self.assertTrue(False)\n-\n-        success=False\n-\n-        if os.path.isfile(self.zephyrHostPath+self.zephyrPrjPath + self.zephyrBin):\n-            success=True\n-\n-        self.assertTrue(success)\n-\n-\n-    def test_arc_build(self):\n-        ''' Build ARC hello world application\\n'''\n-        BOARD=\"arduino_101_sss\"\n-        try:\n-            subprocess.call([\"scripts/make.zephyr\",\"pristine\",\"BOARD=\"+BOARD,\"-C\",self.zephyrContainerPath+self.zephyrPrjPath],stdout=self.devnull)\n-            subprocess.call([\"scripts/make.zephyr\",\"BOARD=\"+BOARD,\"-C\",self.zephyrContainerPath+self.zephyrPrjPath],stdout=self.devnull)\n-        except subprocess.CalledProcessError as e:\n-            print e.output\n-            self.assertTrue(False)\n-\n-        success=False\n-\n-        if os.path.isfile(self.zephyrHostPath+self.zephyrPrjPath + self.zephyrBin):\n-            success=True\n-\n-        self.assertTrue(success)\ndiff --git a/tests/functional/utils/__init__.py b/tests/functional/utils/__init__.py\ndeleted file mode 100644\nindex e69de29..0000000\ndiff --git a/tests/functional/utils/ceedutil.py b/tests/functional/utils/ceedutil.py\ndeleted file mode 100644\nindex ea75b90..0000000\n--- a/tests/functional/utils/ceedutil.py\n+++ /dev/null\n@@ -1,20 +0,0 @@\n-# some shared utility functions\n-import subprocess\n-\n-ToolchainNameBase=\"crops-toolchain-test\"\n-ToolchainNumber=4\n-CodiPort=10000\n-def cmd_exists(cmd):\n-    return subprocess.call (\"command -v \"+cmd,shell=True,\n-                            stdout=subprocess.PIPE,stderr=subprocess.PIPE)==0\n-\n-def getDockerMachineAddress():\n-    machine_name=subprocess.check_output(['docker-machine','active'])\n-    ADDRESS=subprocess.check_output(['docker-machine','ip',machine_name.strip()])\n-    return ADDRESS\n-\n-def getDockerAddress():\n-    ADDRESS=\"127.0.0.1\"\n-    if cmd_exists('docker-machine'):\n-        ADDRESS=getDockerMachineAddress()\n-    return ADDRESS\ndiff --git a/tests/unit/test_basic.py b/tests/unit/test_basic.py\ndeleted file mode 100644\nindex 1856536..0000000\n--- a/tests/unit/test_basic.py\n+++ /dev/null\n@@ -1,19 +0,0 @@\n-''' Crawl the running Docker site and verify all links give a 200 OK '''\n-\n-import unittest\n-import subprocess\n-\n-\n-# Placeholder for future python based codi/TURFF\n-\n-class BasicTests(unittest.TestCase):\n-    ''' Base class for testing '''\n-\n-    def setUp(self):\n-        ''' Define some unique data for validation '''\n-        pass\n-\n-\n-    def tearDown(self):\n-        ''' Destroy unique data '''\n-        pass\ndiff --git a/tests/unit/test_runbitbake.py b/tests/unit/test_runbitbake.py\ndeleted file mode 100644\nindex 3b3a733..0000000\n--- a/tests/unit/test_runbitbake.py\n+++ /dev/null\n@@ -1,130 +0,0 @@\n-#!/usr/bin/env python\n-\n-import unittest\n-import os\n-import subprocess\n-import shutil\n-import tempfile\n-import sys\n-import stat\n-import imp\n-\n-\n-class RunBitbakeTestBase(unittest.TestCase):\n-    def setUp(self):\n-        self.tempdir = tempfile.mkdtemp(prefix=\"runbitbaketest-tmpdir\")\n-\n-        self.pokydir = os.path.join(self.tempdir, \"poky\")\n-        os.mkdir(self.pokydir)\n-\n-        # runbitbake.py requires --pokydir with a \"oe-init-build-env\" script\n-        self.setupscript = os.path.join(self.pokydir, \"oe-init-build-env\")\n-        with open(self.setupscript, \"w\"):\n-            pass\n-\n-        # Create a builddir and confdir as if oe-init-build-env had ran\n-        self.builddir = os.path.join(self.tempdir, \"build\")\n-        self.confdir = os.path.join(self.builddir, \"conf\")\n-        os.mkdir(self.builddir)\n-        os.mkdir(self.confdir)\n-\n-        # Create an executable bitbake that does nothing\n-        self.bindir = os.path.join(self.tempdir, \"bin\")\n-        os.mkdir(self.bindir)\n-\n-        self.bitbake = os.path.join(self.bindir, \"bitbake\")\n-        with open(self.bitbake, \"w\") as f:\n-            f.write(\"#!/bin/sh\\n\")\n-            os.chmod(self.bitbake, stat.S_IRWXU)\n-\n-        # Make sure runbitbake.py can run our fake bitbake\n-        os.environ[\"PATH\"] = \"{}:{}\".format(self.bindir, os.environ[\"PATH\"])\n-\n-        # We will have one line local.conf and bblayers.conf.\n-        self.local_conf = os.path.join(self.confdir, \"local.conf\")\n-        with open(self.local_conf, \"w\") as f:\n-            f.write(\"Some data\\n\")\n-\n-        self.bblayers_conf = os.path.join(self.confdir, \"bblayers.conf\")\n-        with open(self.bblayers_conf, \"w\") as f:\n-            f.write(\"Other data\\n\")\n-\n-        # Create the files that contain extra data to be added to the original\n-        # configuration files\n-        self.extraconf = os.path.join(self.tempdir, \"extra.conf\")\n-        with open(self.extraconf, \"w\") as f:\n-            f.write(\"MOAR STUFF\\nEVEN MOAR!!!!\\n\")\n-\n-        self.extralayers = os.path.join(self.tempdir, \"bblayers_extra.conf\")\n-        with open(self.extralayers, \"w\") as f:\n-            f.write(\"BBLAYERS MOAR STUFF\\nEVEN MOAR BBLAYERS!!!!\\n\")\n-\n-    def tearDown(self):\n-        shutil.rmtree(self.tempdir, ignore_errors=True)\n-\n-\n-class ConfFilesTest(RunBitbakeTestBase):\n-    def setUp(self):\n-        super(ConfFilesTest, self).setUp()\n-\n-        # These \".orig\" files are for checking that the file is restored back\n-        # to the original state\n-        self.local_conf_orig = os.path.join(self.tempdir, \"local.conf.orig\")\n-        self.bblayers_conf_orig = os.path.join(self.tempdir,\n-                                               \"bblayers.conf.orig\")\n-        shutil.copyfile(self.local_conf, self.local_conf_orig)\n-        shutil.copyfile(self.bblayers_conf, self.bblayers_conf_orig)\n-\n-\n-\n-    def test_files_are_restored(self):\n-        cmd = \"\"\"python helpers/runbitbake.py --pokydir={} \"\"\" \\\n-              \"\"\"-t junk -b {} \"\"\" \\\n-              \"\"\"--extraconf={} \"\"\" \\\n-              \"\"\"--extralayers={}\"\"\".format(self.pokydir, self.builddir,\n-                                            self.extraconf, self.extralayers)\n-\n-        subprocess.call(cmd.split(), stderr=sys.stderr, stdout=sys.stdout,\n-                        shell=False)\n-\n-        with open(self.local_conf_orig, \"r\") as f:\n-            origlines = f.readlines()\n-        with open(self.local_conf, \"r\") as f:\n-            newlines = f.readlines()\n-        self.assertListEqual(origlines, newlines)\n-\n-        with open(self.bblayers_conf_orig, \"r\") as f:\n-            origlines = f.readlines()\n-        with open(self.bblayers_conf, \"r\") as f:\n-            newlines = f.readlines()\n-        self.assertListEqual(origlines, newlines)\n-\n-\n-class AddExtraTest(RunBitbakeTestBase):\n-    def setUp(self):\n-        super(AddExtraTest, self).setUp()\n-        # Since we are importing a file in the source directory, this prevents\n-        # cluttering the directory with a .pyc file.\n-        sys.dont_write_bytecode = True\n-\n-        self.runbitbake = os.path.join(\"helpers\", \"runbitbake.py\")\n-        self.module = imp.load_source(\"\", self.runbitbake)\n-\n-        self.addextra_tempdir = os.path.join(self.tempdir, \"addextratmp\")\n-        os.mkdir(self.addextra_tempdir)\n-\n-    def test_addextra_changed_files(self):\n-        addextra = self.module.addextra\n-        addextra(self.addextra_tempdir, self.builddir, \"local.conf\",\n-                 [self.extraconf])\n-\n-        with open(self.extraconf, \"r\") as f:\n-            extraconflines = set(f.readlines())\n-        with open(self.local_conf, \"r\") as f:\n-            localconflines = set(f.readlines())\n-\n-        intersection = extraconflines & localconflines\n-        self.assertListEqual(list(intersection), list(extraconflines))\n-\n-if __name__ == '__main__':\n-    unittest.main()\ndiff --git a/turff/Makefile b/turff/Makefile\ndeleted file mode 100755\nindex 1664c59..0000000\n--- a/turff/Makefile\n+++ /dev/null\n@@ -1,19 +0,0 @@\n-CFLAGS=-g -I. -I../\n-LDFLAGS=-lm\n-DEPS = turff_api.h ../globals.h ../utils.h\n-OBJ = turff.o turff_api.o ../utils.o ../globals.o\n-\n-all: turff\n-\n-debug: DFLAGS=-DDBG\n-debug: clean turff\n-\n-%.o: %.c $(DEPS)\n-\t$(CC) -c -o $@ $< $(CFLAGS) $(DFLAGS)\n-\n-turff: $(OBJ)\n-\t$(CC) -o $@ $^ $(CFLAGS) $(LDFLAGS)\n-\n-.PHONY: clean\n-clean:\n-\trm -rf $(OBJ) turff\ndiff --git a/turff/turff.c b/turff/turff.c\ndeleted file mode 100755\nindex d63fb99..0000000\n--- a/turff/turff.c\n+++ /dev/null\n@@ -1,128 +0,0 @@\n-/*\n- * Copyright (C) 2016 Intel Corporation\n- *\n- * Author: Todor Minchev <todor.minchev@linux.intel.com>\n- *\n- * This program is free software; you can redistribute it and/or modify it\n- * under the terms and conditions of the GNU General Public License,\n- * version 2, or (at your option) any later version, as published by\n- * the Free Software Foundation.\n- *\n- * This program is distributed in the hope it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n- * more details.\n- */\n-\n-#include \"globals.h\"\n-#include <stdlib.h>\n-#include <signal.h>\n-#include <netdb.h>\n-#include \"utils.h\"\n-#include \"turff_api.h\"\n-\n-#define PORT_RANGE 100\n-extern char *turff_ops[];\n-extern char *codi_params[];\n-static int sock_fd;\n-\n-/*TODO - close sockets on CTRL+C. Get rid of this when running as a daemon */\n-void close_sockets(int dummy) {\n-  close(sock_fd);\n-  INFO(\"\\nClosed the sockets. Exiting!\\n\") ;\n-  exit(0);\n-}\n-\n-int main(int argc, char *argv[]) {\n-\n-  struct addrinfo *addr_p = NULL;\n-  struct sockaddr cli_addr;\n-  socklen_t cli_len;\n-  int i, ceed_sock_fd, saved_out = -1, saved_err = -1, bound = 0;\n-  const char *port;\n-\n-  parse_turff_params(argc, argv);\n-\n-  bound = 0;\n-  port = turff_ops[KEY('s')];\n-  while(!bound && (int) *port > (int) *turff_ops[KEY('s')] - PORT_RANGE) {\n-\n-    addr_p = bind_to_socket(NULL, port, &sock_fd);\n-\n-    if (addr_p == NULL) {\n-      asprintf((char**)&port, \"%d\", atoi(port)-1) ;\n-    } else {\n-      turff_ops[KEY('s')] = (char*) port;\n-      register_agent(turff_ops);\n-      bound = 1;\n-      INFO(\"TURFF listening on port: %s\\n\", port);\n-    }\n-  }\n-\n-  if (addr_p == NULL) {\n-    ERR(\"Could not bind agent to socket\\n\");\n-    exit(EXIT_FAILURE);\n-  }\n-\n-  listen(sock_fd,1);\n-  cli_len = sizeof(cli_addr);\n-\n-  signal(SIGINT, close_sockets);\n-\n-  while(1) {\n-    ceed_sock_fd = accept(sock_fd, &cli_addr, &cli_len);\n-\n-    if (ceed_sock_fd < 0) {\n-      ERR(\"ERROR on accept\");\n-    }\n-\n-    /* receive parameters from CODI */\n-    receive_args(ceed_sock_fd, codi_params);\n-\n-    if (!strcmp(CODI_NAME, codi_params[KEY('z')])) {\n-      /* save stdout and stderr file descriptors */\n-      dup2(2, saved_err);\n-      dup2(1, saved_out);\n-\n-      /* redirect stdout & stderr to ceed socket */\n-      dup2(ceed_sock_fd, 2);\n-      dup2(ceed_sock_fd, 1);\n-\n-      /* make sure ceed and turff APIs match*/\n-      if (!strcmp(turff_ops[KEY('v')], codi_params[KEY('v')])) {\n-        /* process ceed requests */\n-        if (process_params(codi_params))\n-          ERR(\"ERROR processing ceed request\\n\");\n-      } else {\n-        INFO(\"Incompatible versions: TURFF[%s] - CODI[%s]\\n\",\n-        turff_ops[KEY('v')], codi_params[KEY('v')]);\n-      }\n-\n-      /* delay EOM - send as separate buffer */\n-      fprintf(stdout, TURFF_EOM);\n-      fflush(stdout);\n-\n-      /* restore stdout and stderr */\n-      dup2(saved_err, 2);\n-      dup2(saved_out, 1);\n-\n-      /* clear parameters and wait for a new service request */\n-      for (i = 0; i< KEY_ARR_SZ; i++){\n-        if (codi_params[i] != NULL) {\n-#ifdef DBG\n-          DEBUG(\"Received parameter [%c] : %s\\n\", i+'a', codi_params[i] );\n-#endif\n-          free(codi_params[i]);\n-          codi_params[i] = NULL ;\n-        }\n-      }\n-    } else {\n-      /* ceed connected to turff directly. send it EOM*/\n-      INFO(\"Request did not originate from CODI!\\n\");\n-      codi_params[KEY('e')] = \"set\";\n-      send_args(ceed_sock_fd, codi_params);\n-    }\n-    close(ceed_sock_fd);\n-  }\n-}\n-\ndiff --git a/turff/turff_api.c b/turff/turff_api.c\ndeleted file mode 100755\nindex 1cd3728..0000000\n--- a/turff/turff_api.c\n+++ /dev/null\n@@ -1,255 +0,0 @@\n-/*\n- * Copyright (C) 2016 Intel Corporation\n- *\n- * Author: Todor Minchev <todor.minchev@linux.intel.com>\n- *\n- * This program is free software; you can redistribute it and/or modify it\n- * under the terms and conditions of the GNU General Public License,\n- * version 2, or (at your option) any later version, as published by\n- * the Free Software Foundation.\n- *\n- * This program is distributed in the hope it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n- * more details.\n- */\n-\n-#include \"globals.h\"\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <strings.h>\n-#include <unistd.h>\n-#include <errno.h>\n-#include <ctype.h>\n-#include \"utils.h\"\n-\n-const char workspace_root[] = \"/crops\";\n-char *turff_ops[KEY_ARR_SZ];\n-char *codi_params[KEY_ARR_SZ];\n-\n-void print_turff_usage(int argc, char *argv[]) {\n-  printf(\"Usage: %s \\n\", argv[0]);\n-  printf(\" -s port number on which the agent is listening [default: 9999]\\n\");\n-  printf(\" -i CODI IP address [default: 127.0.0.1]\\n\");\n-  printf(\" -d CODI port number [default: 10000]\\n\");\n-  printf(\" -n node_id to be sent to CODI [default: TURFFID env variable]\\n\");\n-  printf(\" -h print this help menu\\n\");\n-  printf(\" -v show turff version\\n\");\n-}\n-\n-void init_turff_params(){\n-  int i;\n-\n-  for (i = 0; i <  KEY_ARR_SZ; i++)\n-    codi_params[i] = NULL;\n-\n-  turff_ops[KEY('s')] = TURFF_PORT;\n-  turff_ops[KEY('v')] = VERSION;\n-  turff_ops[KEY('i')] = CODI_IP_NATIVE;\n-  turff_ops[KEY('d')] = CODI_PORT;\n-  turff_ops[KEY('z')] = TURFF_NAME;\n-}\n-\n-void parse_turff_params(int argc, char *argv[]) {\n-  int c ;\n-\n-  init_turff_params() ;\n-\n-  while ((c = getopt(argc, argv, \"hvi:d:s:i:n:\")) != -1) {\n-    switch (c) {\n-    case 'h':\n-      print_turff_usage(argc, argv);\n-      exit(EXIT_SUCCESS);\n-      break;\n-    case 'v':\n-      INFO(\"turff version : %s\\n\", VERSION);\n-      exit(EXIT_SUCCESS);\n-      break;\n-    case 's':\n-      turff_ops[KEY('s')]  = optarg;\n-      break;\n-    case 'i':\n-      turff_ops[KEY('i')]  = optarg;\n-      break;\n-    case 'd':\n-      turff_ops[KEY('d')]  = optarg;\n-      break;\n-    case 'n':\n-      turff_ops[KEY('n')]  = optarg;\n-      break;\n-    case '?':\n-      if (optopt == 's')\n-        INFO(\"Option -%c requires an argument.\\n\", optopt);\n-      else if (isprint (optopt))\n-        INFO(\"Unknown option `-%c'.\\n\", optopt);\n-      else\n-        INFO(\"Unknown option character `\\\\x%x'.\\n\", optopt);\n-    default:\n-      print_turff_usage(argc, argv);\n-      exit(EXIT_FAILURE);\n-    }\n-  }\n-}\n-\n-/* TODO - add error checks and return error codes*/\n-int exec_command(char* cmd) {\n-  system(cmd);\n-  free(cmd);\n-  return 0;\n-}\n-\n-/* TODO - add error checks and return error codes*/\n-int build_at_prj(char *platform, char *prj_dir)\n-{\n-  char cmd[] = \"cd %s/%s/%s; chmod -R 777 *;./autogen.sh $CONFIGURE_FLAGS; make;\";\n-  char *build_cmd;\n-\n-  asprintf(&build_cmd, cmd, workspace_root, platform, prj_dir);\n-  exec_command(build_cmd);\n-  return 0;\n-}\n-\n-/* TODO - add error checks and return error codes*/\n-int clean_at_prj(char *platform, char *prj_dir) {\n-  char cmd[] = \"make distclean -C %s/%s/%s/\";\n-  char *clean_cmd;\n-\n-  asprintf(&clean_cmd, cmd, workspace_root, platform, prj_dir);\n-  exec_command(clean_cmd);\n-  return 0;\n-}\n-\n-/* TODO - add error checks and return error codes*/\n-int build_cm_prj(char *platform, char *prj_dir)\n-{\n-  char cmd[] = \"cd %s/%s/%s; mkdir -p build; cd build; cmake ../; make;\";\n-  char *build_cmd;\n-\n-  asprintf(&build_cmd, cmd, workspace_root, platform, prj_dir);\n-  exec_command(build_cmd);\n-  return 0;\n-}\n-\n-/* TODO - add error checks and return error codes*/\n-int clean_cm_prj(char *platform, char *prj_dir)\n-{\n-  char cmd[] = \"make clean -C %s/%s/%s/build;\";\n-  char *clean_cmd;\n-\n-  asprintf(&clean_cmd, cmd, workspace_root, platform, prj_dir);\n-  exec_command(clean_cmd);\n-  return 0;\n-}\n-\n-/* TODO - add error checks and return error codes*/\n-int build_m_prj(char *platform, char *prj_dir, char *make_target)\n-{\n-  char cmd[] = \"make %s -C %s/%s/%s\";\n-  char *build_cmd;\n-\n-  asprintf(&build_cmd, cmd, make_target, workspace_root, platform, prj_dir);\n-  exec_command(build_cmd);\n-  return 0;\n-}\n-\n-/* TODO - add error checks and return error codes*/\n-int clean_m_prj(char *platform, char *prj_dir) {\n-  char cmd[] = \"make clean -C %s/%s/%s/\";\n-  char *clean_cmd;\n-\n-  asprintf(&clean_cmd, cmd, workspace_root, platform, prj_dir);\n-  exec_command(clean_cmd);\n-  return 0;\n-}\n-\n-/* TODO - add error checks and return error codes*/\n-int generic_cmd(char *params[]) {\n-  char cmd[] = \"%s %s\";\n-  char *gen_cmd;\n-\n-  asprintf(&gen_cmd, cmd, params[KEY('g')], params[KEY('r')]);\n-  exec_command(gen_cmd);\n-  return 0;\n-}\n-\n-/* TODO - add error checks and return error codes*/\n-int build_prj(char *params[])\n-{\n-  if(params[KEY('t')] != NULL)\n-    build_at_prj(params[KEY('a')], params[KEY('p')]);\n-  else if(params[KEY('m')] != NULL)\n-    build_m_prj(params[KEY('a')], params[KEY('p')], params[KEY('m')]);\n-  else if(params[KEY('k')] != NULL)\n-    build_cm_prj(params[KEY('a')], params[KEY('p')]);\n-  else\n-    return -1;\n-\n-  return 0;\n-}\n-\n-/* TODO - add error checks and return error codes*/\n-int clean_prj(char *params[])\n-{\n-  if(params[KEY('t')] != NULL)\n-    clean_at_prj(params[KEY('a')], params[KEY('p')]);\n-  else if(params[KEY('m')] != NULL)\n-    clean_m_prj(params[KEY('a')], params[KEY('p')]);\n-  else if(params[KEY('k')] != NULL)\n-    clean_cm_prj(params[KEY('a')], params[KEY('p')]);\n-  else\n-    return -1;\n-\n-  return 0;\n-}\n-\n-/* TODO - add error checks and return error codes*/\n-int process_params(char *params[]) {\n-  int i;\n-  for (i = 0; i< KEY_ARR_SZ; i++){\n-    if(params[i] != NULL) {\n-      switch ('a' + i) {\n-      case 'b':\n-        build_prj(params);\n-        break;\n-      case 'c':\n-        clean_prj(params);\n-        break;\n-      case 'g':\n-        generic_cmd(params);\n-        break;\n-      }\n-    }\n-  }\n-  return 0;\n-}\n-\n-/* TODO - send port map to CODI*/\n-int register_agent(char *turff_ops[]) {\n-  int turff_sock_fd;\n-  struct addrinfo *addr_p;\n-  char *turff_id;\n-\n-  addr_p = connect_to_socket(turff_ops[KEY('i')], turff_ops[KEY('d')], &turff_sock_fd);\n-\n-  if(addr_p == NULL) {\n-    INFO(\"Please ensure that CODI is running\\n\");\n-    ERR(\"Could not connect to CODI\\n\");\n-  } else {\n-    INFO(\"Connected to codi on %s:%s\\n\",\n-      turff_ops[KEY('i')], turff_ops[KEY('d')]);\n-  }\n-\n-  if (turff_ops[KEY('n')] == NULL) {\n-    turff_id = getenv(TURFFID);\n-    if(turff_id == NULL) {\n-      INFO(\"Unable to read TURFFID from the environment\\n\");\n-      INFO(\"Setting TURFFID to \\\"default\\\"\\n\");\n-      turff_ops[KEY('n')] = \"default\" ;\n-    } else\n-      turff_ops[KEY('n')] = turff_id ;\n-  }\n-  sleep(2);\n-  send_args(turff_sock_fd, turff_ops);\n-\n-  return 0;\n-}\ndiff --git a/turff/turff_api.h b/turff/turff_api.h\ndeleted file mode 100755\nindex c2a3aed..0000000\n--- a/turff/turff_api.h\n+++ /dev/null\n@@ -1,24 +0,0 @@\n-/*\n- * Copyright (C) 2016 Intel Corporation\n- *\n- * Author: Todor Minchev <todor.minchev@linux.intel.com>\n- *\n- * This program is free software; you can redistribute it and/or modify it\n- * under the terms and conditions of the GNU General Public License,\n- * version 2, or (at your option) any later version, as published by\n- * the Free Software Foundation.\n- *\n- * This program is distributed in the hope it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n- * more details.\n- */\n-\n-#ifndef TURFF_API_H\n-#define TURFF_API_H\n-\n-void parse_turff_params(int argc, char *argv[]);\n-int process_params(char *params[]);\n-int register_agent(char *turff_ops[]);\n-\n-#endif\ndiff --git a/turff/turff_launcher b/turff/turff_launcher\ndeleted file mode 100755\nindex 0df0594..0000000\n--- a/turff/turff_launcher\n+++ /dev/null\n@@ -1,43 +0,0 @@\n-#!/usr/bin/env bash\n-\n-help () {\n-\techo -e \"\\nThis is a wrapper for launching TURFF\"\n-\techo -e \"usage: $0 -f env_config_file\\n\";\n-\techo \"Options:\"\n-\techo -e \"-f cross compiler environment configuration file\"\n-\techo -e \"-h show this help menu\"\n-\texit 1;\n-}\n-\n-SUPERVISE=supervise\n-EXEC=/bin/turff/\n-\n-while getopts \":hf:\" opt; do\n-\tcase $opt in\n-\t\tf)\n-\t\t\tenv_conf_file=$OPTARG\n-\t\t\t;;\n-\t\th)\n-\t\t\thelp\n-\t\t\texit 1\n-\t\t\t;;\n-\t\t\\?)\n-\t\t\techo \"Invalid option: -$OPTARG\"\n-\t\t\texit 1\n-\t\t\t;;\n-\t\t:)\n-\t\t\techo \"Option -$OPTARG requires an argument.\"\n-\t\t\texit 1\n-\t\t\t;;\n-\tesac\n-done\n-\n-if [ -n \"$env_conf_file\" ]; then\n-\tsource $env_conf_file\n-fi\n-\n-if [ $? -eq 0 ] ; then\n-\t$SUPERVISE $EXEC\n-else\n-\techo \"Error setting up cross compiler environment\"\n-fi\ndiff --git a/utils.c b/utils.c\ndeleted file mode 100755\nindex 11ff951..0000000\n--- a/utils.c\n+++ /dev/null\n@@ -1,351 +0,0 @@\n-/*\n- * Copyright (C) 2016 Intel Corporation\n- *\n- * Author: Todor Minchev <todor.minchev@linux.intel.com>\n- *\n- * This program is free software; you can redistribute it and/or modify it\n- * under the terms and conditions of the GNU General Public License,\n- * version 2, or (at your option) any later version, as published by\n- * the Free Software Foundation.\n- *\n- * This program is distributed in the hope it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n- * more details.\n- */\n-\n-#include \"globals.h\"\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <errno.h>\n-#include <unistd.h>\n-#if defined(_WIN32)\n-#include <winsock2.h>\n-#include <wspiapi.h>\n-#else\n-#include <netdb.h>\n-#include <sys/select.h>\n-#endif\n-#include \"utils.h\"\n-\n-\n-/* TODO - add error checks and return error codes*/\n-int redirect_sockets(int in_sock, int out_sock) {\n-  int ready, received = 0;\n-  fd_set read_fd_set ;\n-  int size = BUFSIZ;\n-  void *buf = calloc(1, size);\n-\n-  do {\n-    FD_ZERO(&read_fd_set);\n-    FD_SET(in_sock, &read_fd_set);\n-    ready = select(in_sock+1, &read_fd_set, NULL, NULL, NULL);\n-  } while (ready==-1 && errno == EINTR);\n-\n-  if (ready > 0 ){\n-    if (FD_ISSET(in_sock, &read_fd_set)) {\n-      while (size > 0) {\n-        received = recv(in_sock, buf, size, 0);\n-        if (received < 0 ){\n-          ERR(\"Error : %s\\n\", strerror(errno));\n-        } else if (received == 0) {\n-          break ;\n-        } else {\n-          size -= received;\n-          if (strstr((char*) buf, TURFF_EOM)) {\n-            send_data(out_sock, (const void *) buf,received);\n-            break;\n-          } else {\n-            send_data(out_sock, (const void *) buf,received);\n-          }\n-\n-        }\n-      }\n-    }\n-  } else if (ready < 0){\n-    free(buf);\n-    ERR(\"Select error\\n\");\n-  }\n-  free(buf);\n-  return 0;\n-}\n-\n-/* TODO - add error checks and return error codes*/\n-int send_data(int sock_fd, const void *buf, size_t size) {\n-  int n, ready, sent = 0;\n-  fd_set write_fd_set ;\n-  struct timeval timeout;\n-\n-  timeout.tv_sec = (long) 0.3;\n-  timeout.tv_usec = 0;\n-\n-  FD_ZERO(&write_fd_set);\n-  FD_SET(sock_fd, &write_fd_set);\n-  n = sock_fd +1;\n-\n-  ready = select(n, NULL, &write_fd_set, NULL, &timeout);\n-\n-  if (ready) {\n-    while (size > 0) {\n-      sent = send(sock_fd, buf, size, 0);\n-      if (sent == -1){\n-        ERR(\"Unable to send data. Error: [%d] %s\", errno, strerror(errno));\n-      }\n-      else {\n-        size -= sent;\n-#ifdef DBG\n-        DEBUG(\"Bytes sent: %d. Bytes remaining: %zu\\n\", sent, size);\n-#endif\n-      }\n-    }\n-  } else if (ready == -1){\n-      ERR(\"Select timeout\\n\");\n-  }\n-  return 0;\n-}\n-\n-/* TODO - add error checks and return error codes*/\n-int receive_data(int sock_fd, void *buf, size_t size, int is_ceed, int *done) {\n-  int ready, received = 0;\n-  fd_set read_fd_set ;\n-\n-  do {\n-    FD_ZERO(&read_fd_set);\n-    FD_SET(sock_fd, &read_fd_set);\n-    ready = select(sock_fd+1, &read_fd_set, NULL, NULL, NULL);\n-  } while (ready==-1 && errno == EINTR);\n-\n-  if (ready > 0 ){\n-    if (FD_ISSET(sock_fd, &read_fd_set)) {\n-      while (size > 0) {\n-        received = recv(sock_fd, buf, size, 0);\n-        if (received < 0 ){\n-          ERR(\"Error : %s\\n\", strerror(errno));\n-        } else if (received == 0) {\n-          if (is_ceed)\n-            *done = 1;\n-          break ;\n-        } else {\n-          size -= received;\n-          if (strstr((char*) buf, TURFF_EOM) && done != NULL ) {\n-            memset(strstr((char*) buf, TURFF_EOM), 0, sizeof(TURFF_EOM));\n-            printf(\"%s\", (char*) buf);\n-            *done = 1;\n-            break;\n-          } else if (is_ceed) {\n-            printf(\"%s\", (char*) buf);\n-          }\n-          buf = (char*)buf + received;\n-#ifdef DBG\n-          DEBUG(\"\\nBytes read: %d Bytes remaining: %zu\\n\", received, size);\n-#endif\n-        }\n-      }\n-    }\n-  } else if (ready < 0){\n-    ERR(\"Select error : %s\\n\", strerror(errno));\n-  }\n-\n-  return 0;\n-}\n-\n-void send_chunk(int sock_fd, msg_chunk *chunk) {\n-  msg_chunk *head;\n-  head = chunk ;\n-  while (chunk != NULL) {\n-    send_data(sock_fd, chunk, sizeof(msg_chunk));\n-#ifdef DBG\n-    DEBUG(\"Chunk op_code: %d , Chunk payload: %s\\n\", (*chunk).op_code,\n-      (*chunk).arg);\n-#endif\n-    chunk = chunk->next ;\n-  }\n-\n-  /* done with this parameter - free all chunks*/\n-  while (head != NULL) {\n-    chunk = head;\n-    head = chunk->next;\n-    free(chunk);\n-  }\n-}\n-\n-int receive_chunk(int sock_fd, msg_chunk *chunk) {\n-  return receive_data(sock_fd, chunk, sizeof(msg_chunk), 0, NULL);\n-}\n-\n-void send_args(int sock_fd, char *params[]) {\n-  int  i, j, num_chunks;\n-  msg_chunk *new_chunk, *tail_chunk, *head_chunk ;\n-\n-  /* send all params in chunks of 20 chars*/\n-  for(i = 0; i < KEY_ARR_SZ; i++) {\n-    if (params[i] != NULL) {\n-      new_chunk = calloc(1, sizeof(msg_chunk));\n-      head_chunk = new_chunk;\n-      tail_chunk = new_chunk;\n-      num_chunks =  ceil((double) strlen(params[i]) /\n-        (sizeof((*new_chunk).arg)-1));\n-\n-      for(j = 0; j < num_chunks; j++) {\n-        (*tail_chunk).op_code = i;\n-        if (j != 0) {\n-          strncpy((*tail_chunk).arg, params[i]+(j*sizeof((*tail_chunk).arg)-j),\n-            sizeof((*tail_chunk).arg)-1);\n-        } else {\n-          strncpy((*tail_chunk).arg, params[i], sizeof((*tail_chunk).arg)-1);\n-        }\n-\n-        /* was this the last chunk*/\n-        if ((j+1) != num_chunks) {\n-          new_chunk = calloc(1, sizeof(msg_chunk));\n-          tail_chunk->next = new_chunk;\n-          tail_chunk = new_chunk;\n-        }\n-      }\n-      /* this param is ready - send head chunk*/\n-      send_chunk(sock_fd, head_chunk);\n-    }\n-  }\n-\n-  /* we are done with all params. Send EOM as an individual chunk*/\n-  new_chunk = calloc(1, sizeof(msg_chunk));\n-  (*new_chunk).op_code = -1;\n-  strcpy((*new_chunk).arg, MSG_TERM);\n-  send_chunk(sock_fd, new_chunk);\n-}\n-\n-/* receive all params in chunks of 20 chars including terminator*/\n-void receive_args(int sock_fd, char *params[]) {\n-  msg_chunk param_chunk;\n-  char *tmp;\n-  do {\n-    memset(&param_chunk, 0, sizeof(msg_chunk));\n-    receive_chunk(sock_fd, &param_chunk);\n-\n-#ifdef DBG\n-    DEBUG(\"Chunk op_code: %d , Chunk payload: %s\\n\", param_chunk.op_code,\n-      &param_chunk.arg);\n-#endif\n-    if (param_chunk.op_code != -1) {\n-      if (params[param_chunk.op_code] == NULL) {\n-        tmp = calloc(1, sizeof(param_chunk.arg));\n-      } else {\n-        tmp = realloc(params[param_chunk.op_code], strlen(params[param_chunk.op_code])+\n-          sizeof(param_chunk.arg));\n-      }\n-\n-      params[param_chunk.op_code] = tmp;\n-      strcpy(params[param_chunk.op_code] + strlen(params[param_chunk.op_code]),\n-        param_chunk.arg);\n-#ifdef DBG\n-      DEBUG(\"Chunk op_code: %d , parameter: %s\\n\", param_chunk.op_code,\n-        params[param_chunk.op_code]);\n-#endif\n-    }\n-  }while(param_chunk.op_code != -1); /* not EOM chunk*/\n-}\n-\n-struct addrinfo* connect_to_socket(char *ip_in, char *port_in, int* sock_fd_out) {\n-  int sock_fd, result;\n-  struct addrinfo criteria, *srv_addr, *addr_p;\n-\n-#if defined(_WIN32)\n-  WSADATA wsa_data;\n-  int res = WSAStartup(MAKEWORD(2, 2), &wsa_data);\n-  if (res != 0) {\n-    ERR(\"WSAStartup failed: %d\\n\", res);\n-  }\n-#endif\n-\n-  /* connect to agent */\n-  memset(&criteria, 0, sizeof(criteria));\n-  criteria.ai_family = AF_INET;\n-  criteria.ai_socktype = SOCK_STREAM;\n-  criteria.ai_flags = 0;\n-  criteria.ai_protocol = 0;\n-\n-  result = getaddrinfo(ip_in, port_in, &criteria,&srv_addr);\n-\n-  if(result != 0) {\n-    ERR(\"Could not get address info list : %s\\n\", gai_strerror(result));\n-  }\n-\n-  for(addr_p = srv_addr; addr_p != NULL; addr_p = addr_p->ai_next) {\n-    *sock_fd_out = socket(addr_p->ai_family, addr_p->ai_socktype, addr_p->ai_protocol);\n-\n-    if (*sock_fd_out == -1)\n-\n-      continue;\n-\n-    if (connect(*sock_fd_out, addr_p->ai_addr, addr_p->ai_addrlen) != -1)\n-      break;  /* Connected */\n-\n-    close(*sock_fd_out);\n-  }\n-\n-  return addr_p ;\n-}\n-\n-\n-struct addrinfo* bind_to_socket(char *ip_in, const char *port_in, int* sock_fd_out) {\n-  struct addrinfo criteria, *srv_addr;\n-  struct addrinfo *addr_p;\n-  int result, opt = 1;\n-\n-  memset(&criteria, 0, sizeof(criteria));\n-  criteria.ai_family = AF_INET;\n-  criteria.ai_socktype = SOCK_STREAM;\n-  criteria.ai_flags = AI_PASSIVE;\n-  criteria.ai_protocol = 0;\n-  criteria.ai_canonname = NULL;\n-  criteria.ai_addr = NULL;\n-  criteria.ai_next = NULL;\n-\n-  result = getaddrinfo(NULL, port_in, &criteria, &srv_addr);\n-\n-  if (result != 0) {\n-    ERR(\"Could not get address info list\\n\");\n-  }\n-\n-  for (addr_p = srv_addr; addr_p != NULL; addr_p = addr_p->ai_next) {\n-    *sock_fd_out = socket(addr_p->ai_family, addr_p->ai_socktype, addr_p->ai_protocol);\n-\n-    if (*sock_fd_out == -1)\n-      continue;\n-\n-    if (setsockopt(*sock_fd_out, SOL_SOCKET, SO_REUSEADDR,\n-      (char *)&opt, sizeof(opt)) < 0) {\n-\n-      close(*sock_fd_out);\n-      ERR(\"setsockopt failed\\n\");\n-    }\n-\n-    if (bind(*sock_fd_out, addr_p->ai_addr, addr_p->ai_addrlen) == 0)\n-      break;                  /* Success */\n-\n-      close(*sock_fd_out);\n-  }\n-\n-  freeaddrinfo(srv_addr);\n-  return addr_p;\n-}\n-\n-void copy_params(char *in[], char *out[]) {\n-  int i;\n-  for (i = 0; i< KEY_ARR_SZ; i++){\n-    if (in[i] != NULL) {\n-      asprintf(&out[i],\"%s\",in[i]);\n-    }\n-  }\n-}\n-\n-void free_params(char *params[]) {\n-  int i;\n-  for (i = 0; i< KEY_ARR_SZ; i++){\n-    if (params[i] != NULL) {\n-      free(params[i]);\n-      params[i] = NULL ;\n-    }\n-  }\n-}\ndiff --git a/utils.h b/utils.h\ndeleted file mode 100755\nindex b4cc534..0000000\n--- a/utils.h\n+++ /dev/null\n@@ -1,30 +0,0 @@\n-/*\n- * Copyright (C) 2016 Intel Corporation\n- *\n- * Author: Todor Minchev <todor.minchev@linux.intel.com>\n- *\n- * This program is free software; you can redistribute it and/or modify it\n- * under the terms and conditions of the GNU General Public License,\n- * version 2, or (at your option) any later version, as published by\n- * the Free Software Foundation.\n- *\n- * This program is distributed in the hope it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n- * more details.\n- */\n-\n-#ifndef UTILS_H\n-#define UTILS_H\n-\n-int send_data(int sock_fd, const void *buf, size_t size);\n-int receive_data(int sock_fd, void *buf, size_t size, int is_ceed, int *done);\n-void send_args(int sock_fd, char *params[]);\n-void receive_args(int sock_fd, char *params[]);\n-struct addrinfo* connect_to_socket(char *ip_in, char *port_in, int* sock_fd_out);\n-struct addrinfo* bind_to_socket(char *ip_in, const char *port_in, int* sock_fd_out);\n-int redirect_sockets(int in_sock, int out_sock);\n-void free_params(char *params[]);\n-void copy_params(char *in[], char *out[]);\n-\n-#endif\n-- \n2.25.1\n\n\n\n^ permalink raw reply related\t[flat|nested] 2+ messages in thread",
    "* Re: [yocto] [CROPS][PATCH] crops: Archive crops repository\n  2023-01-12 13:26 [CROPS][PATCH] crops: Archive crops repository Eilís 'pidge' Ní Fhlannagáin\n@ 2023-10-19 21:42 ` Tim Orling\n  0 siblings, 0 replies; 2+ messages in thread\nFrom: Tim Orling @ 2023-10-19 21:42 UTC (permalink / raw)\n  To: Eilís 'pidge' Ní Fhlannagáin; +Cc: yocto\n\n[-- Attachment #1: Type: text/plain, Size: 172273 bytes --]\n\nMerged. Thank you.\n\nOn Thu, Jan 12, 2023 at 5:27 AM Eilís 'pidge' Ní Fhlannagáin <\npidge@baylibre.com> wrote:\n\n> From: Eilís Ní Fhlannagáin <pidge@baylibre.com>\n>\n> This repository is depreciated and is no longer maintained so we should\n> archive it and make note that development for crops is currently at\n> https://github.com/crops\n>\n> Signed-off-by: Eilís Ní Fhlannagáin <pidge@baylibre.com>\n> ---\n>  .dockerignore                          |   1 -\n>  .gitignore                             |   9 -\n>  .travis.yml                            |  44 ----\n>  LICENSE                                | 339 ------------------------\n>  Makefile                               |  15 --\n>  README.md                              | 154 +----------\n>  TODO                                   |  10 -\n>  ceed/Makefile                          |  42 ---\n>  ceed/ceed.c                            |  70 -----\n>  ceed/ceed_api.c                        | 157 -----------\n>  ceed/ceed_api.h                        |  22 --\n>  codi/Makefile                          |  19 --\n>  codi/codi.c                            | 126 ---------\n>  codi/codi_api.c                        | 134 ----------\n>  codi/codi_api.h                        |  25 --\n>  codi/codi_db.c                         | 137 ----------\n>  codi/codi_db.h                         |  28 --\n>  codi/codi_launcher.c                   | 146 ----------\n>  codi/codi_launcher.h                   |  58 ----\n>  codi/codi_list.c                       | 100 -------\n>  codi/codi_list.h                       |  33 ---\n>  confs/ostro/ostro.conf                 |  16 --\n>  confs/ostro/ostro.layers               |   0\n>  dockerfiles/Dockerfile.ceed.deps       |  16 --\n>  dockerfiles/Dockerfile.ceed.linux      |  19 --\n>  dockerfiles/Dockerfile.ceed.win        |  19 --\n>  dockerfiles/Dockerfile.codi            |  34 ---\n>  dockerfiles/Dockerfile.codi.deps       |  31 ---\n>  dockerfiles/Dockerfile.ostro           |  24 --\n>  dockerfiles/Dockerfile.ostro.deps      |  33 ---\n>  dockerfiles/Dockerfile.toolchain       |  49 ----\n>  dockerfiles/Dockerfile.toolchain.deps  |  18 --\n>  dockerfiles/Dockerfile.zephyr          |  59 -----\n>  dockerfiles/Dockerfile.zephyr.deps     |  24 --\n>  globals.c                              |  47 ----\n>  globals.h                              |  69 -----\n>  helpers/runbitbake.py                  | 148 -----------\n>  helpers/startOstroScript.sh            |  42 ---\n>  installers/ostro-installer.sh          | 108 --------\n>  installers/zephyr-installer.sh         | 225 ----------------\n>  scripts/bitbake.ostro                  |  12 -\n>  scripts/build_ceed                     |  11 -\n>  scripts/build_containers               |  73 -----\n>  scripts/build_containers.ostro         |  35 ---\n>  scripts/gdb.zephyr                     |   8 -\n>  scripts/make.zephyr                    |  21 --\n>  scripts/run_containers                 |  59 -----\n>  scripts/stop_containers                |  33 ---\n>  tests.py                               |  32 ---\n>  tests/functional/test_ceed_basic.py    | 104 --------\n>  tests/functional/test_ceed_commands.py | 121 ---------\n>  tests/functional/test_zephyr_build.py  | 101 -------\n>  tests/functional/utils/__init__.py     |   0\n>  tests/functional/utils/ceedutil.py     |  20 --\n>  tests/unit/test_basic.py               |  19 --\n>  tests/unit/test_runbitbake.py          | 130 ---------\n>  turff/Makefile                         |  19 --\n>  turff/turff.c                          | 128 ---------\n>  turff/turff_api.c                      | 255 ------------------\n>  turff/turff_api.h                      |  24 --\n>  turff/turff_launcher                   |  43 ---\n>  utils.c                                | 351 -------------------------\n>  utils.h                                |  30 ---\n>  63 files changed, 5 insertions(+), 4274 deletions(-)\n>  delete mode 100644 .dockerignore\n>  delete mode 100644 .gitignore\n>  delete mode 100644 .travis.yml\n>  delete mode 100644 LICENSE\n>  delete mode 100755 Makefile\n>  mode change 100755 => 100644 README.md\n>  delete mode 100755 TODO\n>  delete mode 100755 ceed/Makefile\n>  delete mode 100755 ceed/ceed.c\n>  delete mode 100755 ceed/ceed_api.c\n>  delete mode 100755 ceed/ceed_api.h\n>  delete mode 100644 codi/Makefile\n>  delete mode 100644 codi/codi.c\n>  delete mode 100644 codi/codi_api.c\n>  delete mode 100644 codi/codi_api.h\n>  delete mode 100644 codi/codi_db.c\n>  delete mode 100644 codi/codi_db.h\n>  delete mode 100644 codi/codi_launcher.c\n>  delete mode 100644 codi/codi_launcher.h\n>  delete mode 100644 codi/codi_list.c\n>  delete mode 100644 codi/codi_list.h\n>  delete mode 100644 confs/ostro/ostro.conf\n>  delete mode 100644 confs/ostro/ostro.layers\n>  delete mode 100644 dockerfiles/Dockerfile.ceed.deps\n>  delete mode 100644 dockerfiles/Dockerfile.ceed.linux\n>  delete mode 100644 dockerfiles/Dockerfile.ceed.win\n>  delete mode 100644 dockerfiles/Dockerfile.codi\n>  delete mode 100644 dockerfiles/Dockerfile.codi.deps\n>  delete mode 100644 dockerfiles/Dockerfile.ostro\n>  delete mode 100644 dockerfiles/Dockerfile.ostro.deps\n>  delete mode 100644 dockerfiles/Dockerfile.toolchain\n>  delete mode 100644 dockerfiles/Dockerfile.toolchain.deps\n>  delete mode 100644 dockerfiles/Dockerfile.zephyr\n>  delete mode 100644 dockerfiles/Dockerfile.zephyr.deps\n>  delete mode 100755 globals.c\n>  delete mode 100755 globals.h\n>  delete mode 100644 helpers/runbitbake.py\n>  delete mode 100644 helpers/startOstroScript.sh\n>  delete mode 100644 installers/ostro-installer.sh\n>  delete mode 100755 installers/zephyr-installer.sh\n>  delete mode 100755 scripts/bitbake.ostro\n>  delete mode 100755 scripts/build_ceed\n>  delete mode 100755 scripts/build_containers\n>  delete mode 100755 scripts/build_containers.ostro\n>  delete mode 100644 scripts/gdb.zephyr\n>  delete mode 100755 scripts/make.zephyr\n>  delete mode 100755 scripts/run_containers\n>  delete mode 100755 scripts/stop_containers\n>  delete mode 100644 tests.py\n>  delete mode 100644 tests/functional/test_ceed_basic.py\n>  delete mode 100644 tests/functional/test_ceed_commands.py\n>  delete mode 100644 tests/functional/test_zephyr_build.py\n>  delete mode 100644 tests/functional/utils/__init__.py\n>  delete mode 100644 tests/functional/utils/ceedutil.py\n>  delete mode 100644 tests/unit/test_basic.py\n>  delete mode 100644 tests/unit/test_runbitbake.py\n>  delete mode 100755 turff/Makefile\n>  delete mode 100755 turff/turff.c\n>  delete mode 100755 turff/turff_api.c\n>  delete mode 100755 turff/turff_api.h\n>  delete mode 100755 turff/turff_launcher\n>  delete mode 100755 utils.c\n>  delete mode 100755 utils.h\n>\n> diff --git a/.dockerignore b/.dockerignore\n> deleted file mode 100644\n> index 191381e..0000000\n> --- a/.dockerignore\n> +++ /dev/null\n> @@ -1 +0,0 @@\n> -.git\n> \\ No newline at end of file\n> diff --git a/.gitignore b/.gitignore\n> deleted file mode 100644\n> index bf35249..0000000\n> --- a/.gitignore\n> +++ /dev/null\n> @@ -1,9 +0,0 @@\n> -*~\n> -*.o\n> -ceed/ceed\n> -codi/codi\n> -turff/turff\n> -outdir\n> -*.pyc\n> -*#\n> -.#*\n> diff --git a/.travis.yml b/.travis.yml\n> deleted file mode 100644\n> index 72bda2e..0000000\n> --- a/.travis.yml\n> +++ /dev/null\n> @@ -1,44 +0,0 @@\n> -language: python\n> -python:\n> -  - \"2.7\"\n> -\n> -\n> -sudo: required\n> -services:\n> -  - docker\n> -\n> -services:\n> -    - docker\n> -\n> -env:\n> -    global:\n> -        - DOCKER_VERSION=1.10.1-0~trusty\n> -\n> -\n> -compiler:\n> -  - gcc\n> -  - clang\n> -\n> -before_install:\n> -  # list docker-engine versions\n> -  - apt-cache madison docker-engine\n> -\n> -  # upgrade docker-engine to specific version\n> -  - sudo apt-get -o Dpkg::Options::=\"--force-confnew\" install -y\n> docker-engine=${DOCKER_VERSION}\n> -\n> -\n> -script:\n> -  - ./scripts/build_ceed\n> -  - docker version\n> -  - ./scripts/build_containers\n> -  - docker images | grep codi | grep -q test\n> -  - docker images | grep toolchain | grep -q test\n> -  - docker images | grep zephyr | grep -q test\n> -  - ./scripts/run_containers\n> -  - python tests.py\n> -\n> -notifications:\n> -  email:\n> -    recipients:\n> -    on_success: change\n> -    on_failure: always\n> diff --git a/LICENSE b/LICENSE\n> deleted file mode 100644\n> index d159169..0000000\n> --- a/LICENSE\n> +++ /dev/null\n> @@ -1,339 +0,0 @@\n> -                    GNU GENERAL PUBLIC LICENSE\n> -                       Version 2, June 1991\n> -\n> - Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n> - 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n> - Everyone is permitted to copy and distribute verbatim copies\n> - of this license document, but changing it is not allowed.\n> -\n> -                            Preamble\n> -\n> -  The licenses for most software are designed to take away your\n> -freedom to share and change it.  By contrast, the GNU General Public\n> -License is intended to guarantee your freedom to share and change free\n> -software--to make sure the software is free for all its users.  This\n> -General Public License applies to most of the Free Software\n> -Foundation's software and to any other program whose authors commit to\n> -using it.  (Some other Free Software Foundation software is covered by\n> -the GNU Lesser General Public License instead.)  You can apply it to\n> -your programs, too.\n> -\n> -  When we speak of free software, we are referring to freedom, not\n> -price.  Our General Public Licenses are designed to make sure that you\n> -have the freedom to distribute copies of free software (and charge for\n> -this service if you wish), that you receive source code or can get it\n> -if you want it, that you can change the software or use pieces of it\n> -in new free programs; and that you know you can do these things.\n> -\n> -  To protect your rights, we need to make restrictions that forbid\n> -anyone to deny you these rights or to ask you to surrender the rights.\n> -These restrictions translate to certain responsibilities for you if you\n> -distribute copies of the software, or if you modify it.\n> -\n> -  For example, if you distribute copies of such a program, whether\n> -gratis or for a fee, you must give the recipients all the rights that\n> -you have.  You must make sure that they, too, receive or can get the\n> -source code.  And you must show them these terms so they know their\n> -rights.\n> -\n> -  We protect your rights with two steps: (1) copyright the software, and\n> -(2) offer you this license which gives you legal permission to copy,\n> -distribute and/or modify the software.\n> -\n> -  Also, for each author's protection and ours, we want to make certain\n> -that everyone understands that there is no warranty for this free\n> -software.  If the software is modified by someone else and passed on, we\n> -want its recipients to know that what they have is not the original, so\n> -that any problems introduced by others will not reflect on the original\n> -authors' reputations.\n> -\n> -  Finally, any free program is threatened constantly by software\n> -patents.  We wish to avoid the danger that redistributors of a free\n> -program will individually obtain patent licenses, in effect making the\n> -program proprietary.  To prevent this, we have made it clear that any\n> -patent must be licensed for everyone's free use or not licensed at all.\n> -\n> -  The precise terms and conditions for copying, distribution and\n> -modification follow.\n> -\n> -                    GNU GENERAL PUBLIC LICENSE\n> -   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n> -\n> -  0. This License applies to any program or other work which contains\n> -a notice placed by the copyright holder saying it may be distributed\n> -under the terms of this General Public License.  The \"Program\", below,\n> -refers to any such program or work, and a \"work based on the Program\"\n> -means either the Program or any derivative work under copyright law:\n> -that is to say, a work containing the Program or a portion of it,\n> -either verbatim or with modifications and/or translated into another\n> -language.  (Hereinafter, translation is included without limitation in\n> -the term \"modification\".)  Each licensee is addressed as \"you\".\n> -\n> -Activities other than copying, distribution and modification are not\n> -covered by this License; they are outside its scope.  The act of\n> -running the Program is not restricted, and the output from the Program\n> -is covered only if its contents constitute a work based on the\n> -Program (independent of having been made by running the Program).\n> -Whether that is true depends on what the Program does.\n> -\n> -  1. You may copy and distribute verbatim copies of the Program's\n> -source code as you receive it, in any medium, provided that you\n> -conspicuously and appropriately publish on each copy an appropriate\n> -copyright notice and disclaimer of warranty; keep intact all the\n> -notices that refer to this License and to the absence of any warranty;\n> -and give any other recipients of the Program a copy of this License\n> -along with the Program.\n> -\n> -You may charge a fee for the physical act of transferring a copy, and\n> -you may at your option offer warranty protection in exchange for a fee.\n> -\n> -  2. You may modify your copy or copies of the Program or any portion\n> -of it, thus forming a work based on the Program, and copy and\n> -distribute such modifications or work under the terms of Section 1\n> -above, provided that you also meet all of these conditions:\n> -\n> -    a) You must cause the modified files to carry prominent notices\n> -    stating that you changed the files and the date of any change.\n> -\n> -    b) You must cause any work that you distribute or publish, that in\n> -    whole or in part contains or is derived from the Program or any\n> -    part thereof, to be licensed as a whole at no charge to all third\n> -    parties under the terms of this License.\n> -\n> -    c) If the modified program normally reads commands interactively\n> -    when run, you must cause it, when started running for such\n> -    interactive use in the most ordinary way, to print or display an\n> -    announcement including an appropriate copyright notice and a\n> -    notice that there is no warranty (or else, saying that you provide\n> -    a warranty) and that users may redistribute the program under\n> -    these conditions, and telling the user how to view a copy of this\n> -    License.  (Exception: if the Program itself is interactive but\n> -    does not normally print such an announcement, your work based on\n> -    the Program is not required to print an announcement.)\n> -\n> -These requirements apply to the modified work as a whole.  If\n> -identifiable sections of that work are not derived from the Program,\n> -and can be reasonably considered independent and separate works in\n> -themselves, then this License, and its terms, do not apply to those\n> -sections when you distribute them as separate works.  But when you\n> -distribute the same sections as part of a whole which is a work based\n> -on the Program, the distribution of the whole must be on the terms of\n> -this License, whose permissions for other licensees extend to the\n> -entire whole, and thus to each and every part regardless of who wrote it.\n> -\n> -Thus, it is not the intent of this section to claim rights or contest\n> -your rights to work written entirely by you; rather, the intent is to\n> -exercise the right to control the distribution of derivative or\n> -collective works based on the Program.\n> -\n> -In addition, mere aggregation of another work not based on the Program\n> -with the Program (or with a work based on the Program) on a volume of\n> -a storage or distribution medium does not bring the other work under\n> -the scope of this License.\n> -\n> -  3. You may copy and distribute the Program (or a work based on it,\n> -under Section 2) in object code or executable form under the terms of\n> -Sections 1 and 2 above provided that you also do one of the following:\n> -\n> -    a) Accompany it with the complete corresponding machine-readable\n> -    source code, which must be distributed under the terms of Sections\n> -    1 and 2 above on a medium customarily used for software interchange;\n> or,\n> -\n> -    b) Accompany it with a written offer, valid for at least three\n> -    years, to give any third party, for a charge no more than your\n> -    cost of physically performing source distribution, a complete\n> -    machine-readable copy of the corresponding source code, to be\n> -    distributed under the terms of Sections 1 and 2 above on a medium\n> -    customarily used for software interchange; or,\n> -\n> -    c) Accompany it with the information you received as to the offer\n> -    to distribute corresponding source code.  (This alternative is\n> -    allowed only for noncommercial distribution and only if you\n> -    received the program in object code or executable form with such\n> -    an offer, in accord with Subsection b above.)\n> -\n> -The source code for a work means the preferred form of the work for\n> -making modifications to it.  For an executable work, complete source\n> -code means all the source code for all modules it contains, plus any\n> -associated interface definition files, plus the scripts used to\n> -control compilation and installation of the executable.  However, as a\n> -special exception, the source code distributed need not include\n> -anything that is normally distributed (in either source or binary\n> -form) with the major components (compiler, kernel, and so on) of the\n> -operating system on which the executable runs, unless that component\n> -itself accompanies the executable.\n> -\n> -If distribution of executable or object code is made by offering\n> -access to copy from a designated place, then offering equivalent\n> -access to copy the source code from the same place counts as\n> -distribution of the source code, even though third parties are not\n> -compelled to copy the source along with the object code.\n> -\n> -  4. You may not copy, modify, sublicense, or distribute the Program\n> -except as expressly provided under this License.  Any attempt\n> -otherwise to copy, modify, sublicense or distribute the Program is\n> -void, and will automatically terminate your rights under this License.\n> -However, parties who have received copies, or rights, from you under\n> -this License will not have their licenses terminated so long as such\n> -parties remain in full compliance.\n> -\n> -  5. You are not required to accept this License, since you have not\n> -signed it.  However, nothing else grants you permission to modify or\n> -distribute the Program or its derivative works.  These actions are\n> -prohibited by law if you do not accept this License.  Therefore, by\n> -modifying or distributing the Program (or any work based on the\n> -Program), you indicate your acceptance of this License to do so, and\n> -all its terms and conditions for copying, distributing or modifying\n> -the Program or works based on it.\n> -\n> -  6. Each time you redistribute the Program (or any work based on the\n> -Program), the recipient automatically receives a license from the\n> -original licensor to copy, distribute or modify the Program subject to\n> -these terms and conditions.  You may not impose any further\n> -restrictions on the recipients' exercise of the rights granted herein.\n> -You are not responsible for enforcing compliance by third parties to\n> -this License.\n> -\n> -  7. If, as a consequence of a court judgment or allegation of patent\n> -infringement or for any other reason (not limited to patent issues),\n> -conditions are imposed on you (whether by court order, agreement or\n> -otherwise) that contradict the conditions of this License, they do not\n> -excuse you from the conditions of this License.  If you cannot\n> -distribute so as to satisfy simultaneously your obligations under this\n> -License and any other pertinent obligations, then as a consequence you\n> -may not distribute the Program at all.  For example, if a patent\n> -license would not permit royalty-free redistribution of the Program by\n> -all those who receive copies directly or indirectly through you, then\n> -the only way you could satisfy both it and this License would be to\n> -refrain entirely from distribution of the Program.\n> -\n> -If any portion of this section is held invalid or unenforceable under\n> -any particular circumstance, the balance of the section is intended to\n> -apply and the section as a whole is intended to apply in other\n> -circumstances.\n> -\n> -It is not the purpose of this section to induce you to infringe any\n> -patents or other property right claims or to contest validity of any\n> -such claims; this section has the sole purpose of protecting the\n> -integrity of the free software distribution system, which is\n> -implemented by public license practices.  Many people have made\n> -generous contributions to the wide range of software distributed\n> -through that system in reliance on consistent application of that\n> -system; it is up to the author/donor to decide if he or she is willing\n> -to distribute software through any other system and a licensee cannot\n> -impose that choice.\n> -\n> -This section is intended to make thoroughly clear what is believed to\n> -be a consequence of the rest of this License.\n> -\n> -  8. If the distribution and/or use of the Program is restricted in\n> -certain countries either by patents or by copyrighted interfaces, the\n> -original copyright holder who places the Program under this License\n> -may add an explicit geographical distribution limitation excluding\n> -those countries, so that distribution is permitted only in or among\n> -countries not thus excluded.  In such case, this License incorporates\n> -the limitation as if written in the body of this License.\n> -\n> -  9. The Free Software Foundation may publish revised and/or new versions\n> -of the General Public License from time to time.  Such new versions will\n> -be similar in spirit to the present version, but may differ in detail to\n> -address new problems or concerns.\n> -\n> -Each version is given a distinguishing version number.  If the Program\n> -specifies a version number of this License which applies to it and \"any\n> -later version\", you have the option of following the terms and conditions\n> -either of that version or of any later version published by the Free\n> -Software Foundation.  If the Program does not specify a version number of\n> -this License, you may choose any version ever published by the Free\n> Software\n> -Foundation.\n> -\n> -  10. If you wish to incorporate parts of the Program into other free\n> -programs whose distribution conditions are different, write to the author\n> -to ask for permission.  For software which is copyrighted by the Free\n> -Software Foundation, write to the Free Software Foundation; we sometimes\n> -make exceptions for this.  Our decision will be guided by the two goals\n> -of preserving the free status of all derivatives of our free software and\n> -of promoting the sharing and reuse of software generally.\n> -\n> -                            NO WARRANTY\n> -\n> -  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\n> -FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\n> -OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\n> -PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\n> -OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n> -MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\n> -TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\n> -PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\n> -REPAIR OR CORRECTION.\n> -\n> -  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN\n> WRITING\n> -WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\n> -REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\n> -INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES\n> ARISING\n> -OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\n> -TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\n> -YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\n> -PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\n> -POSSIBILITY OF SUCH DAMAGES.\n> -\n> -                     END OF TERMS AND CONDITIONS\n> -\n> -            How to Apply These Terms to Your New Programs\n> -\n> -  If you develop a new program, and you want it to be of the greatest\n> -possible use to the public, the best way to achieve this is to make it\n> -free software which everyone can redistribute and change under these\n> terms.\n> -\n> -  To do so, attach the following notices to the program.  It is safest\n> -to attach them to the start of each source file to most effectively\n> -convey the exclusion of warranty; and each file should have at least\n> -the \"copyright\" line and a pointer to where the full notice is found.\n> -\n> -    <one line to give the program's name and a brief idea of what it\n> does.>\n> -    Copyright (C) <year>  <name of author>\n> -\n> -    This program is free software; you can redistribute it and/or modify\n> -    it under the terms of the GNU General Public License as published by\n> -    the Free Software Foundation; either version 2 of the License, or\n> -    (at your option) any later version.\n> -\n> -    This program is distributed in the hope that it will be useful,\n> -    but WITHOUT ANY WARRANTY; without even the implied warranty of\n> -    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n> -    GNU General Public License for more details.\n> -\n> -    You should have received a copy of the GNU General Public License\n> along\n> -    with this program; if not, write to the Free Software Foundation,\n> Inc.,\n> -    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n> -\n> -Also add information on how to contact you by electronic and paper mail.\n> -\n> -If the program is interactive, make it output a short notice like this\n> -when it starts in an interactive mode:\n> -\n> -    Gnomovision version 69, Copyright (C) year name of author\n> -    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show\n> w'.\n> -    This is free software, and you are welcome to redistribute it\n> -    under certain conditions; type `show c' for details.\n> -\n> -The hypothetical commands `show w' and `show c' should show the\n> appropriate\n> -parts of the General Public License.  Of course, the commands you use may\n> -be called something other than `show w' and `show c'; they could even be\n> -mouse-clicks or menu items--whatever suits your program.\n> -\n> -You should also get your employer (if you work as a programmer) or your\n> -school, if any, to sign a \"copyright disclaimer\" for the program, if\n> -necessary.  Here is a sample; alter the names:\n> -\n> -  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n> -  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n> -\n> -  <signature of Ty Coon>, 1 April 1989\n> -  Ty Coon, President of Vice\n> -\n> -This General Public License does not permit incorporating your program\n> into\n> -proprietary programs.  If your program is a subroutine library, you may\n> -consider it more useful to permit linking proprietary applications with\n> the\n> -library.  If this is what you want to do, use the GNU Lesser General\n> -Public License instead of this License.\n> diff --git a/Makefile b/Makefile\n> deleted file mode 100755\n> index 97dabae..0000000\n> --- a/Makefile\n> +++ /dev/null\n> @@ -1,15 +0,0 @@\n> -SUBDIRS = turff ceed codi\n> -\n> -.PHONY: subdirs $(SUBDIRS)\n> -\n> -all: TARGET = all\n> -\n> -clean: TARGET = clean\n> -\n> -debug: TARGET = debug\n> -\n> -all clean debug: subdirs $(SUBDIRS)\n> -\n> -$(SUBDIRS):\n> -       $(MAKE) -C $@ $(TARGET)\n> -\n> diff --git a/README.md b/README.md\n> old mode 100755\n> new mode 100644\n> index 555f7e2..ddd9cba\n> --- a/README.md\n> +++ b/README.md\n> @@ -1,153 +1,9 @@\n> -## What is CROPS (CROssPlatformS)?\n> +This repository is depreciated and is no longer maintained.\n>\n> -CROPS is an open source, cross-platform development framework that\n> leverages Docker containers to provide an easily managed, extensible\n> environment which allows developers to build binaries for a variety of\n> architectures of Windows, Linux and Mac OS X hosts.\n> +Current CROPS development occurs at:\n>\n> -### CROPS components\n> -* **CEED** - runs on the development host and exposes an API to Integrated\n> -Development Environments (IDEs) or CLI callers\n> -* **TURFF** - runs in a container and services requests from CODI\n> -* **CODI** - COntainer DIspatcher runs in a container and keeps track of\n> all available TURFF instances\n> -in its internal table. CODI also redirects CEED requests to the\n> corresponding TURFF instance\n> +https://github.com/crops\n>\n> -## USING CROPS FOR [ZEPHYR OS](https://www.zephyrproject.org/)\n> DEVELOPMENT\n> +The last functional commit for this repo was:\n>\n> -Please refer to the [GitHub Wiki](https://github.com/todorez/crops/wiki)\n> -\n> -## USING CROPS WITH YOUR OWN TOOLCHAIN\n> -\n> - 1. **Install [Docker (Linux)](https://docs.docker.com/linux/step_one/)\n> or [Docker Toolbox (Windows/Mac)](\n> https://www.docker.com/products/docker-toolbox)**\n> -\n> - 2. **Build CODI dependencies container**\n> -\n> -  Execute the following command from within the dockerfiles directory:\n> -\n> -  ```\n> -  docker build -t crops/codi:deps -f Dockerfile.codi.deps .\n> -  ```\n> - 3. **Build CODI container**\n> -\n> -  Execute the following command from within the dockerfiles directory:\n> -\n> -  ```\n> -  docker build -t crops/codi:version -f Dockerfile.codi ../\n> -  ```\n> -\n> - 4. **Build toolchain dependencies container**\n> -\n> -  Execute the following command from within the dockerfiles directory:\n> -\n> -  ```\n> -  docker build -t crops/toolchain:deps -f Dockerfile.toolchain.deps .\n> -  ```\n> -\n> - 5. **Open the Dockerfile.toolchain file and provide the URL to your\n> toolchain**\n> -\n> -  Example:\n> -\n> -  ```\n> -  ENV TOOLCHAIN_NAME\n> poky-glibc-x86_64-core-image-sato-i586-toolchain-2.0.sh\n> -  ENV TOOLCHAIN_PATH\n> http://downloads.yoctoproject.org/releases/yocto/yocto-2.0/toolchain/x86_64/\n> -  ```\n> -\n> - 6. **Build your toolchain container**\n> -\n> -  ```\n> -  docker build -t crops/toolchain:my_toolchain -f Dockerfile.toolchain ../\n> -  ```\n> -\n> - 7. **Start CODI container**\n> -\n> -  ```\n> -  docker run -d --name codi-test -v\n> /var/run/docker.sock:/var/run/docker.sock --net=host crops/codi:version\n> -  ```\n> -\n> - 8. **Start toolchain container**\n> -\n> -  ```\n> -  mkdir -p $HOME/crops-workspace && docker run -d --name\n> crops-toolchain-my_toolchain -v $HOME/crops-workspace/:/crops/   --env\n> TURFFID=crops-toolchain-my_toolchain --net=host crops/toolchain:my_toolchain\n> -  ```\n> -\n> - 9. **Run the Zephyr installer and answer \"Yes\" when prompted to install\n> CEED. Answer \"No\" to all other questions**\n> -\n> -  ```\n> -  curl -kOs\n> https://raw.githubusercontent.com/todorez/crops/master/installers/zephyr-installer.sh\n> && source   ./zephyr-installer.sh\n> -  ```\n> -\n> - 10. **Place your project in the shared workspace**\n> -\n> -  Example:\n> -  ```\n> -  $HOME/crops-workspace/my_project/\n> -  ```\n> -\n> - 11. **Build your project**\n> -\n> -  Example:\n> -  ```\n> -  $HOME/.crops/ceed/ceed -d crops-toolchain-my_toolchain -g \"make -C\n> /crops/my_project/\"\n> -  ```\n> - 12. **Share your toolchain with other developers by pushing it to Docker\n> Hub**\n> -\n> -  Example:\n> -  ```\n> -  $docker push crops/toolchain:my_toolchain\"\n> -  ```\n> -\n> -## CONTRIBUTING TO CROPS\n> -\n> -#### COMPILE CEED, TURFF AND CODI ON LINUX\n> -\n> -**Required Prerequisites**\n> -\n> -* **libsqlite3-dev** - \"SQLite is a C library that implements an SQL\n> database engine.\"\n> -* **libcurl4-openssl-dev (7.40 or later)** - \"libcurl is an easy-to-use\n> client-side URL transfer library, supporting DICT, FILE, FTP, FTPS, GOPHER,\n> HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP,\n> SMTP, SMTPS, TELNET and TFTP.\"\n> -* **libjansson-dev** - \"Jansson is a C library for encoding, decoding and\n> manipulating JSON data.\"\n> -\n> -\n> -1. **Install Prerequisites On Debian / Ubuntu**\n> -\n> -  ```\n> -  apt-get install libsqlite3-dev libcurl4-openssl-dev libjansson-dev\n> -  ```\n> -\n> -2. **Compile**\n> -\n> -  * GCC\n> -\n> -  ```\n> -  CC=gcc make all\n> -  ```\n> -\n> -  * CLANG\n> -\n> -  ```\n> -  CC=clang make all\n> -  ```\n> -\n> -3. **Debug Compile**\n> -\n> -  * GCC\n> -\n> -  ```\n> -  CC=gcc make debug\n> -  ```\n> -\n> -  * CLANG\n> -\n> -  ```\n> -  CC=clang make debug\n> -  ```\n> -\n> -#### RUNNING A CLANG STATIC ANALYSYS\n> -\n> -1. **Run the static analyzer**\n> -\n> -  ```\n> -  scan-build -V make\n> -  ```\n> -\n> -2. **Point your browser at the following URL to view the static analysis\n> results**\n> -\n> -  ```\n> -  http://127.0.0.1:8181\n> -  ```\n> +\n> https://git.yoctoproject.org/crops/commit/?id=b719d15fe0e17e5ac05c440680ec3706bcd2cab5\n> diff --git a/TODO b/TODO\n> deleted file mode 100755\n> index 6014c97..0000000\n> --- a/TODO\n> +++ /dev/null\n> @@ -1,10 +0,0 @@\n> -* rewrite eclipse plugin for all platforms Windows, Linux, Mac\n> -* create Docker image installers for Windows/Linux/Mac\n> -* create container launchers\n> -* document installation/configuration/usage\n> -* document APIs\n> -* implement bitbake operations\n> -* fix all bugs.. :)\n> -\n> -\n> -\n> diff --git a/ceed/Makefile b/ceed/Makefile\n> deleted file mode 100755\n> index 58205ed..0000000\n> --- a/ceed/Makefile\n> +++ /dev/null\n> @@ -1,42 +0,0 @@\n> -CFLAGS =-g -I. -I../\n> -LDFLAGS =-lm\n> -\n> -ifeq ($(CC),x86_64-w64-mingw32-gcc)\n> -LDFLAGS += -lws2_32\n> -endif\n> -\n> -DEPS = ceed_api.h ../globals.h ../utils.h\n> -OBJ = ceed.o ceed_api.o ../utils.o ../globals.o\n> -\n> -all: ceed\n> -\n> -debug: DFLAGS = -DDBG\n> -debug: clean ceed\n> -\n> -%.o: %.c $(DEPS)\n> -       $(CC) -c -o $@ $< $(CFLAGS) $(DFLAGS)\n> -\n> -ceed: $(OBJ)\n> -       $(CC) -o $@ $^ $(CFLAGS) $(LDFLAGS)\n> -\n> -.PHONY: clean\n> -clean:\n> -       rm -f $(OBJ) ceed *.exe\n> -\n> -windows:\n> -       docker ps -a -q --filter \"name=ceed-windows\" | awk '{print $1}' |\n> xargs -I {} docker rm -f {}\n> -       docker images -q --filter \"label=name=ceed-windows\" | awk '{print\n> $1}' | xargs -I {} docker rmi {}\n> -       cd ../dockerfiles; docker build -t crops/ceed:windows -f\n> Dockerfile.ceed.win ../\n> -       docker run --name=ceed-windows crops/ceed:windows; mkdir -p\n> ../outdir\n> -       docker cp ceed-windows:/usr/local/crops/ceed/ceed\n> ../outdir/ceed.exe\n> -       docker ps -a -q --filter \"name=ceed-windows\" | awk '{print $1}' |\n> xargs -I {} docker rm -f {}\n> -       docker images -q --filter \"label=name=ceed-windows\" | awk '{print\n> $1}' | xargs -I {} docker rmi {}\n> -\n> -linux:\n> -       docker ps -a -q --filter \"name=ceed-linux\" | awk '{print $1}' |\n> xargs -I {} docker rm -f {}\n> -       docker images -q --filter \"label=name=ceed-linux\" | awk '{print\n> $1}' | xargs -I {} docker rmi {}\n> -       cd ../dockerfiles; docker build -t crops/ceed:linux -f\n> Dockerfile.ceed.linux ../\n> -       docker run --name=ceed-linux crops/ceed:linux; mkdir -p ../outdir\n> -       docker cp ceed-linux:/usr/local/crops/ceed/ceed ../outdir/ceed\n> -       docker ps -a -q --filter \"name=ceed-linux\" | awk '{print $1}' |\n> xargs -I {} docker rm -f {}\n> -       docker images -q --filter \"label=name=ceed-linux\" | awk '{print\n> $1}' | xargs -I {} docker rmi {}\n> diff --git a/ceed/ceed.c b/ceed/ceed.c\n> deleted file mode 100755\n> index f0fa0cc..0000000\n> --- a/ceed/ceed.c\n> +++ /dev/null\n> @@ -1,70 +0,0 @@\n> -/*\n> - * Copyright (C) 2016 Intel Corporation\n> - *\n> - * Author: Todor Minchev <todor.minchev@linux.intel.com>\n> - *\n> - * This program is free software; you can redistribute it and/or modify it\n> - * under the terms and conditions of the GNU General Public License,\n> - * version 2, or (at your option) any later version, as published by\n> - * the Free Software Foundation.\n> - *\n> - * This program is distributed in the hope it will be useful, but WITHOUT\n> - * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n> - * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n> for\n> - * more details.\n> - */\n> -\n> -#include <stdlib.h>\n> -#include \"globals.h\"\n> -#include \"ceed_api.h\"\n> -#include \"utils.h\"\n> -\n> -extern char *ceed_ops[];\n> -\n> -int main(int argc, char *argv[]) {\n> -  int i, done, sock_fd;\n> -  char *turff_nodes[KEY_ARR_SZ];\n> -  struct addrinfo *addr_p;\n> -  void *ceed_out;\n> -\n> -  parse_ceed_params(argc, argv);\n> -\n> -  addr_p = connect_to_socket(ceed_ops[KEY('i')], ceed_ops[KEY('s')],\n> &sock_fd);\n> -\n> -  if(addr_p == NULL) {\n> -    ERR(\"Could not connect to CODI\\n\");\n> -  } else {\n> -    INFO(\"Connected to CODI on %s port : %s\\n\",\n> -      ceed_ops[KEY('i')], ceed_ops[KEY('s')]);\n> -  }\n> -\n> -  INFO(\"Host Architecture : %s\\n\", ceed_ops[KEY('a')]);\n> -  send_args(sock_fd, ceed_ops);\n> -\n> -  if(ceed_ops[KEY('l')] == NULL) { /* this was a service request */\n> -    INFO(\" ==========  CEED OUTPUT BEGIN  ==========\\n\");\n> -    ceed_out = calloc(1, BUFSIZ);\n> -    done = 0;\n> -\n> -    while(!done) {\n> -      memset(ceed_out, 0, BUFSIZ);\n> -      receive_data(sock_fd, ceed_out, BUFSIZ, 1, &done);\n> -    }\n> -    free(ceed_out);\n> -\n> -    INFO(\" ==========  CEED OUTPUT END  ==========\\n\");\n> -  } else { /* this was nodes request, receive turff nodes */\n> -    do {\n> -      for(i = 0; i <  KEY_ARR_SZ; i++)\n> -        turff_nodes[i] = NULL;\n> -\n> -      receive_args(sock_fd, turff_nodes);\n> -      if(turff_nodes[KEY('e')] == NULL) {\n> -        INFO(\"TURFF Node ID: %s \\n\", turff_nodes[KEY('d')]);\n> -      }\n> -    }while (turff_nodes[KEY('e')] == NULL);\n> -  }\n> -\n> -  close(sock_fd);\n> -  return 0;\n> -}\n> diff --git a/ceed/ceed_api.c b/ceed/ceed_api.c\n> deleted file mode 100755\n> index 973c050..0000000\n> --- a/ceed/ceed_api.c\n> +++ /dev/null\n> @@ -1,157 +0,0 @@\n> -/*\n> - * Copyright (C) 2016 Intel Corporation\n> - *\n> - * Author: Todor Minchev <todor.minchev@linux.intel.com>\n> - *\n> - * This program is free software; you can redistribute it and/or modify it\n> - * under the terms and conditions of the GNU General Public License,\n> - * version 2, or (at your option) any later version, as published by\n> - * the Free Software Foundation.\n> - *\n> - * This program is distributed in the hope it will be useful, but WITHOUT\n> - * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n> - * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n> for\n> - * more details.\n> - */\n> -\n> -#include \"globals.h\"\n> -#include <stdio.h>\n> -#include <stdlib.h>\n> -#include <unistd.h>\n> -#include <ctype.h>\n> -\n> -char *ceed_ops[KEY_ARR_SZ];\n> -\n> -void print_ceed_usage(int argc, char *argv[]) {\n> -\n> -  printf(\"Usage: %s -p prj -i 192.168.99.100 -s 10000 -b\\n\", argv[0]);\n> -  printf(\"     -i CODI ip address [default: 127.0.0.1 (linux) or\n> 192.168.99.100 (win/mac)]\\n\");\n> -  printf(\"     -s CODI listening port [default: 10000]\\n\");\n> -  printf(\"     -l list available build containers\\n\");\n> -  printf(\"     -d container_id. Send command to container_id\\n\");\n> -  printf(\"     -p prj_name [required]\\n\");\n> -  printf(\"     -b build project [NOTE: -b and -c are mutually\n> exclusive]\\n\");\n> -  printf(\"     -c clean project [NOTE: -c and -b are mutually\n> exclusive]\\n\");\n> -  printf(\"     -t autotools project [NOTE: -t and -k and -m are mutually\n> exclusive]\\n\");\n> -  printf(\"     -k cmake project [NOTE: -k and -t and -m are mutually\n> exclusive]\\n\");\n> -  printf(\"     -m target make makefile_target [NOTE: -m and -t and -k are\n> mutually exclusive]\\n\");\n> -  printf(\"     -g gen_cmd execute generic command\\n\");\n> -  printf(\"     -r args generic command arguments\\n\");\n> -  printf(\"     -e env environment variables\\n\");\n> -  printf(\"     -h print this help menu\\n\");\n> -  printf(\"     -v show ceed version\\n\");\n> -  exit(EXIT_FAILURE);\n> -}\n> -\n> -void init_ceed_params(){\n> -#if defined(_WIN32) || defined(__CYGWIN__)\n> -  ceed_ops[KEY('a')] = \"win\";\n> -  ceed_ops[KEY('i')] = CODI_IP_VIRT;\n> -#elif __APPLE__\n> -  ceed_ops[KEY('a')] = \"mac\";\n> -  ceed_ops[KEY('i')] = CODI_IP_VIRT;\n> -#elif __linux\n> -  ceed_ops[KEY('a')] = \"linux\";\n> -  ceed_ops[KEY('i')] = CODI_IP_NATIVE;\n> -#endif\n> -  ceed_ops[KEY('p')] = NULL;\n> -  ceed_ops[KEY('s')] = CODI_PORT;\n> -  ceed_ops[KEY('v')] = VERSION;\n> -  ceed_ops[KEY('r')] = \" \";\n> -  ceed_ops[KEY('z')] = CEED_NAME;\n> -}\n> -\n> -void parse_ceed_params(int argc, char *argv[]) {\n> -  int c, b_flg = 0, c_flg = 0, t_flg = 0, m_flg = 0, k_flg = 0;\n> -\n> -  init_ceed_params();\n> -\n> -  while((c = getopt(argc, argv, \"hvltm:kbcp:i:s:g:r:d:\")) != -1) {\n> -    switch (c) {\n> -    case 'h':\n> -      print_ceed_usage(argc, argv);\n> -      exit(EXIT_SUCCESS);\n> -      break;\n> -    case 'v':\n> -      INFO(\"ceed version : %s\\n\", VERSION);\n> -      exit(EXIT_SUCCESS);\n> -      break;\n> -    case 'p':\n> -      ceed_ops[KEY('p')] = optarg;\n> -      break;\n> -    case 'i':\n> -      ceed_ops[KEY('i')] = optarg;\n> -      break;\n> -    case 's':\n> -      ceed_ops[KEY('s')] = optarg;\n> -      break;\n> -    case 'g':\n> -      ceed_ops[KEY('g')] = optarg;\n> -      break;\n> -    case 'r':\n> -      ceed_ops[KEY('r')] = optarg;\n> -      break;\n> -    case 'd':\n> -      ceed_ops[KEY('d')] = optarg;\n> -      break;\n> -    case 'l':\n> -        asprintf(&ceed_ops[KEY('l')] , \"set\");\n> -      break;\n> -    case 'b':\n> -      if(c_flg) {\n> -        print_ceed_usage(argc, argv);\n> -      } else {\n> -        b_flg++;\n> -        asprintf(&ceed_ops[KEY('b')] , \"set\");\n> -      }\n> -      break;\n> -    case 'c':\n> -      if(b_flg) {\n> -        print_ceed_usage(argc, argv);\n> -      } else {\n> -        c_flg++;\n> -        asprintf(&ceed_ops[KEY('c')] , \"set\");\n> -      }\n> -      break;\n> -    case 't':\n> -      if(m_flg || k_flg) {\n> -        print_ceed_usage(argc, argv);\n> -      } else {\n> -        t_flg++;\n> -        asprintf(&ceed_ops[KEY('t')] , \"set\");\n> -      }\n> -      break;\n> -    case 'm':\n> -      if(t_flg || k_flg)\n> -        print_ceed_usage(argc, argv);\n> -      else {\n> -        m_flg++;\n> -        ceed_ops[KEY('m')] = optarg;\n> -      }\n> -      break;\n> -    case 'k':\n> -      if(t_flg || m_flg)\n> -        print_ceed_usage(argc, argv);\n> -      else {\n> -        k_flg++;\n> -        asprintf(&ceed_ops[KEY('k')] , \"set\");\n> -      }\n> -      break;\n> -    case '?':\n> -      if (optopt == 'p' || optopt == 'i' || optopt == 's' || optopt ==\n> 'm')\n> -        ERR(\"Option -%c requires an argument.\\n\", optopt);\n> -      else if (isprint(optopt))\n> -        ERR(\"Unknown option `-%c'.\\n\", optopt);\n> -      else\n> -        ERR(\"Unknown option character `\\\\x%x'.\\n\", optopt);\n> -    default:\n> -      print_ceed_usage(argc, argv);\n> -    }\n> -  }\n> -\n> -  if ((ceed_ops[KEY('l')] == NULL && ceed_ops[KEY('p')] == NULL &&\n> ceed_ops[KEY('g')] == NULL )\n> -    || (ceed_ops[KEY('i')] == NULL || ceed_ops[KEY('s')] == NULL)) {\n> -    print_ceed_usage(argc, argv);\n> -  }\n> -}\n> -\n> diff --git a/ceed/ceed_api.h b/ceed/ceed_api.h\n> deleted file mode 100755\n> index a66e6e6..0000000\n> --- a/ceed/ceed_api.h\n> +++ /dev/null\n> @@ -1,22 +0,0 @@\n> -/*\n> - * Copyright (C) 2016 Intel Corporation\n> - *\n> - * Author: Todor Minchev <todor.minchev@linux.intel.com>\n> - *\n> - * This program is free software; you can redistribute it and/or modify it\n> - * under the terms and conditions of the GNU General Public License,\n> - * version 2, or (at your option) any later version, as published by\n> - * the Free Software Foundation.\n> - *\n> - * This program is distributed in the hope it will be useful, but WITHOUT\n> - * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n> - * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n> for\n> - * more details.\n> - */\n> -\n> -#ifndef CEED_API_H\n> -#define CEED_API_H\n> -\n> -void parse_ceed_params(int argc, char *argv[]);\n> -\n> -#endif\n> diff --git a/codi/Makefile b/codi/Makefile\n> deleted file mode 100644\n> index 0b8135c..0000000\n> --- a/codi/Makefile\n> +++ /dev/null\n> @@ -1,19 +0,0 @@\n> -CFLAGS=-g -I. -I../\n> -LDFLAGS=-lsqlite3 -lm -ljansson -lcurl -lpthread\n> -DEPS = ../globals.h ../utils.h codi_api.h codi_db.h codi_launcher.h\n> codi_list.h\n> -OBJ = codi.o codi_db.o codi_list.o codi_launcher.o codi_api.o ../utils.o\n> ../globals.o\n> -\n> -all: codi\n> -\n> -debug: DFLAGS = -DDBG\n> -debug: clean codi\n> -\n> -%.o: %.c $(DEPS)\n> -       $(CC) -c -o $@ $< $(CFLAGS) $(DFLAGS)\n> -\n> -codi: $(OBJ)\n> -       $(CC) -o $@ $^ $(CFLAGS) $(LDFLAGS)\n> -\n> -.PHONY: clean\n> -clean:\n> -       rm -rf $(OBJ) codi\n> diff --git a/codi/codi.c b/codi/codi.c\n> deleted file mode 100644\n> index e24a03c..0000000\n> --- a/codi/codi.c\n> +++ /dev/null\n> @@ -1,126 +0,0 @@\n> -/*\n> - * Copyright (C) 2016 Intel Corporation\n> - *\n> - * Author: Todor Minchev <todor.minchev@linux.intel.com>\n> - *\n> - * This program is free software; you can redistribute it and/or modify it\n> - * under the terms and conditions of the GNU General Public License,\n> - * version 2, or (at your option) any later version, as published by\n> - * the Free Software Foundation.\n> - *\n> - * This program is distributed in the hope it will be useful, but WITHOUT\n> - * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n> - * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n> for\n> - * more details.\n> - */\n> -\n> -#include \"globals.h\"\n> -#include <stdlib.h>\n> -#include <signal.h>\n> -#include <netdb.h>\n> -#include <arpa/inet.h>\n> -#include <pthread.h>\n> -#include \"utils.h\"\n> -#include \"codi_db.h\"\n> -#include \"codi_api.h\"\n> -#include \"codi_list.h\"\n> -#include \"codi_launcher.h\"\n> -\n> -extern char *codi_ops[];\n> -int codi_sock_fd;\n> -/*\n> -pthread_mutex_t lock;\n> -*/\n> -\n> -/*TODO - close sockets on CTRL+C. Get rid of this when running as a\n> daemon */\n> -void close_sockets(int dummy) {\n> -  close(codi_sock_fd);\n> -  INFO(\"\\nClosed CODI socket. Exiting!\\n\") ;\n> -  exit(0);\n> -}\n> -\n> -int main(int argc, char *argv[]) {\n> -  struct addrinfo *addr_p;\n> -  int i, cli_sock_fd;\n> -  const char *codi_port = (const char*) CODI_PORT;\n> -  turff_node *req_node = NULL;\n> -  char *cli_params[KEY_ARR_SZ], *ip, *docker_url, *tmp_str;\n> -  socklen_t cli_len;\n> -  struct sockaddr cli_addr;\n> -  struct sockaddr_in *cli_ip;\n> -\n> -  parse_codi_params(argc, argv);\n> -\n> -  for (i = 0; i <  KEY_ARR_SZ; i++)\n> -    cli_params[i] = NULL;\n> -\n> -  addr_p = bind_to_socket(NULL, codi_port, &codi_sock_fd);\n> -\n> -  if (addr_p == NULL) {\n> -    ERR(\"Could not bind CODI to socket\\n\");\n> -  } else {\n> -    INFO(\"CODI listening on port: %s\\n\", codi_port);\n> -\n> -  }\n> -\n> -  listen(codi_sock_fd,1);\n> -  cli_len = sizeof(cli_addr);\n> -\n> -  signal(SIGINT, close_sockets);\n> -\n> -  while(1) {\n> -    cli_sock_fd = accept(codi_sock_fd, &cli_addr, &cli_len);\n> -\n> -    if (cli_sock_fd < 0)\n> -      ERR(\"ERROR on accept\");\n> -\n> -    free_params(cli_params);\n> -    receive_args(cli_sock_fd, cli_params);\n> -\n> -    /*turff registration*/\n> -    if (!strcmp(cli_params[KEY('z')], TURFF_NAME)) {\n> -      cli_ip = (struct sockaddr_in*) &cli_addr;\n> -      asprintf(&ip, \"%s\", inet_ntoa(cli_ip->sin_addr));\n> -      cli_params[KEY('c')] = ip;\n> -      db_insert_node(cli_params[KEY('n')], cli_params[KEY('c')],\n> cli_params[KEY('s')]);\n> -      INFO(\"\\nToolchain registration received: %s : %s : %s \\n\",\n> cli_params[KEY('n')],\n> -      cli_params[KEY('c')], cli_params[KEY('s')]) ;\n> -    } else if (!strcmp(cli_params[KEY('z')], CEED_NAME) &&\n> (cli_params[KEY('l')] != NULL )) {\n> -      /* ceed request for available toolchains */\n> -      return_turff_nodes(cli_sock_fd);\n> -    } else if (!strcmp(cli_params[KEY('z')], CEED_NAME) &&\n> (cli_params[KEY('d')] != NULL )) {\n> -      /* must be a command from ceed*/\n> -      req_node = find_turff_node(cli_params[KEY('d')]);\n> -      if (req_node != NULL) {\n> -\n> -        /* check if docker engine is listening on a unix socket or tcp*/\n> -        if (codi_ops[KEY('i')] == NULL || codi_ops[KEY('p')] == NULL) {\n> -          asprintf(&docker_url, \"%s\", codi_ops[KEY('u')]);\n> -        } else {\n> -          asprintf(&docker_url, \"%s:%s\", codi_ops[KEY('i')],\n> codi_ops[KEY('p')]);\n> -        }\n> -\n> -        if (is_container_running(docker_url, cli_params[KEY('d')])) {\n> -          process_ceed_cmd(req_node, cli_sock_fd, cli_params);\n> -        } else {\n> -          asprintf(&tmp_str, \"Container %s is not running\\n%s\",\n> -            cli_params[KEY('d')], TURFF_EOM);\n> -          send_data(cli_sock_fd, tmp_str, strlen(tmp_str));\n> -          free(tmp_str);\n> -        }\n> -        free(docker_url);\n> -      } else {\n> -        asprintf(&tmp_str, \"Container %s not found in database\\n%s\",\n> -          cli_params[KEY('d')], TURFF_EOM);\n> -        send_data(cli_sock_fd, tmp_str, strlen(tmp_str));\n> -        free(tmp_str);\n> -      }\n> -    } else {\n> -      asprintf(&tmp_str, \"Invalid command sent to CODI\\n%s\", TURFF_EOM);\n> -      send_data(cli_sock_fd, tmp_str, strlen(tmp_str));\n> -      free(tmp_str);\n> -    }\n> -\n> -    free_params(cli_params);\n> -  }\n> -}\n> diff --git a/codi/codi_api.c b/codi/codi_api.c\n> deleted file mode 100644\n> index b9eff56..0000000\n> --- a/codi/codi_api.c\n> +++ /dev/null\n> @@ -1,134 +0,0 @@\n> -/*\n> - * Copyright (C) 2016 Intel Corporation\n> - *\n> - * Author: Todor Minchev <todor.minchev@linux.intel.com>\n> - *\n> - * This program is free software; you can redistribute it and/or modify it\n> - * under the terms and conditions of the GNU General Public License,\n> - * version 2, or (at your option) any later version, as published by\n> - * the Free Software Foundation.\n> - *\n> - * This program is distributed in the hope it will be useful, but WITHOUT\n> - * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n> - * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n> for\n> - * more details.\n> - */\n> -\n> -#include \"globals.h\"\n> -#include <stdlib.h>\n> -#include <ctype.h>\n> -#include \"utils.h\"\n> -#include \"codi_api.h\"\n> -#include \"codi_list.h\"\n> -#include \"codi_launcher.h\"\n> -\n> -char *codi_ops[KEY_ARR_SZ];\n> -\n> -void print_codi_usage(int argc, char *argv[])\n> -{\n> -  printf(\"Usage: %s \\n\", argv[0]);\n> -  printf(\" -s port number on which CODI is listening [default: 10000]\\n\");\n> -  printf(\" -u unix socket path of Docker engine [default:\n> /var/lib/docker.sock]\\n\");\n> -  printf(\" -i ip address of Docker engine [default: 127.0.0.1]\\n\");\n> -  printf(\" -p port number of Docker engine [default: 2376]\\n\");\n> -  printf(\" -h print this help menu\\n\");\n> -  printf(\" -v show CODI version\\n\");\n> -}\n> -\n> -void init_codi_params()\n> -{\n> -  int i;\n> -\n> -  for (i = 0; i <  KEY_ARR_SZ; i++)\n> -    codi_ops[i] = NULL;\n> -\n> -  codi_ops[KEY('s')] = CODI_PORT;\n> -  codi_ops[KEY('v')] = VERSION;\n> -  codi_ops[KEY('i')] = NULL;\n> -  codi_ops[KEY('p')] = NULL;\n> -  codi_ops[KEY('u')] = DOCKER_UNIX_SOCKET;\n> -  codi_ops[KEY('z')] = CODI_NAME;\n> -}\n> -\n> -void parse_codi_params(int argc, char *argv[])\n> -{\n> -  int c, i_flg = 0, p_flg = 0, u_flg = 0;\n> -\n> -  init_codi_params() ;\n> -\n> -  while ((c = getopt(argc, argv, \"hvs:i:p:u:\")) != -1) {\n> -    switch (c) {\n> -    case 'h':\n> -      print_codi_usage(argc, argv);\n> -      exit(EXIT_SUCCESS);\n> -      break;\n> -    case 'v':\n> -      INFO(\"CODI version : %s\\n\", VERSION);\n> -      exit(EXIT_SUCCESS);\n> -      break;\n> -    case 's':\n> -      codi_ops[KEY('s')]  = optarg;\n> -      break;\n> -    case 'i':\n> -      if(u_flg) {\n> -        print_codi_usage(argc, argv);\n> -      } else {\n> -        i_flg++;\n> -        codi_ops[KEY('i')]  = optarg;\n> -      }\n> -      break;\n> -    case 'p':\n> -      if(u_flg) {\n> -        print_codi_usage(argc, argv);\n> -      } else {\n> -        p_flg++;\n> -        codi_ops[KEY('p')]  = optarg;\n> -      }\n> -      break;\n> -    case 'u':\n> -      if(i_flg || p_flg) {\n> -        print_codi_usage(argc, argv);\n> -      } else {\n> -        u_flg++;\n> -        codi_ops[KEY('u')]  = optarg;\n> -      }\n> -      break;\n> -    case '?':\n> -      if (optopt == 's' || optopt == 'i' || optopt == 'p' || optopt ==\n> 'u')\n> -        INFO(\"Option -%c requires an argument.\\n\", optopt);\n> -      else if (isprint (optopt))\n> -        INFO(\"Unknown option `-%c'.\\n\", optopt);\n> -      else\n> -        INFO(\"Unknown option character `\\\\x%x'.\\n\", optopt);\n> -    default:\n> -      print_codi_usage(argc, argv);\n> -      exit(EXIT_FAILURE);\n> -    }\n> -  }\n> -}\n> -\n> -int process_ceed_cmd(turff_node *t_node, int ceed_sock_fd, char\n> *ceed_params[])\n> -{\n> -  struct addrinfo *addr_p;\n> -  int turff_sock_fd;\n> -\n> -  addr_p = connect_to_socket(t_node->ip, t_node->port, &turff_sock_fd);\n> -\n> -  if (addr_p == NULL) {\n> -    INFO(\"Could not connect to node id: %s ip: %s port: %s\\n\",\n> -    t_node->id, t_node->ip, t_node->port);\n> -    return 1;\n> -  } else {\n> -    INFO(\"Connected to node id: %s ip: %s port: %s\\n\",\n> -      t_node->id, t_node->ip, t_node->port);\n> -\n> -    /* change the source signature of the param array */\n> -    asprintf(&(ceed_params[KEY('z')]), \"%s\", CODI_NAME);\n> -\n> -    /* forward parameters to turff */\n> -    send_args(turff_sock_fd, ceed_params);\n> -    redirect_sockets(turff_sock_fd, ceed_sock_fd);\n> -  }\n> -  close(turff_sock_fd);\n> -  return 0;\n> -}\n> diff --git a/codi/codi_api.h b/codi/codi_api.h\n> deleted file mode 100644\n> index c5813dd..0000000\n> --- a/codi/codi_api.h\n> +++ /dev/null\n> @@ -1,25 +0,0 @@\n> -/*\n> - * Copyright (C) 2016 Intel Corporation\n> - *\n> - * Author: Todor Minchev <todor.minchev@linux.intel.com>\n> - *\n> - * This program is free software; you can redistribute it and/or modify it\n> - * under the terms and conditions of the GNU General Public License,\n> - * version 2, or (at your option) any later version, as published by\n> - * the Free Software Foundation.\n> - *\n> - * This program is distributed in the hope it will be useful, but WITHOUT\n> - * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n> - * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n> for\n> - * more details.\n> - */\n> -\n> -#ifndef CODI_API_H\n> -#define CODI_API_H\n> -\n> -#include \"codi_list.h\"\n> -\n> -int process_ceed_cmd(turff_node *t_node, int ceed_sock_fd, char\n> *ceed_params[]);\n> -void parse_codi_params(int argc, char *argv[]);\n> -\n> -#endif\n> diff --git a/codi/codi_db.c b/codi/codi_db.c\n> deleted file mode 100644\n> index 91ab5bd..0000000\n> --- a/codi/codi_db.c\n> +++ /dev/null\n> @@ -1,137 +0,0 @@\n> -/*\n> - * Copyright (C) 2016 Intel Corporation\n> - *\n> - * Author: Todor Minchev <todor.minchev@linux.intel.com>\n> - *\n> - * This program is free software; you can redistribute it and/or modify it\n> - * under the terms and conditions of the GNU General Public License,\n> - * version 2, or (at your option) any later version, as published by\n> - * the Free Software Foundation.\n> - *\n> - * This program is distributed in the hope it will be useful, but WITHOUT\n> - * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n> - * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n> for\n> - * more details.\n> - */\n> -\n> -#include \"globals.h\"\n> -#include <stdlib.h>\n> -#include <sqlite3.h>\n> -#include \"codi_db.h\"\n> -#include \"codi_list.h\"\n> -\n> -static sqlite3 *codi_db;\n> -\n> -/* connect */\n> -int db_connect(void)\n> -{\n> -  int result;\n> -  result = sqlite3_open(CODI_DB, &codi_db);\n> -\n> -  if (result != SQLITE_OK ) {\n> -    INFO(\"SQL error: %s\\n\", sqlite3_errmsg(codi_db));\n> -    sqlite3_close(codi_db);\n> -    return -1;\n> -  }\n> -\n> -  return init_db();\n> -}\n> -\n> -int init_db(void)\n> -{\n> -  int result;\n> -  char *err = 0;\n> -  char *qry = \"CREATE TABLE IF NOT EXISTS nodes(id TEXT UNIQUE NOT NULL \\\n> -    CHECK(id <> ''), ip TEXT NOT NULL CHECK(ip <> ''), port TEXT NOT NULL\n> \\\n> -    CHECK(port <> ''), date TEXT NOT NULL CHECK(date <> ''));\";\n> -\n> -  result = sqlite3_exec(codi_db, qry, 0, 0, &err);\n> -\n> -  if (result != SQLITE_OK) {\n> -    INFO(\"SQL error: %s\\n\", err);\n> -    sqlite3_free(err);\n> -    sqlite3_close(codi_db);\n> -    return 1;\n> -  }\n> -\n> -  return 0;\n> -}\n> -\n> -/* insert node */\n> -int db_insert_node(char *id, char *ip, char *port)\n> -{\n> -  int result;\n> -  char *qry, *err = 0;\n> -  turff_node *node;\n> -\n> -  node = find_turff_node(id);\n> -\n> -  /* if a node with this id exists just update it*/\n> -  if (node != NULL) {\n> -    asprintf(&qry, \"UPDATE nodes SET ip = '%s', port = '%s', date = \\\n> -    datetime(CURRENT_TIMESTAMP, 'localtime') WHERE ID = '%s';\", ip, port,\n> id);\n> -  }\n> -  else {\n> -    asprintf(&qry, \"INSERT INTO nodes (id, ip, port, date) VALUES\n> ('%s','%s', \\\n> -    '%s', datetime(CURRENT_TIMESTAMP, 'localtime'));\", id, ip, port);\n> -  }\n> -\n> -  result = exec_db_query(qry, 0, 0, &err);\n> -  free(qry);\n> -\n> -  return result;\n> -}\n> -\n> -int exec_db_query(const char *sql, int (*callback)(void*, int, char**,\n> char**), \\\n> -  void *callback_arg, char **errmsg)\n> -{\n> -  int result;\n> -\n> -  if (db_connect() != 0)\n> -    return -1;\n> -\n> -  result = sqlite3_exec(codi_db, sql, callback, callback_arg, errmsg);\n> -\n> -  if (result != SQLITE_OK) {\n> -    INFO(\"SQL insert error: %s\\n\", *errmsg);\n> -    sqlite3_free(*errmsg);\n> -    sqlite3_close(codi_db);\n> -    return result;\n> -  }\n> -  sqlite3_close(codi_db);\n> -  return SQLITE_OK;\n> -}\n> -\n> -static int find_node_callback(void *dummy, int argc, char **argv, char\n> **col_name)\n> -{\n> -  int i;\n> -\n> -  /* no records were found */\n> -  if(argc == 0)\n> -    return 1;\n> -\n> -  add_turff_node(argv[0], argv[1], argv[2], argv[3]);\n> -\n> -  return 0;\n> -}\n> -\n> -/* find node(s) - gets all nodes if id is NULL */\n> -int get_db_nodes(char *id)\n> -{\n> -  int result;\n> -  char *qry, *err = 0;\n> -\n> -  /* remove all nodes from the list before reading them from the db*/\n> -  free_turff_nodes_list();\n> -\n> -  /* get all nodes */\n> -  if (id == NULL)\n> -    asprintf(&qry, \"SELECT * FROM nodes;\");\n> -  else\n> -    asprintf(&qry, \"SELECT * from nodes WHERE id='%s';\", id);\n> -\n> -  result = exec_db_query(qry, find_node_callback, 0, &err);\n> -  free(qry);\n> -\n> -  return result;\n> -}\n> diff --git a/codi/codi_db.h b/codi/codi_db.h\n> deleted file mode 100644\n> index c6fd586..0000000\n> --- a/codi/codi_db.h\n> +++ /dev/null\n> @@ -1,28 +0,0 @@\n> -/*\n> - * Copyright (C) 2016 Intel Corporation\n> - *\n> - * Author: Todor Minchev <todor.minchev@linux.intel.com>\n> - *\n> - * This program is free software; you can redistribute it and/or modify it\n> - * under the terms and conditions of the GNU General Public License,\n> - * version 2, or (at your option) any later version, as published by\n> - * the Free Software Foundation.\n> - *\n> - * This program is distributed in the hope it will be useful, but WITHOUT\n> - * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n> - * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n> for\n> - * more details.\n> - */\n> -\n> -#ifndef CODI_DB_H\n> -#define CODI_DB_H\n> -\n> -#define CODI_DB      \"codi.db\"\n> -\n> -int init_db(void);\n> -int db_insert_node(char *id, char *ip, char *port);\n> -int exec_db_query(const char *sql, int (*callback)(void*, int, char**,\n> char**), \\\n> -  void *callback_arg, char **errmsg);\n> -int get_db_nodes(char *id);\n> -\n> -#endif\n> diff --git a/codi/codi_launcher.c b/codi/codi_launcher.c\n> deleted file mode 100644\n> index 1087761..0000000\n> --- a/codi/codi_launcher.c\n> +++ /dev/null\n> @@ -1,146 +0,0 @@\n> -/*\n> - * Copyright (C) 2016 Intel Corporation\n> - *\n> - * Author: Todor Minchev <todor.minchev@linux.intel.com>\n> - *\n> - * This program is free software; you can redistribute it and/or modify it\n> - * under the terms and conditions of the GNU General Public License,\n> - * version 2, or (at your option) any later version, as published by\n> - * the Free Software Foundation.\n> - *\n> - * This program is distributed in the hope it will be useful, but WITHOUT\n> - * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n> - * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n> for\n> - * more details.\n> - */\n> -\n> -#include \"globals.h\"\n> -#include <jansson.h>\n> -#include <string.h>\n> -#include <curl/curl.h>\n> -#include <ctype.h>\n> -#include \"codi_launcher.h\"\n> -\n> -/* execute the request and return an array of json objects */\n> -json_t *request_json(char *request_method, char *url, char *api, char\n> *data)\n> -{\n> -  char *in = 0, *j_start;\n> -  json_t *root;\n> -  json_error_t err;\n> -\n> -  in = curl_request(request_method, url, api, data);\n> -\n> -  /* skip the header and move to the json array */\n> -  j_start = strchr(in, '[');\n> -  root = json_loads(j_start, 0, &err);\n> -  free(in);\n> -  return root;\n> -}\n> -\n> -/* execute the request and return the raw server reply */\n> -char *curl_request(char *http_method, char *url, char *api,  char *data)\n> -{\n> -\n> -  CURL *curl = NULL;\n> -  CURLcode res;\n> -  struct curl_slist *api_hdr = NULL;\n> -  curl_mem_chunk_t srv_reply ;\n> -  char *request_str ;\n> -\n> -  srv_reply.mem = calloc(1, 1) ;\n> -\n> -  if (srv_reply.mem == NULL)\n> -    ERR(\"ERROR: Unable to allocate memory\");\n> -\n> -  srv_reply.size = 0 ;\n> -  curl = curl_easy_init();\n> -\n> -  if (curl) {\n> -    /* check if url is a unix socket*/\n> -    if (url[0] == '/') {\n> -      /* map the unix socket as a connection endpoint */\n> -      curl_easy_setopt(curl, CURLOPT_UNIX_SOCKET_PATH, url);\n> -      asprintf(&request_str, \"%s%s\", \"http:\", api);\n> -    } else {\n> -        asprintf(&request_str, \"%s%s%s\",  \"http://\", url, api);\n> -    }\n> -\n> -    curl_easy_setopt(curl, CURLOPT_URL, request_str);\n> -\n> -    if (!strcmp(http_method, POST_REQUEST)) {\n> -      curl_easy_setopt(curl, CURLOPT_POST, 1L);\n> -      api_hdr = curl_slist_append(api_hdr, \"Content-Type:\n> application/json\");\n> -      api_hdr = curl_slist_append(api_hdr, \"Expect:\");\n> -      curl_easy_setopt(curl, CURLOPT_HTTPHEADER, api_hdr);\n> -\n> -      if (data == NULL)\n> -        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, \"\");\n> -      else\n> -        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, data);\n> -    }\n> -\n> -    curl_easy_setopt(curl, CURLOPT_HEADER, 1);\n> -    curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *) &srv_reply);\n> -    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, process_srv_reply);\n> -\n> -#ifdef DBG\n> -    curl_easy_setopt(curl, CURLOPT_VERBOSE, 1);\n> -#endif\n> -\n> -    res = curl_easy_perform(curl);\n> -\n> -    if (res != CURLE_OK)\n> -      INFO(\"curl_easy_perform() failed: %s\\n\", curl_easy_strerror(res));\n> -\n> -    if (!strcmp(http_method, POST_REQUEST))\n> -      curl_slist_free_all(api_hdr);\n> -\n> -    free(request_str);\n> -    curl_easy_cleanup(curl);\n> -  }\n> -\n> -  return srv_reply.mem;\n> -}\n> -\n> -size_t process_srv_reply(void *ptr, size_t size, size_t nmemb, void\n> *reply_p)\n> -{\n> -  size_t chunk_size = size * nmemb;\n> -\n> -  curl_mem_chunk_t *mem_chunk = (curl_mem_chunk_t *)reply_p;\n> -\n> -  /* append chunk_size memory block to the original memory block */\n> -  mem_chunk->mem = realloc(mem_chunk->mem, mem_chunk->size + chunk_size +\n> 1);\n> -  if (mem_chunk->mem == NULL)\n> -    ERR(\"not enough memory (realloc returned NULL)\\n\");\n> -\n> -  INFO(\"%s\", ptr);\n> -\n> -  /* copy the data into the newly allocated chunk */\n> -  memcpy(&(mem_chunk->mem[mem_chunk->size]), ptr, chunk_size);\n> -  mem_chunk->size += chunk_size;\n> -  mem_chunk->mem[mem_chunk->size] = 0;\n> -  return chunk_size;\n> -}\n> -\n> -bool is_container_running(char *url, char *cont_name)\n> -{\n> -  char *api_str = NULL;\n> -  json_t *result;\n> -\n> -  asprintf(&api_str, RUNNING_NAMED_CONTAINER, cont_name);\n> -  result = request_json(GET_REQUEST, url, api_str, NULL);\n> -  free(api_str);\n> -\n> -  if (json_array_size(result)) {\n> -    json_decref(result);\n> -    return true;\n> -  } else {\n> -\n> -#ifdef DBG\n> -  INFO(\"Container : %s is not running\\n\", cont_name);\n> -#endif\n> -\n> -    json_decref(result);\n> -    return false;\n> -  }\n> -}\n> diff --git a/codi/codi_launcher.h b/codi/codi_launcher.h\n> deleted file mode 100644\n> index 1b81e49..0000000\n> --- a/codi/codi_launcher.h\n> +++ /dev/null\n> @@ -1,58 +0,0 @@\n> -/*\n> - * Copyright (C) 2016 Intel Corporation\n> - *\n> - * Author: Todor Minchev <todor.minchev@linux.intel.com>\n> - *\n> - * This program is free software; you can redistribute it and/or modify it\n> - * under the terms and conditions of the GNU General Public License,\n> - * version 2, or (at your option) any later version, as published by\n> - * the Free Software Foundation.\n> - *\n> - * This program is distributed in the hope it will be useful, but WITHOUT\n> - * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n> - * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n> for\n> - * more details.\n> - */\n> -\n> -#ifndef CODI_LAUNCHER_H\n> -#define CODI_LAUNCHER_H\n> -\n> -#include <jansson.h>\n> -#include \"globals.h\"\n> -\n> -\n> -/* Docker Remote API requests */\n> -#define GET_REQUEST              \"GET\"\n> -#define POST_REQUEST             \"POST\"\n> -#define DOCKER_UNIX_SOCKET       \"/var/run/docker.sock\"\n> -#define DOCKER_ENG_IP            \"127.0.0.1\"\n> -#define DOCKER_ENG_PORT         \"2376\"\n> -#define GET_IMAGES               \"/images/json\"\n> -#define ALL_CONTAINERS           \"/containers/json?all=true\"\n> -#define START_CONTAINER          \"/containers/%s/start\"\n> -#define CREATE_CONTAINER         \"/containers/create?name=%s\"\n> -#define GET_IMAGE                \"/images/create?fromImage=%s&tag=%s\"\n> -\n> -#define NAMED_CONTAINER          \"/containers/json?all=true&filters=\" \\\n> -                                 \"{%%22name%%22:[%%22%s%%22]}\"\n> -\n> -#define RUNNING_NAMED_CONTAINER  \"/containers/json?all=true&filters=\" \\\n> -\n>  \"{%%22name%%22:[%%22%s%%22],%%22status%%22:[%%22running%%22]}\"\n> -\n> -/* Docker Engine Responses */\n> -#define PULL_COMPLETE      \"Pull complete\"\n> -#define IMAGE_UP_TO_DATE   \"Image is up to date\"\n> -#define NO_ERROR_204       \"204 No Content\"\n> -#define NOT_MODIFIED_304   \"304 Not Modified\"\n> -#define CREATED_201        \"201 Created\"\n> -#define OK_200             \"200 OK\"\n> -\n> -#define CONTAINER_PARAMS(...) #__VA_ARGS__\n> -\n> -char *curl_request(char *http_method, char *url, char *api,  char *data);\n> -size_t process_srv_reply(void *ptr, size_t size, size_t nmemb, void\n> *reply_p);\n> -json_t *request_json(char *request_method, char *url, char *api, char\n> *data);\n> -bool is_container_running(char *url, char *cont_name);\n> -bool start_container(char *url, char *cont_name);\n> -\n> -#endif\n> diff --git a/codi/codi_list.c b/codi/codi_list.c\n> deleted file mode 100644\n> index 4a3f745..0000000\n> --- a/codi/codi_list.c\n> +++ /dev/null\n> @@ -1,100 +0,0 @@\n> -/*\n> - * Copyright (C) 2016 Intel Corporation\n> - *\n> - * Author: Todor Minchev <todor.minchev@linux.intel.com>\n> - *\n> - * This program is free software; you can redistribute it and/or modify it\n> - * under the terms and conditions of the GNU General Public License,\n> - * version 2, or (at your option) any later version, as published by\n> - * the Free Software Foundation.\n> - *\n> - * This program is distributed in the hope it will be useful, but WITHOUT\n> - * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n> - * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n> for\n> - * more details.\n> - */\n> -\n> -#include \"globals.h\"\n> -#include <stdlib.h>\n> -#include <stdint.h>\n> -#include <stdio.h>\n> -#include <string.h>\n> -#include \"utils.h\"\n> -#include \"codi_db.h\"\n> -#include \"codi_list.h\"\n> -\n> -turff_node *head = NULL;\n> -\n> -turff_node *find_turff_node(char *id)\n> -{\n> -\n> -  /* clear the list and read the nodes from the db*/\n> -  get_db_nodes(id);\n> -  turff_node *cur = head;\n> -\n> -  while (cur != NULL) {\n> -    if(!strcmp(cur->id, id))\n> -      return cur;\n> -    else\n> -      cur = cur->next;\n> -  }\n> -  return NULL;\n> -}\n> -\n> -void free_turff_nodes_list()\n> -{\n> -  turff_node *tmp = NULL;\n> -\n> -  while (head != NULL) {\n> -    free(head->id);\n> -    free(head->ip);\n> -    free(head->port);\n> -    free(head->date);\n> -    tmp = head ;\n> -    head = head->next;\n> -    free(tmp);\n> -  }\n> -}\n> -\n> -void add_turff_node(char *id, char *ip, char *port, char *date)\n> -{\n> -  int node_exists = 0;\n> -  turff_node *node;\n> -\n> -  node = calloc(1, sizeof(turff_node));\n> -  asprintf(&(node->id), \"%s\", id);\n> -  asprintf(&(node->ip), \"%s\", ip);\n> -  asprintf(&(node->port), \"%s\",  port);\n> -  asprintf(&(node->date), \"%s\",  date);\n> -  node->next = head;\n> -  head = node;\n> -}\n> -\n> -\n> -/* send these to ceed*/\n> -void return_turff_nodes(int sock_fd)\n> -{\n> -  int i;\n> -  char *tmp_node[KEY_ARR_SZ];\n> -\n> -  /* clear the list and read the nodes from the db*/\n> -  get_db_nodes(NULL);\n> -  turff_node *cur = head;\n> -\n> -  for (i = 0; i <  KEY_ARR_SZ; i++)\n> -    tmp_node[i] = NULL;\n> -\n> -  while (cur != NULL) {\n> -    tmp_node[KEY('d')] = cur->id;\n> -\n> -#ifdef DBG\n> -    DEBUG(\"Sent turff node id : %s ip: %s port %s\\n\", cur->id, cur->ip,\n> cur->port);\n> -#endif\n> -\n> -    send_args(sock_fd, tmp_node);\n> -    cur = cur->next;\n> -  }\n> -\n> -  tmp_node[KEY('e')] = \"set\";\n> -  send_args(sock_fd, tmp_node);\n> -}\n> diff --git a/codi/codi_list.h b/codi/codi_list.h\n> deleted file mode 100644\n> index 4ce5301..0000000\n> --- a/codi/codi_list.h\n> +++ /dev/null\n> @@ -1,33 +0,0 @@\n> -/*\n> - * Copyright (C) 2016 Intel Corporation\n> - *\n> - * Author: Todor Minchev <todor.minchev@linux.intel.com>\n> - *\n> - * This program is free software; you can redistribute it and/or modify it\n> - * under the terms and conditions of the GNU General Public License,\n> - * version 2, or (at your option) any later version, as published by\n> - * the Free Software Foundation.\n> - *\n> - * This program is distributed in the hope it will be useful, but WITHOUT\n> - * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n> - * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n> for\n> - * more details.\n> - */\n> -\n> -#ifndef CODI_LIST_H\n> -#define CODI_LIST_H\n> -\n> -typedef struct list_node{\n> -  char *id;\n> -  char *ip;\n> -  char *port;\n> -  char *date;\n> -  struct list_node *next;\n> -} turff_node;\n> -\n> -turff_node *find_turff_node(char *id);\n> -void add_turff_node(char *id, char *ip, char *port, char *date);\n> -void return_turff_nodes();\n> -void free_turff_nodes_list();\n> -\n> -#endif\n> diff --git a/confs/ostro/ostro.conf b/confs/ostro/ostro.conf\n> deleted file mode 100644\n> index 796104b..0000000\n> --- a/confs/ostro/ostro.conf\n> +++ /dev/null\n> @@ -1,16 +0,0 @@\n> -# allows a standard development build. Read the ostro docs for production\n> settings.\n> -require conf/distro/include/ostro-os-development.inc\n> -# default ostro mirror, used for speedup!!!\n> -SSTATE_MIRRORS ?= \"file://.*\n> http://download.ostroproject.org/sstate/ostro-os/PATH\"\n> -# puts results on the shared host folder\n> -# windows can't do this due to lack of ln -s support on shared volumes\n> -#DEPLOY_DIR_IMAGE = \"/ostro/ostro-shared/images\"\n> -# windows hangs on this. Currently unsure why.\n> -#SSTATE_DIR = \"/ostro/ostro-shared/sstate\"\n> -DL_DIR = \"/ostro/ostro-shared/downloads\"\n> -# lets bitbake ignore the odd inode settings of the shared directory\n> -BB_DISKMON_DIRS = \"\\\n> -    STOPTASKS,${TMPDIR},1G,100K \\\n> -    ABORT,${TMPDIR},100M,1K \"\n> -# keep workdir small\n> -INHERIT+=\"rm_work\"\n> diff --git a/confs/ostro/ostro.layers b/confs/ostro/ostro.layers\n> deleted file mode 100644\n> index e69de29..0000000\n> diff --git a/dockerfiles/Dockerfile.ceed.deps\n> b/dockerfiles/Dockerfile.ceed.deps\n> deleted file mode 100644\n> index f806613..0000000\n> --- a/dockerfiles/Dockerfile.ceed.deps\n> +++ /dev/null\n> @@ -1,16 +0,0 @@\n> -# This file describes the standard way to build the dependencies required\n> for\n> -# cross compiling ceed with mingw\n> -#\n> -# Usage:\n> -#\n> -# docker build -t crops/ceed:deps -f Dockerfile.ceed.deps .\n> -\n> -FROM debian:jessie\n> -MAINTAINER Todor Minchev <todor.minchev@linux.intel.com>\n> -\n> -# Install dependencies\n> -RUN apt-get update && apt-get install -y \\\n> -  mingw-w64 \\\n> -  gcc \\\n> -  make\n> -\n> diff --git a/dockerfiles/Dockerfile.ceed.linux\n> b/dockerfiles/Dockerfile.ceed.linux\n> deleted file mode 100644\n> index 10fcf90..0000000\n> --- a/dockerfiles/Dockerfile.ceed.linux\n> +++ /dev/null\n> @@ -1,19 +0,0 @@\n> -# This file describes the standard way to cross compile ceed with mingw\n> -#\n> -# Example:\n> -#\n> -# docker build -t crops/ceed:0.1 -f Dockerfile.ceed.linux ../\n> -\n> -FROM crops/ceed:deps\n> -MAINTAINER Todor Minchev <todor.minchev@linux.intel.com>\n> -LABEL name=\"ceed-linux\"\n> -\n> -# Build and install CEED\n> -RUN mkdir -p /usr/local/crops/ceed/\n> -COPY ceed /usr/local/crops/ceed/\n> -COPY utils.[ch] /usr/local/crops/\n> -COPY globals.[ch] /usr/local/crops/\n> -\n> -RUN cd /usr/local/crops/ceed && \\\n> -  CC=gcc make\n> -\n> diff --git a/dockerfiles/Dockerfile.ceed.win\n> b/dockerfiles/Dockerfile.ceed.win\n> deleted file mode 100644\n> index 7674c69..0000000\n> --- a/dockerfiles/Dockerfile.ceed.win\n> +++ /dev/null\n> @@ -1,19 +0,0 @@\n> -# This file describes the standard way to cross compile ceed with mingw\n> -#\n> -# Example:\n> -#\n> -# docker build -t crops/ceed:0.1 -f Dockerfile.ceed.win ../\n> -\n> -FROM crops/ceed:deps\n> -MAINTAINER Todor Minchev <todor.minchev@linux.intel.com>\n> -LABEL name=\"ceed-windows\"\n> -\n> -# Build and install CEED\n> -RUN mkdir -p /usr/local/crops/ceed/\n> -COPY ceed /usr/local/crops/ceed/\n> -COPY utils.[ch] /usr/local/crops/\n> -COPY globals.[ch] /usr/local/crops/\n> -\n> -RUN cd /usr/local/crops/ceed && \\\n> -  CC=x86_64-w64-mingw32-gcc make\n> -\n> diff --git a/dockerfiles/Dockerfile.codi b/dockerfiles/Dockerfile.codi\n> deleted file mode 100644\n> index cf6ef30..0000000\n> --- a/dockerfiles/Dockerfile.codi\n> +++ /dev/null\n> @@ -1,34 +0,0 @@\n> -# This file describes the standard way to build a CROPS dispatcher image\n> -#\n> -# Usage:\n> -#\n> -# # Build CODI image with the following command. Replace the \"version\" tag\n> -# with the current codi version\n> -#\n> -# docker build -t crops/codi:version -f Dockerfile.codi ../\n> -#\n> -# Example: Build CODI version 0.1\n> -#\n> -# docker build -t crops/codi:0.1 -f Dockerfile.codi ../\n> -\n> -FROM crops/codi:deps\n> -MAINTAINER Todor Minchev <todor.minchev@linux.intel.com>\n> -\n> -# Build and install CODI\n> -RUN mkdir -p /usr/local/crops/codi/\n> -COPY codi /usr/local/crops/codi/\n> -COPY utils.[ch] /usr/local/crops/\n> -COPY globals.[ch] /usr/local/crops/\n> -ARG build_type\n> -\n> -RUN    cd /usr/local/crops/codi && \\\n> -       make $build_type && \\\n> -       mkdir -p /bin/codi && \\\n> -       cp /usr/local/crops/codi/codi /bin/codi/run && \\\n> -       rm -rf /usr/local/crops\n> -\n> -# Monitor CODI and restart it on exit\n> -ENTRYPOINT [\"supervise\", \"/bin/codi\"]\n> -\n> -# Default CODI port\n> -EXPOSE 10000\n> diff --git a/dockerfiles/Dockerfile.codi.deps\n> b/dockerfiles/Dockerfile.codi.deps\n> deleted file mode 100644\n> index dc563d0..0000000\n> --- a/dockerfiles/Dockerfile.codi.deps\n> +++ /dev/null\n> @@ -1,31 +0,0 @@\n> -# This file describes the standard way to build the dependencies for a\n> CROPS\n> -# dispatcher image\n> -#\n> -# Usage:\n> -#\n> -# # Build CODI dependencies image with the following command:\n> -#\n> -# docker build -t crops/codi:deps -f Dockerfile.codi.deps .\n> -#\n> -\n> -FROM debian:wheezy\n> -MAINTAINER Todor Minchev <todor.minchev@linux.intel.com>\n> -\n> -# Install dependencies\n> -RUN apt-get update -qq && apt-get install -y -qq \\\n> -       libsqlite3-dev \\\n> -       libjansson-dev  \\\n> -       git     \\\n> -       wget \\\n> -       daemontools \\\n> -       build-essential && \\\n> -       apt-get upgrade -y -qq\n> -\n> -#Install a version of curl with unix sockets support\n> -RUN wget -q -P /tmp http://curl.haxx.se/download/curl-7.45.0.tar.gz && \\\n> -       cd /tmp && \\\n> -       tar xf curl-7.45.0.tar.gz && \\\n> -       cd curl-7.45.0 && \\\n> -       ./configure --prefix=/usr --enable-unix-sockets && \\\n> -       make && \\\n> -       make install\n> diff --git a/dockerfiles/Dockerfile.ostro b/dockerfiles/Dockerfile.ostro\n> deleted file mode 100644\n> index b68e455..0000000\n> --- a/dockerfiles/Dockerfile.ostro\n> +++ /dev/null\n> @@ -1,24 +0,0 @@\n> -# This file describes the standard way to build an Ostro bitbake builder\n> image\n> -#\n> -# Usage:\n> -#\n> -# docker build -t crops/ostro:builder -f Dockerfile.ostro ..\n> -#\n> -\n> -FROM crops/ostro:deps\n> -MAINTAINER Todor Minchev <todor.minchev@linux.intel.com>\n> -\n> -USER root\n> -\n> -RUN  mkdir -p /ostro/bin && \\\n> -     mkdir -p /ostro/sample-conf && \\\n> -     chmod -R a+rwx /ostro\n> -COPY helpers/runbitbake.py /ostro/bin/runbitbake.py\n> -COPY helpers/startOstroScript.sh /ostro/bin/startOstroScript.sh\n> -COPY confs/ostro/ostro.conf /ostro/sample-conf/ostro.conf\n> -\n> -RUN   chmod +rx /ostro/bin/runbitbake.py && \\\n> -      chmod +rx /ostro/bin/startOstroScript.sh && \\\n> -      git clone https://github.com/ostroproject/ostro-os.git\n> /ostro/ostro-os\n> -\n> -ENTRYPOINT [\"/ostro/bin/startOstroScript.sh\"]\n> diff --git a/dockerfiles/Dockerfile.ostro.deps\n> b/dockerfiles/Dockerfile.ostro.deps\n> deleted file mode 100644\n> index d4da08f..0000000\n> --- a/dockerfiles/Dockerfile.ostro.deps\n> +++ /dev/null\n> @@ -1,33 +0,0 @@\n> -# This file describes the standard way to build the dependencies for\n> Ostro bitbake build image\n> -#\n> -# Usage:\n> -#\n> -# docker build -t crops/ostro:deps -f Dockerfile.ostro.deps .\n> -\n> -FROM debian:jessie\n> -MAINTAINER Todor Minchev <todor.minchev@linux.intel.com>\n> -\n> -# Install dependencies\n> -RUN apt-get update && apt-get upgrade -y && apt-get install -y \\\n> -  gawk \\\n> -  wget \\\n> -  git-core \\\n> -  diffstat \\\n> -  unzip \\\n> -  sysstat \\\n> -  texinfo \\\n> -  gcc-multilib \\\n> -  build-essential \\\n> -  chrpath \\\n> -  socat \\\n> -  python \\\n> -  libsdl1.2-dev  \\\n> -  cpio \\\n> -  sudo  \\\n> -  rsync && \\\n> -  apt-get clean && \\\n> -  echo \"dash dash/sh boolean false\" | debconf-set-selections && \\\n> -  DEBIAN_FRONTEND=noninteractive dpkg-reconfigure dash\n> -\n> -\n> -CMD /bin/bash\n> diff --git a/dockerfiles/Dockerfile.toolchain\n> b/dockerfiles/Dockerfile.toolchain\n> deleted file mode 100644\n> index c03fd90..0000000\n> --- a/dockerfiles/Dockerfile.toolchain\n> +++ /dev/null\n> @@ -1,49 +0,0 @@\n> -# This file describes the standard way to build a CROPS toolchain image\n> -#\n> -# Usage:\n> -#\n> -# 1) Replace the TOOLCHAIN_NAME and TOOLCHAIN_PATH environment variables\n> below with\n> -# the name and URL of your self-extracting toolchain\n> -#\n> -# Example:\n> -#\n> -# ENV TOOLCHAIN_NAME\n> poky-glibc-x86_64-core-image-sato-i586-toolchain-2.0.sh\n> -# ENV TOOLCHAIN_PATH\n> http://downloads.yoctoproject.org/releases/yocto/yocto-2.0/toolchain/x86_64/\n> -#\n> -# 2) Build your toolchain image with the following command replacing\n> my_tag with your target arch\n> -# docker build -t crops/toolchain:my_tag -f Dockerfile.toolchain ../\n> -#\n> -# Example for i586 target:\n> -# docker build -t crops/toolchain:i586 -f Dockerfile.toolchain ../\n> -#\n> -# The default configuration below will build an i586 toolchain for an\n> x86_64 host\n> -\n> -FROM crops/toolchain:deps\n> -MAINTAINER Todor Minchev <todor.minchev@linux.intel.com>\n> -\n> -ENV TOOLCHAIN_NAME\n> poky-glibc-x86_64-core-image-sato-i586-toolchain-2.0.sh\n> -ENV TOOLCHAIN_PATH\n> http://downloads.yoctoproject.org/releases/yocto/yocto-2.0/toolchain/x86_64/\n> -\n> -# Build and install turff\n> -RUN mkdir -p /usr/local/crops/turff/\n> -COPY turff /usr/local/crops/turff/\n> -COPY utils.[ch] /usr/local/crops/\n> -COPY globals.[ch] /usr/local/crops/\n> -\n> -RUN cd /usr/local/crops/turff && \\\n> -       make && \\\n> -       mkdir -p /bin/turff && \\\n> -       cp /usr/local/crops/turff/turff /bin/turff/run && \\\n> -       cp /usr/local/crops/turff/turff_launcher /bin/\n> -\n> -# Download and install toolchain\n> -RUN wget -q -P /tmp ${TOOLCHAIN_PATH}${TOOLCHAIN_NAME} && \\\n> -       cd /tmp &&      \\\n> -       chmod 755 ./${TOOLCHAIN_NAME} &&        \\\n> -       ./${TOOLCHAIN_NAME} -d /opt/poky/ -y\n> -\n> -# Make environment setup script executable and setup workspaces\n> -RUN chmod 755 /opt/poky/environment-setup*\n> -\n> -# Container entry point\n> -ENTRYPOINT [\"/bin/turff_launcher\", \"-f\", \"/opt/poky/environment-setup*\"]\n> diff --git a/dockerfiles/Dockerfile.toolchain.deps\n> b/dockerfiles/Dockerfile.toolchain.deps\n> deleted file mode 100644\n> index ff809e6..0000000\n> --- a/dockerfiles/Dockerfile.toolchain.deps\n> +++ /dev/null\n> @@ -1,18 +0,0 @@\n> -# This file describes the standard way to build the dependencies for CROPS\n> -# toolchain images\n> -#\n> -# Usage:\n> -#\n> -# docker build -t crops/toolchain:deps -f Dockerfile.toolchain.deps .\n> -\n> -FROM debian:wheezy\n> -MAINTAINER Todor Minchev <todor.minchev@linux.intel.com>\n> -\n> -# Install dependencies\n> -RUN apt-get update -qq && apt-get install -y -qq \\\n> -       python  \\\n> -       daemontools \\\n> -       git \\\n> -       build-essential \\\n> -       wget\n> -\n> diff --git a/dockerfiles/Dockerfile.zephyr b/dockerfiles/Dockerfile.zephyr\n> deleted file mode 100644\n> index 32068cb..0000000\n> --- a/dockerfiles/Dockerfile.zephyr\n> +++ /dev/null\n> @@ -1,59 +0,0 @@\n> -# This file describes the standard way to build a Zephyr toolchain image\n> -#\n> -# Usage:\n> -#\n> -# 1) Replace the TOOLCHAIN_NAME and TOOLCHAIN_PATH environment variables\n> below with\n> -# the name and URL of your self-extracting toolchain\n> -#\n> -# Example:\n> -#\n> -# ENV TOOLCHAIN_NAME zephyr-sdk-0.7.2-i686-setup.run\n> -# ENV TOOLCHAIN_PATH\n> https://nexus.zephyrproject.org/content/repositories/releases/org/zephyrproject/zephyr-sdk/0.7.2-i686/\n> -#\n> -# 2) Build your toolchain image with the following command replacing\n> my_tag with your Zephyr's release\n> -# docker build -t crops/zephyr:my_tag -f Dockerfile.zephyr ../\n> -#\n> -# Example for Zephyr SDK 0.7.2:\n> -# docker build -t crops/zephyr:0.7.2-src -f Dockerfile.zephyr ../\n> -#\n> -\n> -FROM crops/zephyr:deps\n> -MAINTAINER Todor Minchev <todor.minchev@linux.intel.com>\n> -\n> -ENV TOOLCHAIN_NAME zephyr-sdk-0.7.2-i686-setup.run\n> -ENV TOOLCHAIN_PATH\n> https://nexus.zephyrproject.org/content/repositories/releases/org/zephyrproject/zephyr-sdk/0.7.2-i686/\n> -\n> -# Build and install turff\n> -RUN mkdir -p /usr/local/crops/turff/\n> -COPY turff /usr/local/crops/turff/\n> -COPY utils.[ch] /usr/local/crops/\n> -COPY globals.[ch] /usr/local/crops/\n> -\n> -RUN cd /usr/local/crops/turff && \\\n> -       make && \\\n> -       mkdir -p /bin/turff && \\\n> -       cp /usr/local/crops/turff/turff /bin/turff/run && \\\n> -       cp /usr/local/crops/turff/turff_launcher /bin/\n> -\n> -# Download and install Zephyr toolchain\n> -RUN wget -q -P /tmp ${TOOLCHAIN_PATH}${TOOLCHAIN_NAME} && \\\n> -       cd /tmp &&      \\\n> -       chmod 755 ./${TOOLCHAIN_NAME} && \\\n> -       ./${TOOLCHAIN_NAME} && \\\n> -       rm -rf ./${TOOLCHAIN_NAME}\n> -\n> -#Linkups\n> -# /bin/sh to bash\n> -# easy to use gdb to various architectures\n> -# NOTE: in future we will probably split these into separate toolchain\n> containers\n> -RUN rm /bin/sh && ln -s /bin/bash /bin/sh && \\\n> -    ln -s\n> /opt/zephyr-sdk/sysroots/i686-pokysdk-linux/usr/bin/i586-poky-elf/i586-poky-elf-gdb\n> /usr/bin/zephyr-i586-gdb && \\\n> -    ln -s\n> /opt/zephyr-sdk/sysroots/i686-pokysdk-linux/usr/bin/arm-poky-eabi/arm-poky-eabi-gdb\n> /usr/bin/zephyr-arm-gdb && \\\n> -    ln -s\n> /opt/zephyr-sdk/sysroots/i686-pokysdk-linux/usr/bin/arc-poky-elf/arc-poky-elf-gdb\n> /usr/bin/zephyr-arc-gdb && \\\n> -    ln -s\n> /opt/zephyr-sdk/sysroots/i686-pokysdk-linux/usr/bin/mips-poky-elf/mips-poky-elf-gdb\n> /usr/bin/zephyr-mips-gdb\n> -\n> -#Create Zephyr bare clone\n> -RUN git clone --bare https://gerrit.zephyrproject.org/r/zephyr\n> /zephyr-src\n> -\n> -# Container entry point\n> -ENTRYPOINT [\"/bin/turff_launcher\"]\n> diff --git a/dockerfiles/Dockerfile.zephyr.deps\n> b/dockerfiles/Dockerfile.zephyr.deps\n> deleted file mode 100644\n> index 4c5aa4f..0000000\n> --- a/dockerfiles/Dockerfile.zephyr.deps\n> +++ /dev/null\n> @@ -1,24 +0,0 @@\n> -# This file describes the standard way to build the dependencies for\n> Zephyr\n> -# toolchain images\n> -#\n> -# Usage:\n> -#\n> -# docker build -t crops/zephyr:deps -f Dockerfile.zephyr.deps .\n> -\n> -FROM debian:wheezy\n> -MAINTAINER Todor Minchev <todor.minchev@linux.intel.com>\n> -\n> -# Install dependencies\n> -RUN apt-get update && apt-get install -y \\\n> -       python  \\\n> -       daemontools \\\n> -       git \\\n> -       make \\\n> -       gcc \\\n> -       gcc-multilib \\\n> -       g++ \\\n> -       libc6-dev-i386 \\\n> -       g++-multilib    \\\n> -       bzip2   \\\n> -       wget\n> -\n> diff --git a/globals.c b/globals.c\n> deleted file mode 100755\n> index 2716495..0000000\n> --- a/globals.c\n> +++ /dev/null\n> @@ -1,47 +0,0 @@\n> -/*\n> - * Copyright (C) 2016 Intel Corporation\n> - *\n> - * Author: Todor Minchev <todor.minchev@linux.intel.com>\n> - *\n> - * This program is free software; you can redistribute it and/or modify it\n> - * under the terms and conditions of the GNU General Public License,\n> - * version 2, or (at your option) any later version, as published by\n> - * the Free Software Foundation.\n> - *\n> - * This program is distributed in the hope it will be useful, but WITHOUT\n> - * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n> - * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n> for\n> - * more details.\n> - */\n> -\n> -#include <stdio.h>\n> -#include <stdlib.h>\n> -#include \"globals.h\"\n> -\n> -void info(const char *file, int line, const char *func, const char* fmt,\n> ...) {\n> -  va_list args;\n> -\n> -  printf(\"[INFO] \");\n> -  va_start(args, fmt);\n> -  vprintf(fmt, args);\n> -  va_end(args);\n> -}\n> -\n> -void debug(const char *file, int line, const char *func, const char* fmt,\n> ...) {\n> -  va_list args;\n> -\n> -  printf(\"[DEBUG] %s:%d: [%s] \", file, line, func);\n> -  va_start(args, fmt);\n> -  vprintf(fmt, args);\n> -  va_end(args);\n> -}\n> -\n> -void error(const char *file, int line, const char *func, const char* fmt,\n> ...) {\n> -  va_list args;\n> -\n> -  printf(\"[ERROR] %s:%d: [%s] \", file, line, func);\n> -  va_start(args, fmt);\n> -  vprintf(fmt, args);\n> -  va_end(args);\n> -  exit(EXIT_FAILURE);\n> -}\n> diff --git a/globals.h b/globals.h\n> deleted file mode 100755\n> index c928166..0000000\n> --- a/globals.h\n> +++ /dev/null\n> @@ -1,69 +0,0 @@\n> -/*\n> - * Copyright (C) 2016 Intel Corporation\n> - *\n> - * Author: Todor Minchev <todor.minchev@linux.intel.com>\n> - *\n> - * This program is free software; you can redistribute it and/or modify it\n> - * under the terms and conditions of the GNU General Public License,\n> - * version 2, or (at your option) any later version, as published by\n> - * the Free Software Foundation.\n> - *\n> - * This program is distributed in the hope it will be useful, but WITHOUT\n> - * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n> - * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n> for\n> - * more details.\n> - */\n> -\n> -#ifndef GLOBALS_H\n> -#define GLOBALS_H\n> -#ifdef __linux\n> -#define _GNU_SOURCE\n> -#endif\n> -\n> -\n> -#include <math.h>\n> -#include <stdarg.h>\n> -#include <stdint.h>\n> -#include <stdio.h>\n> -#include <string.h>\n> -#include <unistd.h>\n> -\n> -#define KEY_ARR_SZ 'z' -'a' + 1\n> -#define KEY(var) abs('a'- #var[1])\n> -\n> -\n> -#define CODI_PORT      \"10000\"\n> -#define CODI_IP_NATIVE \"127.0.0.1\"\n> -#define CODI_IP_VIRT   \"192.168.99.100\"\n> -#define TURFF_PORT     \"9999\"\n> -#define MSG_TERM       \"EOM\"\n> -#define VERSION        \"0.1\"\n> -#define TURFF_EOM      \"TEOM\"\n> -#define CEED_NAME      \"ceed\"\n> -#define TURFF_NAME     \"turff\"\n> -#define CODI_NAME      \"codi\"\n> -#define TURFFID        \"TURFFID\"\n> -\n> -void info(const char *file, int line, const char *func, const char* fmt,\n> ...);\n> -void debug(const char *file, int line, const char *func, const char* fmt,\n> ...);\n> -void error(const char *file, int line, const char *func, const char* fmt,\n> ...);\n> -\n> -#define INFO(...)  info(__FILE__, __LINE__, __func__, __VA_ARGS__)\n> -#define ERR(...) error(__FILE__, __LINE__, __func__, __VA_ARGS__)\n> -#define DEBUG(...) debug(__FILE__, __LINE__, __func__, __VA_ARGS__)\n> -\n> -typedef enum { false, true } bool;\n> -\n> -/* parameter chunk*/\n> -typedef struct chunk{\n> -  uint32_t op_code;\n> -  char arg[20];\n> -  struct chunk *next;\n> -} msg_chunk;\n> -\n> -typedef struct{\n> -  char  *mem;\n> -  size_t size;\n> -} curl_mem_chunk_t;\n> -\n> -#endif\n> diff --git a/helpers/runbitbake.py b/helpers/runbitbake.py\n> deleted file mode 100644\n> index 96c55dc..0000000\n> --- a/helpers/runbitbake.py\n> +++ /dev/null\n> @@ -1,148 +0,0 @@\n> -#!/usr/bin/python\n> -\n> -# runbitbake.py\n> -#\n> -# Copyright (C) 2016 Intel Corporation\n> -#\n> -# This program is free software; you can redistribute it and/or modify\n> -# it under the terms of the GNU General Public License version 2 as\n> -# published by the Free Software Foundation.\n> -#\n> -# This program is distributed in the hope that it will be useful,\n> -# but WITHOUT ANY WARRANTY; without even the implied warranty of\n> -# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n> -# GNU General Public License for more details.\n> -#\n> -# You should have received a copy of the GNU General Public License along\n> -# with this program; if not, write to the Free Software Foundation, Inc.,\n> -# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n> -\n> -import argparse\n> -import subprocess\n> -import os\n> -import tempfile\n> -import shutil\n> -import sys\n> -import signal\n> -\n> -bitbake_process = None\n> -\n> -old_handler = {}\n> -old_handler[str(signal.SIGINT)] = signal.getsignal(signal.SIGINT)\n> -old_handler[str(signal.SIGTERM)] = signal.getsignal(signal.SIGTERM)\n> -\n> -\n> -def addextra(tempdir, builddir, name, extralist):\n> -    myf = \"{}/conf/{}\".format(builddir, name)\n> -    myf_orig = \"{}/{}.orig\".format(tempdir, name)\n> -    tmpfile = \"{}/{}.orig.tmp\".format(tempdir, name)\n> -\n> -    # copy isn't atomic so make sure that orig is created atomically so\n> that\n> -    # file.orig is always correct even if file gets hosed. So that\n> -    # means if a user ever sees file.orig, they can be assured that it\n> -    # is the same as the original file with no corruption.\n> -    shutil.copyfile(myf, tmpfile)\n> -    with open(tmpfile, \"r\") as f:\n> -        fd = f.fileno()\n> -        os.fdatasync(fd)\n> -\n> -    # Remember first sync the file AND directory to make sure data\n> -    # is written out\n> -    fd = os.open(os.path.dirname(tmpfile), os.O_RDONLY)\n> -    os.fsync(fd)\n> -    os.close(fd)\n> -\n> -    # Rename should be atomic with respect to disk, yes all of this\n> assumes\n> -    # linux and possibly non-network filesystems.\n> -    os.rename(tmpfile, myf_orig)\n> -\n> -    with open(myf, \"a\") as f:\n> -        if extralist:\n> -            for conf in extralist:\n> -                with open(conf) as f2:\n> -                    content = f2.readlines()\n> -                for l in content:\n> -                    f.write(\"%s\\n\" % format(l.strip()))\n> -\n> -\n> -def restore_files(tempdir, builddir, conffiles):\n> -    for f in conffiles:\n> -        dest = os.path.join(builddir, \"conf\", f)\n> -        src = os.path.join(tempdir, f + \".orig\")\n> -\n> -        if os.path.exists(src):\n> -            os.rename(src, dest)\n> -\n> -\n> -# If bitbake is around let it do all the signal handling\n> -def handler(signum, frame):\n> -    if bitbake_process:\n> -        # SIGINT is special if there is a tty. Because with a tty SIGINT\n> will\n> -        # automatically get sent to all processes in the process group.\n> So we\n> -        # don't need to send it ourselves.\n> -        if signum == signal.SIGINT and sys.stdin.isatty():\n> -            pass\n> -        else:\n> -            # If there is a bitbake process we want to let it tear down\n> all\n> -            # its children itself so send the signal to bitbake.\n> -            bitbake_process.send_signal(signum)\n> -    else:\n> -        old_handler[str(signum)](signum, frame)\n> -\n> -\n> -if __name__ == '__main__':\n> -    signal.signal(signal.SIGINT, handler)\n> -    signal.signal(signal.SIGTERM, handler)\n> -\n> -    parser = argparse.ArgumentParser()\n> -\n> -    parser.add_argument(\"--extraconf\", action='append', help=\"File\n> containing\"\n> -                        \"extra configuration\")\n> -    parser.add_argument(\"--extralayers\", action='append',\n> -                        help=\"File containing extra bblayers\")\n> -\n> -    parser.add_argument(\"--pokydir\", default=\"/home/yoctouser/poky\",\n> -                        required=True, help=\"Directory containing poky\")\n> -    parser.add_argument(\"--target\", \"-t\", required=True,\n> -                        help=\"What bitbake should build\")\n> -    parser.add_argument(\"--builddir\", \"-b\", required=True,\n> -                        help=\"Directory to build in\")\n> -\n> -    args = parser.parse_args()\n> -\n> -    builddir = args.builddir\n> -\n> -    if not os.path.isdir(builddir):\n> -        os.makedirs(builddir)\n> -\n> -    # tempdir is a subdirectory of builddir in case builddir and\n> local.conf\n> -    # already existed. Then if something goes wrong with local.conf the\n> user\n> -    # can restore it by using builddir/tempdir/local.conf.orig\n> -    tempdir = tempfile.mkdtemp(prefix=\"runbitbake-tmpdir\", dir=builddir)\n> -\n> -    # Have to use bash since the default on ubuntu is dash which is\n> garbage\n> -    try:\n> -        cmd = 'bash -c \". {}/oe-init-build-env {}\"'.format(args.pokydir,\n> -                                                           builddir)\n> -        subprocess.check_call(cmd, stdout=sys.stdout, stderr=sys.stderr,\n> -                              shell=True)\n> -\n> -        try:\n> -            addextra(tempdir, builddir, \"local.conf\", args.extraconf)\n> -            addextra(tempdir, builddir, \"bblayers.conf\", args.extralayers)\n> -\n> -            cmd = '. {}/oe-init-build-env {} && '.format(args.pokydir,\n> -                                                         builddir)\n> -            cmd += 'exec bitbake {}'.format(args.target)\n> -            bitbake_process = subprocess.Popen(['/bin/bash', '-c', cmd],\n> -                                               stdout=sys.stdout,\n> -                                               stderr=sys.stderr,\n> shell=False)\n> -            bitbake_process.wait()\n> -        finally:\n> -            restore_files(tempdir, builddir, [\"local.conf\",\n> \"bblayers.conf\"])\n> -\n> -    except subprocess.CalledProcessError as e:\n> -        print e\n> -\n> -    finally:\n> -        shutil.rmtree(tempdir, ignore_errors=True)\n> diff --git a/helpers/startOstroScript.sh b/helpers/startOstroScript.sh\n> deleted file mode 100644\n> index 49a1dd1..0000000\n> --- a/helpers/startOstroScript.sh\n> +++ /dev/null\n> @@ -1,42 +0,0 @@\n> -#!/bin/bash\n> -POKY_DIR=/ostro/ostro-os/\n> -EXTRA_CONF=/ostro/ostro-shared/conf/ostro.conf\n> -BUILD_DIR=/ostro/build/\n> -EXTRA_LAYERS=/ostro/ostro-shared/conf/ostro.layers\n> -\n> -H_UID=$(ls -al /ostro/ostro-shared/ | egrep \"\\.\"|egrep -v \"\\.\\.\" | awk\n> '{print $3}')\n> -H_USER=$(getent passwd \"$H_UID\" | cut -d: -f1)\n> -if [ \"$H_USER\" == \"\" ]; then\n> -    H_USER=\"yoctobuilder\"\n> -    /usr/sbin/useradd -m -u ${H_UID} ${H_USER}\n> -fi\n> -\n> -# provide the ostro.conf if there isn't one yet\n> -if [ ! -f ${EXTRA_CONF} ]; then\n> -    mkdir -p /ostro/ostro-shared/conf\n> -    cp /ostro/sample-conf/ostro.conf ${EXTRA_CONF}\n> -fi\n> -\n> -# provide ostro.layers if there isn't one yet\n> -if [ ! -f ${EXTRA_LAYERS} ]; then\n> -    mkdir -p /ostro/ostro-shared/conf\n> -    cp /ostro/sample-conf/ostro.layers ${EXTRA_LAYERS}\n> -fi\n> -\n> -mkdir -p /ostro/ostro-shared/images/\n> -chmod a+rwx /ostro/ostro-shared/images/\n> -chmod a+rwx /ostro/ostro-shared/conf\n> -chmod a+rw  ${EXTRA_CONF}\n> -\n> -\n> -# switch into user to build\n> -sudo  --user ${H_USER} /ostro/bin/runbitbake.py --pokydir $POKY_DIR\n> --extraconf $EXTRA_CONF --extralayers $EXTRA_LAYERS -b $BUILD_DIR -t $*\n> -echo \"copying images to shared folder\"\n> -\n> -# we need to source the bitbake env in order to use the bitbake script to\n> find the images\n> -cd ${BUILD_DIR}\n> -source ${POKY_DIR}/oe-init-build-env >> /dev/null\n> -CON_DIR=`bitbake -e | egrep \"DEPLOY_DIR_IMAGE\\=\"|tr \"\\=\" \" \" | tr -d\n> \"\\\"\"| awk '{print $2}'`\n> -rsync -a ${CON_DIR} /ostro/ostro-shared/images/ > /dev/null 2>&1\n> -\n> -\n> diff --git a/installers/ostro-installer.sh b/installers/ostro-installer.sh\n> deleted file mode 100644\n> index 05eca6a..0000000\n> --- a/installers/ostro-installer.sh\n> +++ /dev/null\n> @@ -1,108 +0,0 @@\n> -#!/bin/bash\n> -\n> -if [[ \"$(basename -- \"$0\")\" == \"ostro-installer.sh\" ]]; then\n> -  echo -e \"$0 has to be sourced not run\" >&2;\n> -  echo -e \"\\nExample:\\nsource $0\\n\"; exit 1\n> -fi\n> -\n> -OSTRO_IMG=crops/ostro:builder\n> -OSTRO_CONTAINER=ostro-builder\n> -OSTRO_CONF=$HOME/ostro-workspace/shared/conf/ostro.conf\n> -BITBAKE_WRAPPER=$HOME/.crops/bitbake.ostro\n> -WIN_PLATFORM=\"msys\"\n> -LINUX_PLATFORM=\"linux\"\n> -MAC_PLATFORM=\"darwin\"\n> -unset MY_PLATFORM\n> -\n> -# establish platform\n> -if [[ \"echo \"${OSTYPE}\" | tr '[:upper:]' '[:lower:]'\" = *$LINUX_PLATFORM*\n> ]]; then\n> -  MY_PLATFORM=$LINUX_PLATFORM\n> -elif [[ \"echo \"${OSTYPE}\" | tr '[:upper:]' '[:lower:]'\" ==\n> *$MAC_PLATFORM* ]]; then\n> -  MY_PLATFORM=$MAC_PLATFORM\n> -elif [[ \"echo \"${OSTYPE}\" | tr '[:upper:]' '[:lower:]'\" ==\n> *$WIN_PLATFORM* ]]; then\n> -  MY_PLATFORM=$WIN_PLATFORM\n> -else\n> -  echo \"Unknown platform: $OSTYPE. Exiting\"; return 1\n> -fi\n> -echo -e \"\\nPlatform is $MY_PLATFORM\"\n> -\n> -if [ \"`which docker`\" = \"\" ]; then\n> -  echo -e \"\\nPlease install docker first, then run this installer\"\n> -  if [[ $MY_PLATFORM = $LINUX_PLATFORM ]]; then\n> -    echo -e \"\\nFrom: https://docs.docker.com/linux/step_one/\"\n> -  else\n> -    echo -e \"\\nFrom: https://www.docker.com/products/docker-toolbox\"\n> -  fi\n> -  return 1\n> -fi\n> -\n> -echo -e \"\\n\"\n> -read -p \"This will remove existing OSTRO build containers. Answering No\n> will exit the installer. Proceed? Y/N \" -r\n> -echo\n> -if [[ ! $REPLY =~ ^[Yy]$ ]]\n> -then\n> -  echo \"There is nothing for me to do. Exiting\"; return 1\n> -else\n> -  echo -e \"\\nRemove existing OSTRO build containers\"\n> -  docker ps -a | awk '{ print $1,$2 }' | grep $OSTRO_IMG | awk '{print $1\n> }' | xargs -I {} docker rm -f {}\n> -  echo -e \"Done\"\n> -fi\n> -\n> -if [[ \"$(docker images -q $OSTRO_IMG 2> /dev/null)\" != \"\" ]]; then\n> -  read -p \"OSTRO build image found. Download latest OSTRO build image?\n> Y/N \" -r; echo\n> -  if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n> -    if [[ \"$(docker images -q $OSTRO_IMG 2> /dev/null)\" == \"\" ]]; then\n> -      echo \"OSTRO build image not found. Exiting installer\"; return 1\n> -    fi\n> -  else\n> -    echo -e \"\\nRemove existing OSTRO build image\"\n> -    docker rmi $OSTRO_IMG 2> /dev/null\n> -    echo -e \"Done\"\n> -\n> -    echo -e \"\\nDownloading OSTRO build image. Please wait\"\n> -    docker pull $OSTRO_IMG\n> -    echo -e \"Done\"\n> -  fi\n> -else\n> -  read -p \"Download OSTRO build image? Y/N \" -r\n> -  echo\n> -  if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n> -    if [[ \"$(docker images -q $OSTRO_IMG 2> /dev/null)\" == \"\" ]]; then\n> -      echo \"OSTRO build image not found. Exiting installer\"; return 1\n> -    fi\n> -  else\n> -    echo -e \"\\nDownloading OSTRO build image. Please wait\"\n> -    docker pull $OSTRO_IMG\n> -    echo -e \"Done\"\n> -  fi\n> -fi\n> -\n> -if [[ \"$(docker images -q $OSTRO_IMG 2> /dev/null)\" == \"\" ]]; then\n> -  echo \"OSTRO build image not found. Exiting installer\"; return 1\n> -fi\n> -\n> -mkdir -p $HOME/.crops\n> -\n> -if [[ -f \"$BITBAKE_WRAPPER\" ]]; then\n> -  read -p \"OSTRO bitbake wrapper found. Do you want to reinstall bitbake\n> wrapper? Y/N \" -r; echo\n> -  if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n> -    echo -e \"\\nOSTRO bitbake wrapper was not updated\"\n> -  else\n> -    rm -rf $BITBAKE_WRAPPER\n> -         echo -e \"Downloading default OSTRO bitbake wrapper\"\n> -    curl -k -s -o $BITBAKE_WRAPPER\n> https://raw.githubusercontent.com/crops/crops/master/scripts/bitbake.ostro\n> -    chmod 755 $BITBAKE_WRAPPER\n> -    echo -e \"Done.\"\n> -  fi\n> -else\n> -  echo -e \"Downloading OSTRO bitbake wrapper\"\n> -  curl -k -s -o $BITBAKE_WRAPPER\n> https://raw.githubusercontent.com/crops/crops/master/scripts/bitbake.ostro\n> -  chmod 755 $BITBAKE_WRAPPER\n> -  echo -e \"Done.\"\n> -fi\n> -export PATH=$PATH:$HOME/.crops\n> -\n> -echo -e \"\\n\\nTHE OSTRO BUILD ENVIRONMENT HAS BEEN SET UP\"\n> -\n> -echo -e \"\\nYou can now build ostro-os from the CLI\\n\"\n> -echo -e \"Example :\\nbitbake.ostro ostro-image-noswupd\\n\"\n> diff --git a/installers/zephyr-installer.sh\n> b/installers/zephyr-installer.sh\n> deleted file mode 100755\n> index 2afb4cf..0000000\n> --- a/installers/zephyr-installer.sh\n> +++ /dev/null\n> @@ -1,225 +0,0 @@\n> -#!/bin/bash\n> -\n> -if [[ \"$(basename -- \"$0\")\" == \"zephyr-installer.sh\" ]]; then\n> -  echo -e \"$0 has to be sourced not run\" >&2;\n> -  echo -e \"\\nExample:\\nsource $0\\n\"; exit 1\n> -fi\n> -\n> -CODI_IMG=crops/codi:latest\n> -CODI_CONTAINER=codi\n> -ZEPHYR_IMG=crops/zephyr:latest\n> -ZEPHYR_CONTAINER=crops-zephyr-0-7-2-src\n> -VM_NAME=default\n> -CEED_EXE=$HOME/.crops/ceed/ceed\n> -MAKE_PATH=$HOME/.crops\n> -WIN_PLATFORM=\"msys\"\n> -LINUX_PLATFORM=\"linux\"\n> -MAC_PLATFORM=\"darwin\"\n> -unset MY_PLATFORM\n> -\n> -# establish platform\n> -if [[ \"echo \"${OSTYPE}\" | tr '[:upper:]' '[:lower:]'\" = *$LINUX_PLATFORM*\n> ]]; then\n> -  MY_PLATFORM=$LINUX_PLATFORM\n> -elif [[ \"echo \"${OSTYPE}\" | tr '[:upper:]' '[:lower:]'\" ==\n> *$MAC_PLATFORM* ]]; then\n> -  MY_PLATFORM=$MAC_PLATFORM\n> -elif [[ \"echo \"${OSTYPE}\" | tr '[:upper:]' '[:lower:]'\" ==\n> *$WIN_PLATFORM* ]]; then\n> -  MY_PLATFORM=$WIN_PLATFORM\n> -else\n> -  echo \"Unknown platform: $OSTYPE. Exiting\"; return 1\n> -fi\n> -echo -e \"\\nPlatform is $MY_PLATFORM\"\n> -\n> -if [ \"`which docker`\" = \"\" ]; then\n> -  echo -e \"\\nPlease install docker first, then run this installer\"\n> -  if [[ $MY_PLATFORM = $LINUX_PLATFORM ]]; then\n> -    echo -e \"\\nFrom: https://docs.docker.com/linux/step_one/\"\n> -  else\n> -    echo -e \"\\nFrom: https://www.docker.com/products/docker-toolbox\"\n> -  fi\n> -  return 1\n> -fi\n> -\n> -echo -e \"\\n\"\n> -read -p \"This will remove existing CROPS containers. Answering No will\n> exit the installer. Proceed? Y/N \" -r\n> -echo\n> -if [[ ! $REPLY =~ ^[Yy]$ ]]\n> -then\n> -  echo \"There is nothing for me to do. Exiting\"; return 1\n> -else\n> -  echo -e \"\\nRemove existing CODI containers\"\n> -  docker ps -a | awk '{ print $1,$2 }' | grep $CODI_IMG | awk '{print $1\n> }' | xargs -I {} docker rm -f {}\n> -  echo -e \"Done\"\n> -\n> -  echo -e \"\\nRemove existing Zephyr container\"\n> -  docker ps -a | awk '{ print $1,$2 }' | grep $ZEPHYR_IMG | awk '{print\n> $1 }' | xargs -I {} docker rm -f {}\n> -  echo -e \"Done\"\n> -fi\n> -\n> -if [[ \"$(docker images -q $CODI_IMG 2> /dev/null)\" != \"\" ]]; then\n> -  read -p \"CODI image found. Download latest CODI image? Y/N \" -r; echo\n> -  if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n> -    if [[ \"$(docker images -q $CODI_IMG 2> /dev/null)\" == \"\" ]]; then\n> -      echo \"CODI image not found. Exiting installer\"; return 1\n> -    fi\n> -  else\n> -    echo -e \"\\nRemove existing CODI image\"\n> -    docker rmi $CODI_IMG 2> /dev/null\n> -    echo -e \"Done\"\n> -\n> -    echo -e \"\\nDownloading CODI image. Please wait\"\n> -    docker pull $CODI_IMG\n> -    echo -e \"Done\"\n> -  fi\n> -else\n> -  read -p \"Download CODI image? Y/N \" -r\n> -  echo\n> -  if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n> -    if [[ \"$(docker images -q $CODI_IMG 2> /dev/null)\" == \"\" ]]; then\n> -      echo \"CODI image not found. Exiting installer\"; return 1\n> -    fi\n> -  else\n> -    echo -e \"\\nDownloading CODI image. Please wait\"\n> -    docker pull $CODI_IMG\n> -    echo -e \"Done\"\n> -  fi\n> -fi\n> -\n> -if [[ \"$(docker images -q $ZEPHYR_IMG 2> /dev/null)\" != \"\" ]]; then\n> -  read -p \"Zephyr toolchain found. Download latest Zephyr toolchain? Y/N\n> \" -r; echo\n> -  if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n> -    if [[ \"$(docker images -q $ZEPHYR_IMG 2> /dev/null)\" == \"\" ]]; then\n> -      echo \"Zephyr toolchain not found. Exiting installer\"; return 1\n> -    fi\n> -  else\n> -    echo -e \"\\nRemove existing Zephyr toolchain\"\n> -    docker rmi $ZEPHYR_IMG 2> /dev/null\n> -    echo -e \"Done\"\n> -\n> -    echo -e \"\\nDownloading Zephyr toolchain. Please wait\"\n> -    docker pull $ZEPHYR_IMG\n> -    echo -e \"Done\"\n> -  fi\n> -else\n> -  read -p \"Download Zephyr toolchain? Y/N \" -r; echo\n> -  if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n> -    if [[ \"$(docker images -q $ZEPHYR_IMG 2> /dev/null)\" == \"\" ]]; then\n> -      echo \"Zephyr toolchain not found. Exiting installer\"; return 1\n> -    fi\n> -  else\n> -    echo -e \"\\nDownloading Zephyr toolchain. Please wait\"\n> -    docker pull $ZEPHYR_IMG\n> -    echo -e \"Done\"\n> -  fi\n> -fi\n> -\n> -echo -e \"\\nLaunching CODI container\"\n> -docker run -d --name $CODI_CONTAINER -v\n> //var//run//docker.sock://var//run//docker.sock \\\n> -  --net=host $CODI_IMG || { echo 'Couldn't start $CODI_CONTAINER\\' ;\n> return 1; }\n> -echo -e \"Done\"\n> -\n> -echo -e \"\\nLaunching Zephyr toolchain\"\n> -docker run -d --name $ZEPHYR_CONTAINER  -e TURFFID=$ZEPHYR_CONTAINER -v\n> $HOME/crops-workspace:/crops \\\n> -  --net=host $ZEPHYR_IMG || { echo 'Couldn't start $ZEPHYR_CONTAINER\\' ;\n> return 1; }\n> -echo -e \"Done\"\n> -\n> -mkdir -p $HOME/crops-workspace;\n> -\n> -if [[ $MY_PLATFORM == $MAC_PLATFORM ]]; then\n> -  if [[ ! -f \"$CEED_EXE\" ]]; then\n> -    echo -e \"Downloading CEED executable for Mac...\"\n> -    mkdir -p $HOME/.crops/ceed/\n> -    curl -s -o $CEED_EXE http://crops.minchev.co.uk/ceed/mac/ceed\n> -    chmod 755 $CEED_EXE\n> -    echo -e \"Done.\"\n> -  fi\n> -\n> -  if [[ ! -f \"$MAKE_PATH/make.zephyr\" ]]; then\n> -    echo -e \"Downloading Zephyr CLI make utility...\"\n> -    curl -s -o $MAKE_PATH/make.zephyr\n> https://raw.githubusercontent.com/todorez/crops/master/scripts/make.zephyr\n> -    chmod 755 $MAKE_PATH/make.zephyr\n> -    echo -e \"Done.\"\n> -  fi\n> -else\n> -  if [[ -f \"$CEED_EXE\" ]]; then\n> -    read -p \"CEED found. Do you want to reinstall CEED? Y/N \" -r; echo\n> -    if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n> -      echo -e \"\\nCEED executable was not updated\"\n> -    else\n> -      echo -e \"\\nRemove existing CEED executable\"\n> -      rm -rf $CEED_EXE\n> -      echo -e \"Done\"\n> -\n> -      git clone https://github.com/todorez/crops.git; cd\n> crops/dockerfiles;\n> -      if [[ $MY_PLATFORM == $WIN_PLATFORM ]]; then\n> -        echo -e \"\\nBuilding CEED executable\"\n> -        docker ps -a -q --filter \"name=ceed-windows\" | awk '{print $1}' |\n> xargs -I {} docker rm -f {}\n> -        docker images -q --filter \"label=name=ceed-windows\" | awk '{print\n> $1}' | xargs -I {} docker rmi {}\n> -        docker build -t crops/ceed:windows -f Dockerfile.ceed.win ../\n> -        docker run --name=ceed-windows crops/ceed:windows;\n> -        docker-machine ssh default \"docker cp\n> ceed-windows:/usr/local/crops/ceed/ceed $CEED_EXE\";\n> -        docker ps -a -q --filter \"name=ceed-windows\" | awk '{print $1}' |\n> xargs -I {} docker rm -f {}\n> -        docker images -q --filter \"label=name=ceed-windows\" | awk '{print\n> $1}' | xargs -I {} docker rmi {}\n> -        echo -e \"Done\"\n> -      else\n> -        echo -e \"\\nBuilding CEED executable\"\n> -        docker ps -a -q --filter \"name=ceed-linux\" | awk '{print $1}' |\n> xargs -I {} docker rm -f {}\n> -        docker images -q --filter \"label=name=ceed-linux\" | awk '{print\n> $1}' | xargs -I {} docker rmi {}\n> -        docker build -t crops/ceed:linux -f Dockerfile.ceed.linux ../\n> -        docker run --name=ceed-linux crops/ceed:linux;\n> -        docker cp ceed-linux:/usr/local/crops/ceed/ceed $CEED_EXE;\n> -        docker ps -a -q --filter \"name=ceed-linux\" | awk '{print $1}' |\n> xargs -I {} docker rm -f {}\n> -        docker images -q --filter \"label=name=ceed-linux\" | awk '{print\n> $1}' | xargs -I {} docker rmi {}\n> -      fi\n> -      cd ../../; cp -fp ./crops/scripts/make.zephyr $MAKE_PATH/\n> -      cp -fp ./crops/scripts/gdb.zephyr $MAKE_PATH/; rm -rf ./crops\n> -    fi\n> -  else\n> -    read -p \"Do you want to install CEED? Y/N \" -r; echo\n> -    if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n> -      echo -e \"\\nExiting installer. Your install is incomplete.\"; return 1\n> -    else\n> -      mkdir -p $HOME/.crops/ceed\n> -      git clone https://github.com/todorez/crops.git; cd\n> crops/dockerfiles;\n> -      if [[ $MY_PLATFORM == $WIN_PLATFORM ]]; then\n> -        echo -e \"\\nBuilding CEED executable\"\n> -        docker ps -a -q --filter \"name=ceed-windows\" | awk '{print $1}' |\n> xargs -I {} docker rm -f {}\n> -        docker images -q --filter \"label=name=ceed-windows\" | awk '{print\n> $1}' | xargs -I {} docker rmi {}\n> -        docker build -t crops/ceed:windows -f Dockerfile.ceed.win ../\n> -        docker run --name=ceed-windows crops/ceed:windows;\n> -        docker-machine ssh default \"docker cp\n> ceed-windows:/usr/local/crops/ceed/ceed $CEED_EXE\";\n> -        docker ps -a -q --filter \"name=ceed-windows\" | awk '{print $1}' |\n> xargs -I {} docker rm -f {}\n> -        docker images -q --filter \"label=name=ceed-windows\" | awk '{print\n> $1}' | xargs -I {} docker rmi {}\n> -        echo -e \"Done\"\n> -      else\n> -        echo -e \"\\nBuilding CEED executable\"\n> -        docker ps -a -q --filter \"name=ceed-linux\" | awk '{print $1}' |\n> xargs -I {} docker rm -f {}\n> -        docker images -q --filter \"label=name=ceed-linux\" | awk '{print\n> $1}' | xargs -I {} docker rmi {}\n> -        docker build -t crops/ceed:linux -f Dockerfile.ceed.linux ../\n> -        docker run --name=ceed-linux crops/ceed:linux;\n> -        docker cp ceed-linux:/usr/local/crops/ceed/ceed $CEED_EXE;\n> -        docker ps -a -q --filter \"name=ceed-linux\" | awk '{print $1}' |\n> xargs -I {} docker rm -f {}\n> -        docker images -q --filter \"label=name=ceed-linux\" | awk '{print\n> $1}' | xargs -I {} docker rmi {}\n> -        echo -e \"Done\"\n> -      fi\n> -      cd ../../; cp -fp ./crops/scripts/make.zephyr $MAKE_PATH/;\n> -      cp -fp ./crops/scripts/gdb.zephyr $MAKE_PATH/; rm -rf ./crops\n> -    fi\n> -  fi\n> -fi\n> -\n> -echo -e \"\\n\\nTHE CROPS ENVIRONMENT HAS BEEN SET UP\"\n> -\n> -if [[ $MY_PLATFORM != $LINUX_PLATFORM ]]; then\n> -  MACHINE=`docker-machine active`\n> -  IP=`docker-machine ip $MACHINE`\n> -  CEED_EXE=\"$CEED_EXE -i $IP\"\n> -fi\n> -\n> -echo -e \"\\nInitialize Zephyr environment for CLI use\"\n> -echo -e \"Example :\\n${CEED_EXE} -d ${ZEPHYR_CONTAINER} -g \\\"git clone\n> --branch v1.0.0 /zephyr-src /crops/zephyr-project/\\\"\"\n> -\n> -echo -e \"\\nYou can now build Zephyr applications from the CLI\"\n> -echo -e \"Example :\\n$MAKE_PATH/make.zephyr BOARD=arduino_101 -C\n> /crops/zephyr-project/samples/nanokernel/apps/hello_world/\"\n> -\n> -export CEED_EXE=$CEED_EXE\n> -export ZEPHYR_CONTAINER=$ZEPHYR_CONTAINER\n> diff --git a/scripts/bitbake.ostro b/scripts/bitbake.ostro\n> deleted file mode 100755\n> index a7fba2a..0000000\n> --- a/scripts/bitbake.ostro\n> +++ /dev/null\n> @@ -1,12 +0,0 @@\n> -#!/usr/bin/env bash\n> -\n> -OSTRO_CONTAINER=ostro-builder\n> -OSTRO_IMG=crops/ostro:builder\n> -\n> -DOCKER_CMD=\"docker run --rm --name $OSTRO_CONTAINER -v\n> `pwd`/ostro-shared:/ostro/ostro-shared --net=host $OSTRO_IMG\"\n> -PARAMS=$1\n> -\n> -# make sure the shared directory exists\n> -mkdir -p `pwd`/ostro-shared\n> -${DOCKER_CMD} ${PARAMS} || { echo -e \"\\nCouldn't start $OSTRO_CONTAINER\n> container\\n\" ; exit 1; }\n> -\n> diff --git a/scripts/build_ceed b/scripts/build_ceed\n> deleted file mode 100755\n> index a181b2d..0000000\n> --- a/scripts/build_ceed\n> +++ /dev/null\n> @@ -1,11 +0,0 @@\n> -#!/usr/bin/env bash\n> -set -e\n> -set -o pipefail\n> -\n> -# This is a convenience script to build the host side ceed for travis\n> testing.\n> -# this is probably a more travisy way to do this so if you know it, speak\n> up!\n> -\n> -TOPDIR=`git rev-parse --show-toplevel`\n> -\n> -cd ${TOPDIR}/ceed\n> -make\n> diff --git a/scripts/build_containers b/scripts/build_containers\n> deleted file mode 100755\n> index 4335d8b..0000000\n> --- a/scripts/build_containers\n> +++ /dev/null\n> @@ -1,73 +0,0 @@\n> -#!/usr/bin/env bash\n> -set -e\n> -set -o pipefail\n> -\n> -# This is a sanity test script for the CODI and toolchain Docker images.\n> -# This removes the old test containers, and builds a new codi and new\n> toolchains.\n> -# If you do not have the deps containers, it will build them but this\n> takes awhile\n> -#\n> -# Example:\n> -#\n> -# ./tests/build_containers\n> -\n> -TOPDIR=`git rev-parse --show-toplevel`\n> -\n> -# remove codi test image as we will rebuild it\n> -Q=`docker images  -q crops/codi:test`\n> -if [ \"$Q\"  != \"\" ]; then\n> -    echo \"Removing codi image\"\n> -    docker rmi -f $Q\n> -fi\n> -\n> -Q=`docker images  -q crops/codi:testdebug`\n> -if [ \"$Q\"  != \"\" ]; then\n> -    echo \"Removing codi debug image\"\n> -    docker rmi -f $Q\n> -fi\n> -\n> -# remove toolchain test image as we will rebuild it\n> -Q=`docker images  -q crops/toolchain:test`\n> -if [ \"$Q\"  != \"\" ]; then\n> -    echo \"Removing toolchain image\"\n> -    docker rmi -f   $Q\n> -fi\n> -\n> -# remove Zephyr toolchain image as we will rebuild it\n> -Q=`docker images  -q crops/zephyr:test`\n> -if [ \"$Q\"  != \"\" ]; then\n> -    echo \"Removing Zephyr toolchain image\"\n> -    docker rmi -f   $Q\n> -fi\n> -\n> -cd ${TOPDIR}/dockerfiles;\n> -\n> -Q=`docker images  -q crops/codi:deps`\n> -if [ \"$Q\"  == \"\" ]; then\n> -    echo \"Build CODI deps image\"\n> -    docker build -t crops/codi:deps -f Dockerfile.codi.deps --rm=true ..\n> -fi\n> -\n> -\n> -echo \"Build CODI test image\"\n> -docker build -t crops/codi:test -f Dockerfile.codi --rm=true ..\n> -\n> -echo \"Build CODI debug test image\"\n> -docker build -t crops/codi:testdebug --build-arg build_type=debug -f\n> Dockerfile.codi --rm=true ..\n> -\n> -Q=`docker images  -q crops/toolchain:deps`\n> -if [ \"$Q\"  == \"\" ]; then\n> -    echo \"Build toolchain deps image\"\n> -    docker build -t crops/toolchain:deps -f Dockerfile.toolchain.deps\n> --rm=true ..\n> -fi\n> -\n> -echo \"Build toolchain test image\"\n> -docker build -t crops/toolchain:test -f Dockerfile.toolchain --rm=true ..\n> -\n> -Q=`docker images  -q crops/zephyr:deps`\n> -if [ \"$Q\"  == \"\" ]; then\n> -    echo \"Build Zephyr deps image\"\n> -    docker build -t crops/zephyr:deps -f Dockerfile.zephyr.deps\n> --rm=true ..\n> -fi\n> -\n> -echo \"Build Zephyr toolchain image\"\n> -docker build -t crops/zephyr:test -f Dockerfile.zephyr --rm=true ..\n> diff --git a/scripts/build_containers.ostro\n> b/scripts/build_containers.ostro\n> deleted file mode 100755\n> index 15019bc..0000000\n> --- a/scripts/build_containers.ostro\n> +++ /dev/null\n> @@ -1,35 +0,0 @@\n> -#!/usr/bin/env bash\n> -set -e\n> -set -o pipefail\n> -\n> -\n> -# This removes the old test containers, and builds a new ostro container.\n> -# If you do not have the deps containers, it will build them but this\n> takes awhile\n> -# it does NOT remove the deps images\n> -#\n> -# Example:\n> -#\n> -# ./scripts/build_containers.ostro\n> -\n> -TOPDIR=`git rev-parse --show-toplevel`\n> -\n> -# remove ostro builder image as we will rebuild it\n> -Q=`docker images  -q crops/ostro:builder`\n> -if [ \"$Q\"  != \"\" ]; then\n> -    echo \"Removing ostro image\"\n> -    docker rmi -f $Q\n> -fi\n> -\n> -cd ${TOPDIR}/dockerfiles;\n> -\n> -Q=`docker images  -q crops/ostro:deps`\n> -if [ \"$Q\"  == \"\" ]; then\n> -    echo \"Build ostro deps image\"\n> -    docker build -t crops/ostro:deps -f Dockerfile.ostro.deps --rm=true ..\n> -fi\n> -Q=`docker images  -q crops/ostro:builder`\n> -if [ \"$Q\"  == \"\" ]; then\n> -    echo \"Build ostro builder image\"\n> -    docker build -t crops/ostro:builder -f Dockerfile.ostro --rm=true ..\n> -fi\n> -\n> diff --git a/scripts/gdb.zephyr b/scripts/gdb.zephyr\n> deleted file mode 100644\n> index dfb128e..0000000\n> --- a/scripts/gdb.zephyr\n> +++ /dev/null\n> @@ -1,8 +0,0 @@\n> -#!/usr/bin/env bash\n> -\n> -DOCKER_EXEC_TTY=\"docker exec -it\"\n> -CONTAINER=crops-zephyr-0-7-2-src\n>\n> -GDB_PATH=//opt//zephyr-sdk//sysroots//i686-pokysdk-linux//usr//bin//i586-poky-elf//i586-poky-elf-gdb\n> -IMAGE=$1\n> -\n> - ${DOCKER_EXEC_TTY} ${CONTAINER} ${GDB_PATH} ${IMAGE}\n> diff --git a/scripts/make.zephyr b/scripts/make.zephyr\n> deleted file mode 100755\n> index 55f0cef..0000000\n> --- a/scripts/make.zephyr\n> +++ /dev/null\n> @@ -1,21 +0,0 @@\n> -#!/usr/bin/env bash\n> -\n> -echo $CEED_EXE\n> -\n> -if [ -z \"$CEED_EXE\" ]; then\n> -  CEED_EXE=./ceed/ceed\n> -fi\n> -\n> -if [ -z \"$ZEPHYR_CONTAINER\" ]; then\n> -  ZEPHYR_CONTAINER=zephyr-test\n> -fi\n> -\n> -ZEPHYR_ENV=\"ZEPHYR_GCC_VARIANT=zephyr\n> ZEPHYR_SDK_INSTALL_DIR=/opt/zephyr-sdk ZEPHYR_BASE=/crops/zephyr-project/\"\n> -ALL_PARAMS=$*\n> -\n> -if [ \"$#\" -eq 0 ]; then\n> -    echo $0: No parameters found\n> -    exit 1\n> -fi\n> -\n> -${CEED_EXE} -d ${ZEPHYR_CONTAINER} -g \"${ZEPHYR_ENV} make ${ALL_PARAMS}\"\n> diff --git a/scripts/run_containers b/scripts/run_containers\n> deleted file mode 100755\n> index d2c8066..0000000\n> --- a/scripts/run_containers\n> +++ /dev/null\n> @@ -1,59 +0,0 @@\n> -#!/usr/bin/env bash\n> -\n> -# This is a sanity test script for the CODI and toolchain Docker images.\n> -# This runs the test containers.\n> -# Then it runs ceed -l to talk to codi to list the 4 test toolchains\n> -#\n> -# Example:\n> -#\n> -# ./tests/run_containers [NUM_TOOLCHAIN CONATINERS TO START DEFAULT:4]\n> -\n> -TOPDIR=`git rev-parse --show-toplevel`\n> -# note, currently the turff node and the container name MUST match\n> exactly or have matching formats\n> -# Example: TURFFID=repo/image:tag and container name repo-image-tag\n> -# The Docker API does not allow special characters in container names\n> except '-'\n> -NAME_BASE=\"crops-toolchain-test\"\n> -NUM_TOOLCHAINS=4\n> -if [ \"$1\" != \"\" ]; then\n> -  NUM_TOOLCHAINS=$1\n> -fi\n> -\n> -\n> -if [ \"$DEBUG\" == \"\" ]; then\n> -    echo \"Start CODI container\"\n> -    docker run -d --name codi-test -v\n> /var/run/docker.sock:/var/run/docker.sock --net=host crops/codi:test || \\\n> -       { echo 'docker run codi failed' ; exit 1; }\n> -else\n> -    echo \"Start DEBUG CODI container\"\n> -    docker run -d --name codi-test-debug -v\n> /var/run/docker.sock:/var/run/docker.sock --net=host crops/codi:testdebug\n> || \\\n> -       { echo 'docker run codi failed' ; exit 1; }\n> -fi\n> -II=0\n> -while [ $II -lt $NUM_TOOLCHAINS ]; do\n> -  echo \"Start toolchain container $II\"\n> -  sleep 2;\n> -  docker run -d --name ${NAME_BASE}${II} -v /crops/:/crops/ --env\n> TURFFID=${NAME_BASE}${II} --net=host crops/toolchain:test || \\\n> -  { echo 'docker run toolchain-test${II} failed' ; exit 1; }\n> -  let II=$II+1\n> -done\n> -\n> -echo \"Start Zephyr toolchain container\"\n> -sleep 2;\n> -mkdir -p $HOME/crops-test-workspace\n> -docker run -d --name zephyr-test -v $HOME/crops-test-workspace/:/crops/\n> --env TURFFID=zephyr-test --net=host crops/zephyr:test || \\\n> -  { echo 'docker run zephyr-test failed' ; exit 1; }\n> -\n> -echo \"List containers known to CODI\"\n> -sleep 5;\n> -cd ${TOPDIR}/ceed\n> -\n> -# if docker-machine exists then we are on a mac/windows and use the\n> address of the vm we are running in\n> -# else localhost\n> -if [ -x \"$(command -v docker-machine)\" ]; then\n> -  NAME=`docker-machine active`\n> -  ADDRESS=`docker-machine ip ${NAME}`\n> -else\n> -  # linux can run over unix sockets rather than ip but ip is more cross\n> platform\n> -  ADDRESS=127.0.0.1\n> -fi\n> -./ceed -i $ADDRESS -s 10000 -l\n> diff --git a/scripts/stop_containers b/scripts/stop_containers\n> deleted file mode 100755\n> index b8d0cb7..0000000\n> --- a/scripts/stop_containers\n> +++ /dev/null\n> @@ -1,33 +0,0 @@\n> -#!/usr/bin/env bash\n> -\n> -# This is a sanity test script for the CODI and toolchain Docker images.\n> -# This stops the test containers.\n> -#\n> -# Example:\n> -#\n> -# ./scripts/stop_containers\n> -\n> -NAME_BASE=\"crops-toolchain-test\"\n> -\n> -II=0\n> -Q=`docker ps -a | egrep ${NAME_BASE}${II} | awk '{print $1}'`\n> -while [ \"$Q\" != \"\"  ]; do\n> -    echo \"Stop and Remove toolchain container $II\"\n> -    docker rm -f $Q || { echo 'docker rm $Q failed' ; exit 1; };\n> -    let II=$II+1\n> -    Q=`docker ps -a | egrep ${NAME_BASE}${II} | awk '{print $1}'`\n> -done\n> -\n> -echo \"Stop and remove Zephyr test container\"\n> -Q=`docker ps -a | egrep zephyr-test | awk '{print $1}'`\n> -if [ \"$Q\"  != \"\" ]; then\n> -    echo \"Removing Zephyr container\"\n> -    docker rm -f $Q || { echo 'docker rm $Q failed' ; exit 1; };\n> -fi\n> -\n> -echo \"Stop and remove CODI test container\"\n> -Q=`docker ps -a | egrep codi-test | awk '{print $1}'`\n> -if [ \"$Q\"  != \"\" ]; then\n> -    echo \"Removing codi container\"\n> -    docker rm -f $Q || { echo 'docker rm $Q failed' ; exit 1; };\n> -fi\n> diff --git a/tests.py b/tests.py\n> deleted file mode 100644\n> index f574c29..0000000\n> --- a/tests.py\n> +++ /dev/null\n> @@ -1,32 +0,0 @@\n> -''' CROPS test runner '''\n> -\n> -import unittest\n> -import sys\n> -\n> -def run_unittests():\n> -    ''' Execute Unit Tests '''\n> -    tests = unittest.TestLoader().discover('tests/unit')\n> -    result = unittest.TextTestRunner(verbosity=2).run(tests)\n> -    return result.wasSuccessful()\n> -\n> -def run_functional_tests():\n> -    ''' Execute Functional Tests '''\n> -    tests = unittest.TestLoader().discover('tests/functional')\n> -    result = unittest.TextTestRunner(verbosity=2).run(tests)\n> -    return result.wasSuccessful()\n> -\n> -if __name__ == '__main__':\n> -    print \"#\" * 70\n> -    print \"Test Runner: Unit tests\"\n> -    print \"#\" * 70\n> -    unit_results = run_unittests()\n> -\n> -    print \"#\" * 70\n> -    print \"Test Runner: Functional tests\"\n> -    print \"#\" * 70\n> -    functional_results = run_functional_tests()\n> -\n> -    if unit_results and functional_results:\n> -        sys.exit(0)\n> -    else:\n> -        sys.exit(1)\n> diff --git a/tests/functional/test_ceed_basic.py\n> b/tests/functional/test_ceed_basic.py\n> deleted file mode 100644\n> index ed7a7a9..0000000\n> --- a/tests/functional/test_ceed_basic.py\n> +++ /dev/null\n> @@ -1,104 +0,0 @@\n> -''' Test Basic ceed/codi api'''\n> -\n> -import unittest\n> -import re\n> -import subprocess\n> -import utils.ceedutil as ceedutil\n> -\n> -\n> -# This test set ASSUMES the initial scripts have been run and therefore\n> we have\n> -# 1) 1 codi container named codi-test\n> -# 2) 4 toolchain containers named test-toolchain-test[0-3]\n> -\n> -\n> -\n> -\n> -class CeedBasicTests(unittest.TestCase):\n> -    ''' Base class for testing ceed '''\n> -\n> -    def setUp(self):\n> -        ''' Define some unique data for validation '''\n> -        self.dockerAddress = ceedutil.getDockerAddress().strip()\n> -        self.tbase=ceedutil.ToolchainNameBase\n> -        self.tnum=ceedutil.ToolchainNumber\n> -        self.cPort=ceedutil.CodiPort\n> -\n> -    def tearDown(self):\n> -        ''' Destroy unique data '''\n> -        self.dockerAddress = None\n> -\n> -    def test_connect(self):\n> -        ''' Connect to codi'''\n> -        SUBSTRING=\"Connected to CODI on\"\n> -        try:\n> -            p =\n> subprocess.Popen([\"ceed/ceed\",\"-i\",self.dockerAddress,\"-l\"],stdout=subprocess.PIPE)\n> -        except subprocess.CalledProcessError as e:\n> -            print e.output\n> -            self.assertTrue(False)\n> -\n> -        success=False\n> -        output=p.communicate()[0]\n> -\n> -        for line in output.split('\\n'):\n> -            if line.find(SUBSTRING) >= 0:\n> -                success=True\n> -                break\n> -        self.assertTrue(success)\n> -\n> -    def test_connect_with_port(self):\n> -        ''' Connect to codi'''\n> -        SUBSTRING=\"Connected to CODI on\"\n> -        try:\n> -            p =\n> subprocess.Popen([\"ceed/ceed\",\"-i\",self.dockerAddress,\"-s\",str(self.cPort),\"-l\"],stdout=subprocess.PIPE)\n> -        except subprocess.CalledProcessError as e:\n> -            print e.output\n> -            self.assertTrue(False)\n> -\n> -        success=False\n> -        output=p.communicate()[0]\n> -\n> -        for line in output.split('\\n'):\n> -            if line.find(SUBSTRING) >= 0:\n> -                success=True\n> -                break\n> -        self.assertTrue(success)\n> -\n> -    def test_connect_with_badport_shouldfail(self):\n> -        ''' Connect to codi'''\n> -        SUBSTRING=\"Connected to CODI on\"\n> -        try:\n> -            p =\n> subprocess.Popen([\"ceed/ceed\",\"-i\",self.dockerAddress,\"-s\",str(self.cPort+1),\"-l\"],stdout=subprocess.PIPE)\n> -        except subprocess.CalledProcessError as e:\n> -            print e.output\n> -            self.assertTrue(False)\n> -\n> -        success=False\n> -        output=p.communicate()[0]\n> -\n> -        for line in output.split('\\n'):\n> -            if line.find(SUBSTRING) >= 0:\n> -                success=True\n> -                break\n> -        self.assertFalse(success)\n> -\n> -\n> -    def test_listContainers(self):\n> -        ''' List all the toolchain Containers'''\n> -        SUBSTRING1=\"TURFF\"\n> -        SUBSTRING2=self.tbase\n> -        EXPECTED_COUNT=4\n> -        try:\n> -            p =\n> subprocess.Popen([\"ceed/ceed\",\"-i\",self.dockerAddress,\"-l\"],stdout=subprocess.PIPE)\n> -        except subprocess.CalledProcessError as e:\n> -            print e.output\n> -            self.assertTrue(False)\n> -\n> -\n> -        count=0\n> -        output=p.communicate()[0]\n> -\n> -        for line in output.split('\\n'):\n> -            if line.find(SUBSTRING1) >= 0:\n> -                if line.find(SUBSTRING2) >= 0:\n> -                    count+=1\n> -        self.assertEqual(count,EXPECTED_COUNT)\n> diff --git a/tests/functional/test_ceed_commands.py\n> b/tests/functional/test_ceed_commands.py\n> deleted file mode 100644\n> index 72c22ea..0000000\n> --- a/tests/functional/test_ceed_commands.py\n> +++ /dev/null\n> @@ -1,121 +0,0 @@\n> -''' Test Basic ceed/codi api'''\n> -\n> -import unittest\n> -import re\n> -import subprocess\n> -import utils.ceedutil as ceedutil\n> -\n> -\n> -# This test set ASSUMES the initial scripts have been run and therefore\n> we have\n> -# 1) 1 codi container named codi-test\n> -# 2) 4 toolchain containers named test-toolchain-test[0-3]\n> -\n> -\n> -class CeedCommandsTests(unittest.TestCase):\n> -    ''' Base class for testing ceed '''\n> -\n> -    def setUp(self):\n> -        ''' Define some unique data for validation '''\n> -        self.dockerAddress = ceedutil.getDockerAddress().strip()\n> -        self.tbase=ceedutil.ToolchainNameBase\n> -        self.tnum=ceedutil.ToolchainNumber\n> -\n> -    def tearDown(self):\n> -        ''' Destroy unique data '''\n> -        self.dockerAddress = None\n> -\n> -    def test_command(self):\n> -        ''' Get Output from simple command'''\n> -        SUBSTRING=\"/bin/bash\"\n> -        try:\n> -            p =\n> subprocess.Popen([\"ceed/ceed\",\"-i\",self.dockerAddress,\"-d\",self.tbase+\"0\",\n> \"-g\",\"which bash\"],stdout=subprocess.PIPE)\n> -        except subprocess.CalledProcessError as e:\n> -            print e.output\n> -            self.assertTrue(False)\n> -\n> -        success=False\n> -        output=p.communicate()[0]\n> -\n> -        for line in output.split('\\n'):\n> -            if line.find(SUBSTRING) >= 0:\n> -                success=True\n> -                break\n> -        self.assertTrue(success)\n> -\n> -    def test_command_all(self):\n> -        ''' Get Output from simple command for all containers'''\n> -        SUBSTRING=\"/bin/bash\"\n> -        successAll=True\n> -        for i in range(self.tnum):\n> -            try:\n> -                p =\n> subprocess.Popen([\"ceed/ceed\",\"-i\",self.dockerAddress,\"-d\",self.tbase+str(i),\n> \"-g\",\"which bash\"],stdout=subprocess.PIPE)\n> -            except subprocess.CalledProcessError as e:\n> -                print e.output\n> -                self.assertTrue(False)\n> -\n> -            success=False\n> -            output=p.communicate()[0]\n> -\n> -            for line in output.split('\\n'):\n> -                if line.find(SUBSTRING) >= 0:\n> -                    success=True\n> -                    break\n> -            successAll&=success\n> -        self.assertTrue(successAll)\n> -\n> -\n> -    def test_command_args_switch(self):\n> -        ''' Get Output from simple command using argument switch'''\n> -        SUBSTRING=\"/bin/bash\"\n> -        try:\n> -            p =\n> subprocess.Popen([\"ceed/ceed\",\"-i\",self.dockerAddress,\"-d\",self.tbase+\"0\",\n> \"-r\",\"bash\",\"-g\",\"which\"],stdout=subprocess.PIPE)\n> -        except subprocess.CalledProcessError as e:\n> -            print e.output\n> -            self.assertTrue(False)\n> -\n> -        success=False\n> -        output=p.communicate()[0]\n> -\n> -        for line in output.split('\\n'):\n> -            if line.find(SUBSTRING) >= 0:\n> -                success=True\n> -                break\n> -        self.assertTrue(success)\n> -\n> -\n> -    def test_command_env_inline(self):\n> -        ''' Pass env as Q=R cmd'''\n> -        SUBSTRING=\"FROGS=FRIENDS\"\n> -        try:\n> -            p =\n> subprocess.Popen([\"ceed/ceed\",\"-i\",self.dockerAddress,\"-d\",self.tbase+\"0\",\n> \"-g\",\"FROGS=FRIENDS printenv\"],stdout=subprocess.PIPE)\n> -        except subprocess.CalledProcessError as e:\n> -            print e.output\n> -            self.assertTrue(False)\n> -\n> -        success=False\n> -        output=p.communicate()[0]\n> -\n> -        for line in output.split('\\n'):\n> -            if line.find(SUBSTRING) >= 0:\n> -                success=True\n> -                break\n> -        self.assertTrue(success)\n> -\n> -    # This will be added when the -e flag is fixed\n> -    # def test_command_env_as_argument(self):\n> -    #     ''' Pass env using the -e switch to cmd'''\n> -    #     SUBSTRING=\"FROGS=FRIENDS\"\n> -    #     try:\n> -    #         p =\n> subprocess.Popen([\"ceed/ceed\",\"-i\",self.dockerAddress,\"-d\",self.tbase+\"0\",\n> \"-e\",\"FROGS=FRIENDS\",\"-g\",\"printenv\"],stdout=subprocess.PIPE)\n> -    #     except subprocess.CalledProcessError as e:\n> -    #         print e.output\n> -    #         self.assertTrue(False)\n> -\n> -    #     success=False\n> -    #     output=p.communicate()[0]\n> -\n> -    #     for line in output.split('\\n'):\n> -    #         if line.find(SUBSTRING) >= 0:\n> -    #             success=True\n> -    #             break\n> -    #     self.assertTrue(success)\n> diff --git a/tests/functional/test_zephyr_build.py\n> b/tests/functional/test_zephyr_build.py\n> deleted file mode 100644\n> index 97fedf7..0000000\n> --- a/tests/functional/test_zephyr_build.py\n> +++ /dev/null\n> @@ -1,101 +0,0 @@\n> -''' Test Zephyr Build'''\n> -import unittest\n> -import re\n> -import subprocess\n> -import os.path\n> -import utils.ceedutil as ceedutil\n> -\n> -\n> -# This test set ASSUMES the initial scripts have been run and therefore\n> we have\n> -# 1) 1 codi container named codi-test\n> -# 2) 1 zephyr toolchain container named zephyr-test\n> -\n> -\n> -class ZephyrBuildTest(unittest.TestCase):\n> -    ''' Base class for testing Zephyr builds '''\n> -\n> -    def setUp(self):\n> -        ''' Define some unique data for validation '''\n> -        self.dockerAddress = ceedutil.getDockerAddress().strip()\n> -        self.codiPort=ceedutil.CodiPort\n> -        self.zephyrName=\"zephyr-test\"\n> -        self.zephyrHostPath=os.environ['HOME']+\"/crops-test-workspace/\"\n> -        self.zephyrContainerPath=\"/crops/\"\n> -\n> self.zephyrPrjPath=\"zephyr-project/samples/nanokernel/apps/hello_world/\"\n> -        self.zephyrBin=\"outdir/zephyr.bin\"\n> -        self.devnull=open(os.devnull, 'w')\n> -\n> -    def tearDown(self):\n> -        ''' Destroy unique data '''\n> -        self.dockerAddress = None\n> -\n> -    def test_a_git_clone(self):\n> -        ''' Checkout Zephyr source'''\n> -        SUBSTRING=\"Note: checking out\"\n> -        try:\n> -\n> subprocess.call([\"rm\",\"-rf\",os.environ['HOME']+\"/crops-test-workspace/zephyr-project\"],stdout=self.devnull)\n> -\n> subprocess.call([\"ceed/ceed\",\"-i\",self.dockerAddress,\"-d\",self.zephyrName,\n> \"-s\",str(self.codiPort),\n> -                \"-g\",\"git clone --branch v1.0.0 /zephyr-src\n> /crops/zephyr-project\"],stdout=self.devnull)\n> -        except subprocess.CalledProcessError as e:\n> -            print e.output\n> -            self.assertTrue(False)\n> -\n> -        success=False\n> -\n> -        if os.path.isdir(self.zephyrHostPath+self.zephyrPrjPath):\n> -            success=True\n> -\n> -        self.assertTrue(success)\n> -\n> -    def test_x86_build(self):\n> -        ''' Build X86 hello world application\\n'''\n> -        BOARD=\"arduino_101\"\n> -        try:\n> -\n> subprocess.call([\"scripts/make.zephyr\",\"pristine\",\"BOARD=\"+BOARD,\"-C\",self.zephyrContainerPath+self.zephyrPrjPath],stdout=self.devnull)\n> -\n> subprocess.call([\"scripts/make.zephyr\",\"BOARD=\"+BOARD,\"-C\",self.zephyrContainerPath+self.zephyrPrjPath],stdout=self.devnull)\n> -        except subprocess.CalledProcessError as e:\n> -            print e.output\n> -            self.assertTrue(False)\n> -\n> -        success=False\n> -\n> -        if os.path.isfile(self.zephyrHostPath+self.zephyrPrjPath +\n> self.zephyrBin):\n> -            success=True\n> -\n> -        self.assertTrue(success)\n> -\n> -\n> -    def test_arm_build(self):\n> -        ''' Build ARM hello world application\\n'''\n> -        BOARD=\"arduino_due\"\n> -        try:\n> -\n> subprocess.call([\"scripts/make.zephyr\",\"pristine\",\"BOARD=\"+BOARD,\"-C\",self.zephyrContainerPath+self.zephyrPrjPath],stdout=self.devnull)\n> -\n> subprocess.call([\"scripts/make.zephyr\",\"BOARD=\"+BOARD,\"-C\",self.zephyrContainerPath+self.zephyrPrjPath],stdout=self.devnull)\n> -        except subprocess.CalledProcessError as e:\n> -            print e.output\n> -            self.assertTrue(False)\n> -\n> -        success=False\n> -\n> -        if os.path.isfile(self.zephyrHostPath+self.zephyrPrjPath +\n> self.zephyrBin):\n> -            success=True\n> -\n> -        self.assertTrue(success)\n> -\n> -\n> -    def test_arc_build(self):\n> -        ''' Build ARC hello world application\\n'''\n> -        BOARD=\"arduino_101_sss\"\n> -        try:\n> -\n> subprocess.call([\"scripts/make.zephyr\",\"pristine\",\"BOARD=\"+BOARD,\"-C\",self.zephyrContainerPath+self.zephyrPrjPath],stdout=self.devnull)\n> -\n> subprocess.call([\"scripts/make.zephyr\",\"BOARD=\"+BOARD,\"-C\",self.zephyrContainerPath+self.zephyrPrjPath],stdout=self.devnull)\n> -        except subprocess.CalledProcessError as e:\n> -            print e.output\n> -            self.assertTrue(False)\n> -\n> -        success=False\n> -\n> -        if os.path.isfile(self.zephyrHostPath+self.zephyrPrjPath +\n> self.zephyrBin):\n> -            success=True\n> -\n> -        self.assertTrue(success)\n> diff --git a/tests/functional/utils/__init__.py\n> b/tests/functional/utils/__init__.py\n> deleted file mode 100644\n> index e69de29..0000000\n> diff --git a/tests/functional/utils/ceedutil.py\n> b/tests/functional/utils/ceedutil.py\n> deleted file mode 100644\n> index ea75b90..0000000\n> --- a/tests/functional/utils/ceedutil.py\n> +++ /dev/null\n> @@ -1,20 +0,0 @@\n> -# some shared utility functions\n> -import subprocess\n> -\n> -ToolchainNameBase=\"crops-toolchain-test\"\n> -ToolchainNumber=4\n> -CodiPort=10000\n> -def cmd_exists(cmd):\n> -    return subprocess.call (\"command -v \"+cmd,shell=True,\n> -\n> stdout=subprocess.PIPE,stderr=subprocess.PIPE)==0\n> -\n> -def getDockerMachineAddress():\n> -    machine_name=subprocess.check_output(['docker-machine','active'])\n> -\n> ADDRESS=subprocess.check_output(['docker-machine','ip',machine_name.strip()])\n> -    return ADDRESS\n> -\n> -def getDockerAddress():\n> -    ADDRESS=\"127.0.0.1\"\n> -    if cmd_exists('docker-machine'):\n> -        ADDRESS=getDockerMachineAddress()\n> -    return ADDRESS\n> diff --git a/tests/unit/test_basic.py b/tests/unit/test_basic.py\n> deleted file mode 100644\n> index 1856536..0000000\n> --- a/tests/unit/test_basic.py\n> +++ /dev/null\n> @@ -1,19 +0,0 @@\n> -''' Crawl the running Docker site and verify all links give a 200 OK '''\n> -\n> -import unittest\n> -import subprocess\n> -\n> -\n> -# Placeholder for future python based codi/TURFF\n> -\n> -class BasicTests(unittest.TestCase):\n> -    ''' Base class for testing '''\n> -\n> -    def setUp(self):\n> -        ''' Define some unique data for validation '''\n> -        pass\n> -\n> -\n> -    def tearDown(self):\n> -        ''' Destroy unique data '''\n> -        pass\n> diff --git a/tests/unit/test_runbitbake.py b/tests/unit/test_runbitbake.py\n> deleted file mode 100644\n> index 3b3a733..0000000\n> --- a/tests/unit/test_runbitbake.py\n> +++ /dev/null\n> @@ -1,130 +0,0 @@\n> -#!/usr/bin/env python\n> -\n> -import unittest\n> -import os\n> -import subprocess\n> -import shutil\n> -import tempfile\n> -import sys\n> -import stat\n> -import imp\n> -\n> -\n> -class RunBitbakeTestBase(unittest.TestCase):\n> -    def setUp(self):\n> -        self.tempdir = tempfile.mkdtemp(prefix=\"runbitbaketest-tmpdir\")\n> -\n> -        self.pokydir = os.path.join(self.tempdir, \"poky\")\n> -        os.mkdir(self.pokydir)\n> -\n> -        # runbitbake.py requires --pokydir with a \"oe-init-build-env\"\n> script\n> -        self.setupscript = os.path.join(self.pokydir, \"oe-init-build-env\")\n> -        with open(self.setupscript, \"w\"):\n> -            pass\n> -\n> -        # Create a builddir and confdir as if oe-init-build-env had ran\n> -        self.builddir = os.path.join(self.tempdir, \"build\")\n> -        self.confdir = os.path.join(self.builddir, \"conf\")\n> -        os.mkdir(self.builddir)\n> -        os.mkdir(self.confdir)\n> -\n> -        # Create an executable bitbake that does nothing\n> -        self.bindir = os.path.join(self.tempdir, \"bin\")\n> -        os.mkdir(self.bindir)\n> -\n> -        self.bitbake = os.path.join(self.bindir, \"bitbake\")\n> -        with open(self.bitbake, \"w\") as f:\n> -            f.write(\"#!/bin/sh\\n\")\n> -            os.chmod(self.bitbake, stat.S_IRWXU)\n> -\n> -        # Make sure runbitbake.py can run our fake bitbake\n> -        os.environ[\"PATH\"] = \"{}:{}\".format(self.bindir,\n> os.environ[\"PATH\"])\n> -\n> -        # We will have one line local.conf and bblayers.conf.\n> -        self.local_conf = os.path.join(self.confdir, \"local.conf\")\n> -        with open(self.local_conf, \"w\") as f:\n> -            f.write(\"Some data\\n\")\n> -\n> -        self.bblayers_conf = os.path.join(self.confdir, \"bblayers.conf\")\n> -        with open(self.bblayers_conf, \"w\") as f:\n> -            f.write(\"Other data\\n\")\n> -\n> -        # Create the files that contain extra data to be added to the\n> original\n> -        # configuration files\n> -        self.extraconf = os.path.join(self.tempdir, \"extra.conf\")\n> -        with open(self.extraconf, \"w\") as f:\n> -            f.write(\"MOAR STUFF\\nEVEN MOAR!!!!\\n\")\n> -\n> -        self.extralayers = os.path.join(self.tempdir,\n> \"bblayers_extra.conf\")\n> -        with open(self.extralayers, \"w\") as f:\n> -            f.write(\"BBLAYERS MOAR STUFF\\nEVEN MOAR BBLAYERS!!!!\\n\")\n> -\n> -    def tearDown(self):\n> -        shutil.rmtree(self.tempdir, ignore_errors=True)\n> -\n> -\n> -class ConfFilesTest(RunBitbakeTestBase):\n> -    def setUp(self):\n> -        super(ConfFilesTest, self).setUp()\n> -\n> -        # These \".orig\" files are for checking that the file is restored\n> back\n> -        # to the original state\n> -        self.local_conf_orig = os.path.join(self.tempdir,\n> \"local.conf.orig\")\n> -        self.bblayers_conf_orig = os.path.join(self.tempdir,\n> -                                               \"bblayers.conf.orig\")\n> -        shutil.copyfile(self.local_conf, self.local_conf_orig)\n> -        shutil.copyfile(self.bblayers_conf, self.bblayers_conf_orig)\n> -\n> -\n> -\n> -    def test_files_are_restored(self):\n> -        cmd = \"\"\"python helpers/runbitbake.py --pokydir={} \"\"\" \\\n> -              \"\"\"-t junk -b {} \"\"\" \\\n> -              \"\"\"--extraconf={} \"\"\" \\\n> -              \"\"\"--extralayers={}\"\"\".format(self.pokydir, self.builddir,\n> -                                            self.extraconf,\n> self.extralayers)\n> -\n> -        subprocess.call(cmd.split(), stderr=sys.stderr, stdout=sys.stdout,\n> -                        shell=False)\n> -\n> -        with open(self.local_conf_orig, \"r\") as f:\n> -            origlines = f.readlines()\n> -        with open(self.local_conf, \"r\") as f:\n> -            newlines = f.readlines()\n> -        self.assertListEqual(origlines, newlines)\n> -\n> -        with open(self.bblayers_conf_orig, \"r\") as f:\n> -            origlines = f.readlines()\n> -        with open(self.bblayers_conf, \"r\") as f:\n> -            newlines = f.readlines()\n> -        self.assertListEqual(origlines, newlines)\n> -\n> -\n> -class AddExtraTest(RunBitbakeTestBase):\n> -    def setUp(self):\n> -        super(AddExtraTest, self).setUp()\n> -        # Since we are importing a file in the source directory, this\n> prevents\n> -        # cluttering the directory with a .pyc file.\n> -        sys.dont_write_bytecode = True\n> -\n> -        self.runbitbake = os.path.join(\"helpers\", \"runbitbake.py\")\n> -        self.module = imp.load_source(\"\", self.runbitbake)\n> -\n> -        self.addextra_tempdir = os.path.join(self.tempdir, \"addextratmp\")\n> -        os.mkdir(self.addextra_tempdir)\n> -\n> -    def test_addextra_changed_files(self):\n> -        addextra = self.module.addextra\n> -        addextra(self.addextra_tempdir, self.builddir, \"local.conf\",\n> -                 [self.extraconf])\n> -\n> -        with open(self.extraconf, \"r\") as f:\n> -            extraconflines = set(f.readlines())\n> -        with open(self.local_conf, \"r\") as f:\n> -            localconflines = set(f.readlines())\n> -\n> -        intersection = extraconflines & localconflines\n> -        self.assertListEqual(list(intersection), list(extraconflines))\n> -\n> -if __name__ == '__main__':\n> -    unittest.main()\n> diff --git a/turff/Makefile b/turff/Makefile\n> deleted file mode 100755\n> index 1664c59..0000000\n> --- a/turff/Makefile\n> +++ /dev/null\n> @@ -1,19 +0,0 @@\n> -CFLAGS=-g -I. -I../\n> -LDFLAGS=-lm\n> -DEPS = turff_api.h ../globals.h ../utils.h\n> -OBJ = turff.o turff_api.o ../utils.o ../globals.o\n> -\n> -all: turff\n> -\n> -debug: DFLAGS=-DDBG\n> -debug: clean turff\n> -\n> -%.o: %.c $(DEPS)\n> -       $(CC) -c -o $@ $< $(CFLAGS) $(DFLAGS)\n> -\n> -turff: $(OBJ)\n> -       $(CC) -o $@ $^ $(CFLAGS) $(LDFLAGS)\n> -\n> -.PHONY: clean\n> -clean:\n> -       rm -rf $(OBJ) turff\n> diff --git a/turff/turff.c b/turff/turff.c\n> deleted file mode 100755\n> index d63fb99..0000000\n> --- a/turff/turff.c\n> +++ /dev/null\n> @@ -1,128 +0,0 @@\n> -/*\n> - * Copyright (C) 2016 Intel Corporation\n> - *\n> - * Author: Todor Minchev <todor.minchev@linux.intel.com>\n> - *\n> - * This program is free software; you can redistribute it and/or modify it\n> - * under the terms and conditions of the GNU General Public License,\n> - * version 2, or (at your option) any later version, as published by\n> - * the Free Software Foundation.\n> - *\n> - * This program is distributed in the hope it will be useful, but WITHOUT\n> - * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n> - * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n> for\n> - * more details.\n> - */\n> -\n> -#include \"globals.h\"\n> -#include <stdlib.h>\n> -#include <signal.h>\n> -#include <netdb.h>\n> -#include \"utils.h\"\n> -#include \"turff_api.h\"\n> -\n> -#define PORT_RANGE 100\n> -extern char *turff_ops[];\n> -extern char *codi_params[];\n> -static int sock_fd;\n> -\n> -/*TODO - close sockets on CTRL+C. Get rid of this when running as a\n> daemon */\n> -void close_sockets(int dummy) {\n> -  close(sock_fd);\n> -  INFO(\"\\nClosed the sockets. Exiting!\\n\") ;\n> -  exit(0);\n> -}\n> -\n> -int main(int argc, char *argv[]) {\n> -\n> -  struct addrinfo *addr_p = NULL;\n> -  struct sockaddr cli_addr;\n> -  socklen_t cli_len;\n> -  int i, ceed_sock_fd, saved_out = -1, saved_err = -1, bound = 0;\n> -  const char *port;\n> -\n> -  parse_turff_params(argc, argv);\n> -\n> -  bound = 0;\n> -  port = turff_ops[KEY('s')];\n> -  while(!bound && (int) *port > (int) *turff_ops[KEY('s')] - PORT_RANGE) {\n> -\n> -    addr_p = bind_to_socket(NULL, port, &sock_fd);\n> -\n> -    if (addr_p == NULL) {\n> -      asprintf((char**)&port, \"%d\", atoi(port)-1) ;\n> -    } else {\n> -      turff_ops[KEY('s')] = (char*) port;\n> -      register_agent(turff_ops);\n> -      bound = 1;\n> -      INFO(\"TURFF listening on port: %s\\n\", port);\n> -    }\n> -  }\n> -\n> -  if (addr_p == NULL) {\n> -    ERR(\"Could not bind agent to socket\\n\");\n> -    exit(EXIT_FAILURE);\n> -  }\n> -\n> -  listen(sock_fd,1);\n> -  cli_len = sizeof(cli_addr);\n> -\n> -  signal(SIGINT, close_sockets);\n> -\n> -  while(1) {\n> -    ceed_sock_fd = accept(sock_fd, &cli_addr, &cli_len);\n> -\n> -    if (ceed_sock_fd < 0) {\n> -      ERR(\"ERROR on accept\");\n> -    }\n> -\n> -    /* receive parameters from CODI */\n> -    receive_args(ceed_sock_fd, codi_params);\n> -\n> -    if (!strcmp(CODI_NAME, codi_params[KEY('z')])) {\n> -      /* save stdout and stderr file descriptors */\n> -      dup2(2, saved_err);\n> -      dup2(1, saved_out);\n> -\n> -      /* redirect stdout & stderr to ceed socket */\n> -      dup2(ceed_sock_fd, 2);\n> -      dup2(ceed_sock_fd, 1);\n> -\n> -      /* make sure ceed and turff APIs match*/\n> -      if (!strcmp(turff_ops[KEY('v')], codi_params[KEY('v')])) {\n> -        /* process ceed requests */\n> -        if (process_params(codi_params))\n> -          ERR(\"ERROR processing ceed request\\n\");\n> -      } else {\n> -        INFO(\"Incompatible versions: TURFF[%s] - CODI[%s]\\n\",\n> -        turff_ops[KEY('v')], codi_params[KEY('v')]);\n> -      }\n> -\n> -      /* delay EOM - send as separate buffer */\n> -      fprintf(stdout, TURFF_EOM);\n> -      fflush(stdout);\n> -\n> -      /* restore stdout and stderr */\n> -      dup2(saved_err, 2);\n> -      dup2(saved_out, 1);\n> -\n> -      /* clear parameters and wait for a new service request */\n> -      for (i = 0; i< KEY_ARR_SZ; i++){\n> -        if (codi_params[i] != NULL) {\n> -#ifdef DBG\n> -          DEBUG(\"Received parameter [%c] : %s\\n\", i+'a', codi_params[i] );\n> -#endif\n> -          free(codi_params[i]);\n> -          codi_params[i] = NULL ;\n> -        }\n> -      }\n> -    } else {\n> -      /* ceed connected to turff directly. send it EOM*/\n> -      INFO(\"Request did not originate from CODI!\\n\");\n> -      codi_params[KEY('e')] = \"set\";\n> -      send_args(ceed_sock_fd, codi_params);\n> -    }\n> -    close(ceed_sock_fd);\n> -  }\n> -}\n> -\n> diff --git a/turff/turff_api.c b/turff/turff_api.c\n> deleted file mode 100755\n> index 1cd3728..0000000\n> --- a/turff/turff_api.c\n> +++ /dev/null\n> @@ -1,255 +0,0 @@\n> -/*\n> - * Copyright (C) 2016 Intel Corporation\n> - *\n> - * Author: Todor Minchev <todor.minchev@linux.intel.com>\n> - *\n> - * This program is free software; you can redistribute it and/or modify it\n> - * under the terms and conditions of the GNU General Public License,\n> - * version 2, or (at your option) any later version, as published by\n> - * the Free Software Foundation.\n> - *\n> - * This program is distributed in the hope it will be useful, but WITHOUT\n> - * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n> - * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n> for\n> - * more details.\n> - */\n> -\n> -#include \"globals.h\"\n> -#include <stdio.h>\n> -#include <stdlib.h>\n> -#include <strings.h>\n> -#include <unistd.h>\n> -#include <errno.h>\n> -#include <ctype.h>\n> -#include \"utils.h\"\n> -\n> -const char workspace_root[] = \"/crops\";\n> -char *turff_ops[KEY_ARR_SZ];\n> -char *codi_params[KEY_ARR_SZ];\n> -\n> -void print_turff_usage(int argc, char *argv[]) {\n> -  printf(\"Usage: %s \\n\", argv[0]);\n> -  printf(\" -s port number on which the agent is listening [default:\n> 9999]\\n\");\n> -  printf(\" -i CODI IP address [default: 127.0.0.1]\\n\");\n> -  printf(\" -d CODI port number [default: 10000]\\n\");\n> -  printf(\" -n node_id to be sent to CODI [default: TURFFID env\n> variable]\\n\");\n> -  printf(\" -h print this help menu\\n\");\n> -  printf(\" -v show turff version\\n\");\n> -}\n> -\n> -void init_turff_params(){\n> -  int i;\n> -\n> -  for (i = 0; i <  KEY_ARR_SZ; i++)\n> -    codi_params[i] = NULL;\n> -\n> -  turff_ops[KEY('s')] = TURFF_PORT;\n> -  turff_ops[KEY('v')] = VERSION;\n> -  turff_ops[KEY('i')] = CODI_IP_NATIVE;\n> -  turff_ops[KEY('d')] = CODI_PORT;\n> -  turff_ops[KEY('z')] = TURFF_NAME;\n> -}\n> -\n> -void parse_turff_params(int argc, char *argv[]) {\n> -  int c ;\n> -\n> -  init_turff_params() ;\n> -\n> -  while ((c = getopt(argc, argv, \"hvi:d:s:i:n:\")) != -1) {\n> -    switch (c) {\n> -    case 'h':\n> -      print_turff_usage(argc, argv);\n> -      exit(EXIT_SUCCESS);\n> -      break;\n> -    case 'v':\n> -      INFO(\"turff version : %s\\n\", VERSION);\n> -      exit(EXIT_SUCCESS);\n> -      break;\n> -    case 's':\n> -      turff_ops[KEY('s')]  = optarg;\n> -      break;\n> -    case 'i':\n> -      turff_ops[KEY('i')]  = optarg;\n> -      break;\n> -    case 'd':\n> -      turff_ops[KEY('d')]  = optarg;\n> -      break;\n> -    case 'n':\n> -      turff_ops[KEY('n')]  = optarg;\n> -      break;\n> -    case '?':\n> -      if (optopt == 's')\n> -        INFO(\"Option -%c requires an argument.\\n\", optopt);\n> -      else if (isprint (optopt))\n> -        INFO(\"Unknown option `-%c'.\\n\", optopt);\n> -      else\n> -        INFO(\"Unknown option character `\\\\x%x'.\\n\", optopt);\n> -    default:\n> -      print_turff_usage(argc, argv);\n> -      exit(EXIT_FAILURE);\n> -    }\n> -  }\n> -}\n> -\n> -/* TODO - add error checks and return error codes*/\n> -int exec_command(char* cmd) {\n> -  system(cmd);\n> -  free(cmd);\n> -  return 0;\n> -}\n> -\n> -/* TODO - add error checks and return error codes*/\n> -int build_at_prj(char *platform, char *prj_dir)\n> -{\n> -  char cmd[] = \"cd %s/%s/%s; chmod -R 777 *;./autogen.sh\n> $CONFIGURE_FLAGS; make;\";\n> -  char *build_cmd;\n> -\n> -  asprintf(&build_cmd, cmd, workspace_root, platform, prj_dir);\n> -  exec_command(build_cmd);\n> -  return 0;\n> -}\n> -\n> -/* TODO - add error checks and return error codes*/\n> -int clean_at_prj(char *platform, char *prj_dir) {\n> -  char cmd[] = \"make distclean -C %s/%s/%s/\";\n> -  char *clean_cmd;\n> -\n> -  asprintf(&clean_cmd, cmd, workspace_root, platform, prj_dir);\n> -  exec_command(clean_cmd);\n> -  return 0;\n> -}\n> -\n> -/* TODO - add error checks and return error codes*/\n> -int build_cm_prj(char *platform, char *prj_dir)\n> -{\n> -  char cmd[] = \"cd %s/%s/%s; mkdir -p build; cd build; cmake ../; make;\";\n> -  char *build_cmd;\n> -\n> -  asprintf(&build_cmd, cmd, workspace_root, platform, prj_dir);\n> -  exec_command(build_cmd);\n> -  return 0;\n> -}\n> -\n> -/* TODO - add error checks and return error codes*/\n> -int clean_cm_prj(char *platform, char *prj_dir)\n> -{\n> -  char cmd[] = \"make clean -C %s/%s/%s/build;\";\n> -  char *clean_cmd;\n> -\n> -  asprintf(&clean_cmd, cmd, workspace_root, platform, prj_dir);\n> -  exec_command(clean_cmd);\n> -  return 0;\n> -}\n> -\n> -/* TODO - add error checks and return error codes*/\n> -int build_m_prj(char *platform, char *prj_dir, char *make_target)\n> -{\n> -  char cmd[] = \"make %s -C %s/%s/%s\";\n> -  char *build_cmd;\n> -\n> -  asprintf(&build_cmd, cmd, make_target, workspace_root, platform,\n> prj_dir);\n> -  exec_command(build_cmd);\n> -  return 0;\n> -}\n> -\n> -/* TODO - add error checks and return error codes*/\n> -int clean_m_prj(char *platform, char *prj_dir) {\n> -  char cmd[] = \"make clean -C %s/%s/%s/\";\n> -  char *clean_cmd;\n> -\n> -  asprintf(&clean_cmd, cmd, workspace_root, platform, prj_dir);\n> -  exec_command(clean_cmd);\n> -  return 0;\n> -}\n> -\n> -/* TODO - add error checks and return error codes*/\n> -int generic_cmd(char *params[]) {\n> -  char cmd[] = \"%s %s\";\n> -  char *gen_cmd;\n> -\n> -  asprintf(&gen_cmd, cmd, params[KEY('g')], params[KEY('r')]);\n> -  exec_command(gen_cmd);\n> -  return 0;\n> -}\n> -\n> -/* TODO - add error checks and return error codes*/\n> -int build_prj(char *params[])\n> -{\n> -  if(params[KEY('t')] != NULL)\n> -    build_at_prj(params[KEY('a')], params[KEY('p')]);\n> -  else if(params[KEY('m')] != NULL)\n> -    build_m_prj(params[KEY('a')], params[KEY('p')], params[KEY('m')]);\n> -  else if(params[KEY('k')] != NULL)\n> -    build_cm_prj(params[KEY('a')], params[KEY('p')]);\n> -  else\n> -    return -1;\n> -\n> -  return 0;\n> -}\n> -\n> -/* TODO - add error checks and return error codes*/\n> -int clean_prj(char *params[])\n> -{\n> -  if(params[KEY('t')] != NULL)\n> -    clean_at_prj(params[KEY('a')], params[KEY('p')]);\n> -  else if(params[KEY('m')] != NULL)\n> -    clean_m_prj(params[KEY('a')], params[KEY('p')]);\n> -  else if(params[KEY('k')] != NULL)\n> -    clean_cm_prj(params[KEY('a')], params[KEY('p')]);\n> -  else\n> -    return -1;\n> -\n> -  return 0;\n> -}\n> -\n> -/* TODO - add error checks and return error codes*/\n> -int process_params(char *params[]) {\n> -  int i;\n> -  for (i = 0; i< KEY_ARR_SZ; i++){\n> -    if(params[i] != NULL) {\n> -      switch ('a' + i) {\n> -      case 'b':\n> -        build_prj(params);\n> -        break;\n> -      case 'c':\n> -        clean_prj(params);\n> -        break;\n> -      case 'g':\n> -        generic_cmd(params);\n> -        break;\n> -      }\n> -    }\n> -  }\n> -  return 0;\n> -}\n> -\n> -/* TODO - send port map to CODI*/\n> -int register_agent(char *turff_ops[]) {\n> -  int turff_sock_fd;\n> -  struct addrinfo *addr_p;\n> -  char *turff_id;\n> -\n> -  addr_p = connect_to_socket(turff_ops[KEY('i')], turff_ops[KEY('d')],\n> &turff_sock_fd);\n> -\n> -  if(addr_p == NULL) {\n> -    INFO(\"Please ensure that CODI is running\\n\");\n> -    ERR(\"Could not connect to CODI\\n\");\n> -  } else {\n> -    INFO(\"Connected to codi on %s:%s\\n\",\n> -      turff_ops[KEY('i')], turff_ops[KEY('d')]);\n> -  }\n> -\n> -  if (turff_ops[KEY('n')] == NULL) {\n> -    turff_id = getenv(TURFFID);\n> -    if(turff_id == NULL) {\n> -      INFO(\"Unable to read TURFFID from the environment\\n\");\n> -      INFO(\"Setting TURFFID to \\\"default\\\"\\n\");\n> -      turff_ops[KEY('n')] = \"default\" ;\n> -    } else\n> -      turff_ops[KEY('n')] = turff_id ;\n> -  }\n> -  sleep(2);\n> -  send_args(turff_sock_fd, turff_ops);\n> -\n> -  return 0;\n> -}\n> diff --git a/turff/turff_api.h b/turff/turff_api.h\n> deleted file mode 100755\n> index c2a3aed..0000000\n> --- a/turff/turff_api.h\n> +++ /dev/null\n> @@ -1,24 +0,0 @@\n> -/*\n> - * Copyright (C) 2016 Intel Corporation\n> - *\n> - * Author: Todor Minchev <todor.minchev@linux.intel.com>\n> - *\n> - * This program is free software; you can redistribute it and/or modify it\n> - * under the terms and conditions of the GNU General Public License,\n> - * version 2, or (at your option) any later version, as published by\n> - * the Free Software Foundation.\n> - *\n> - * This program is distributed in the hope it will be useful, but WITHOUT\n> - * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n> - * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n> for\n> - * more details.\n> - */\n> -\n> -#ifndef TURFF_API_H\n> -#define TURFF_API_H\n> -\n> -void parse_turff_params(int argc, char *argv[]);\n> -int process_params(char *params[]);\n> -int register_agent(char *turff_ops[]);\n> -\n> -#endif\n> diff --git a/turff/turff_launcher b/turff/turff_launcher\n> deleted file mode 100755\n> index 0df0594..0000000\n> --- a/turff/turff_launcher\n> +++ /dev/null\n> @@ -1,43 +0,0 @@\n> -#!/usr/bin/env bash\n> -\n> -help () {\n> -       echo -e \"\\nThis is a wrapper for launching TURFF\"\n> -       echo -e \"usage: $0 -f env_config_file\\n\";\n> -       echo \"Options:\"\n> -       echo -e \"-f cross compiler environment configuration file\"\n> -       echo -e \"-h show this help menu\"\n> -       exit 1;\n> -}\n> -\n> -SUPERVISE=supervise\n> -EXEC=/bin/turff/\n> -\n> -while getopts \":hf:\" opt; do\n> -       case $opt in\n> -               f)\n> -                       env_conf_file=$OPTARG\n> -                       ;;\n> -               h)\n> -                       help\n> -                       exit 1\n> -                       ;;\n> -               \\?)\n> -                       echo \"Invalid option: -$OPTARG\"\n> -                       exit 1\n> -                       ;;\n> -               :)\n> -                       echo \"Option -$OPTARG requires an argument.\"\n> -                       exit 1\n> -                       ;;\n> -       esac\n> -done\n> -\n> -if [ -n \"$env_conf_file\" ]; then\n> -       source $env_conf_file\n> -fi\n> -\n> -if [ $? -eq 0 ] ; then\n> -       $SUPERVISE $EXEC\n> -else\n> -       echo \"Error setting up cross compiler environment\"\n> -fi\n> diff --git a/utils.c b/utils.c\n> deleted file mode 100755\n> index 11ff951..0000000\n> --- a/utils.c\n> +++ /dev/null\n> @@ -1,351 +0,0 @@\n> -/*\n> - * Copyright (C) 2016 Intel Corporation\n> - *\n> - * Author: Todor Minchev <todor.minchev@linux.intel.com>\n> - *\n> - * This program is free software; you can redistribute it and/or modify it\n> - * under the terms and conditions of the GNU General Public License,\n> - * version 2, or (at your option) any later version, as published by\n> - * the Free Software Foundation.\n> - *\n> - * This program is distributed in the hope it will be useful, but WITHOUT\n> - * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n> - * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n> for\n> - * more details.\n> - */\n> -\n> -#include \"globals.h\"\n> -#include <stdio.h>\n> -#include <stdlib.h>\n> -#include <string.h>\n> -#include <errno.h>\n> -#include <unistd.h>\n> -#if defined(_WIN32)\n> -#include <winsock2.h>\n> -#include <wspiapi.h>\n> -#else\n> -#include <netdb.h>\n> -#include <sys/select.h>\n> -#endif\n> -#include \"utils.h\"\n> -\n> -\n> -/* TODO - add error checks and return error codes*/\n> -int redirect_sockets(int in_sock, int out_sock) {\n> -  int ready, received = 0;\n> -  fd_set read_fd_set ;\n> -  int size = BUFSIZ;\n> -  void *buf = calloc(1, size);\n> -\n> -  do {\n> -    FD_ZERO(&read_fd_set);\n> -    FD_SET(in_sock, &read_fd_set);\n> -    ready = select(in_sock+1, &read_fd_set, NULL, NULL, NULL);\n> -  } while (ready==-1 && errno == EINTR);\n> -\n> -  if (ready > 0 ){\n> -    if (FD_ISSET(in_sock, &read_fd_set)) {\n> -      while (size > 0) {\n> -        received = recv(in_sock, buf, size, 0);\n> -        if (received < 0 ){\n> -          ERR(\"Error : %s\\n\", strerror(errno));\n> -        } else if (received == 0) {\n> -          break ;\n> -        } else {\n> -          size -= received;\n> -          if (strstr((char*) buf, TURFF_EOM)) {\n> -            send_data(out_sock, (const void *) buf,received);\n> -            break;\n> -          } else {\n> -            send_data(out_sock, (const void *) buf,received);\n> -          }\n> -\n> -        }\n> -      }\n> -    }\n> -  } else if (ready < 0){\n> -    free(buf);\n> -    ERR(\"Select error\\n\");\n> -  }\n> -  free(buf);\n> -  return 0;\n> -}\n> -\n> -/* TODO - add error checks and return error codes*/\n> -int send_data(int sock_fd, const void *buf, size_t size) {\n> -  int n, ready, sent = 0;\n> -  fd_set write_fd_set ;\n> -  struct timeval timeout;\n> -\n> -  timeout.tv_sec = (long) 0.3;\n> -  timeout.tv_usec = 0;\n> -\n> -  FD_ZERO(&write_fd_set);\n> -  FD_SET(sock_fd, &write_fd_set);\n> -  n = sock_fd +1;\n> -\n> -  ready = select(n, NULL, &write_fd_set, NULL, &timeout);\n> -\n> -  if (ready) {\n> -    while (size > 0) {\n> -      sent = send(sock_fd, buf, size, 0);\n> -      if (sent == -1){\n> -        ERR(\"Unable to send data. Error: [%d] %s\", errno,\n> strerror(errno));\n> -      }\n> -      else {\n> -        size -= sent;\n> -#ifdef DBG\n> -        DEBUG(\"Bytes sent: %d. Bytes remaining: %zu\\n\", sent, size);\n> -#endif\n> -      }\n> -    }\n> -  } else if (ready == -1){\n> -      ERR(\"Select timeout\\n\");\n> -  }\n> -  return 0;\n> -}\n> -\n> -/* TODO - add error checks and return error codes*/\n> -int receive_data(int sock_fd, void *buf, size_t size, int is_ceed, int\n> *done) {\n> -  int ready, received = 0;\n> -  fd_set read_fd_set ;\n> -\n> -  do {\n> -    FD_ZERO(&read_fd_set);\n> -    FD_SET(sock_fd, &read_fd_set);\n> -    ready = select(sock_fd+1, &read_fd_set, NULL, NULL, NULL);\n> -  } while (ready==-1 && errno == EINTR);\n> -\n> -  if (ready > 0 ){\n> -    if (FD_ISSET(sock_fd, &read_fd_set)) {\n> -      while (size > 0) {\n> -        received = recv(sock_fd, buf, size, 0);\n> -        if (received < 0 ){\n> -          ERR(\"Error : %s\\n\", strerror(errno));\n> -        } else if (received == 0) {\n> -          if (is_ceed)\n> -            *done = 1;\n> -          break ;\n> -        } else {\n> -          size -= received;\n> -          if (strstr((char*) buf, TURFF_EOM) && done != NULL ) {\n> -            memset(strstr((char*) buf, TURFF_EOM), 0, sizeof(TURFF_EOM));\n> -            printf(\"%s\", (char*) buf);\n> -            *done = 1;\n> -            break;\n> -          } else if (is_ceed) {\n> -            printf(\"%s\", (char*) buf);\n> -          }\n> -          buf = (char*)buf + received;\n> -#ifdef DBG\n> -          DEBUG(\"\\nBytes read: %d Bytes remaining: %zu\\n\", received,\n> size);\n> -#endif\n> -        }\n> -      }\n> -    }\n> -  } else if (ready < 0){\n> -    ERR(\"Select error : %s\\n\", strerror(errno));\n> -  }\n> -\n> -  return 0;\n> -}\n> -\n> -void send_chunk(int sock_fd, msg_chunk *chunk) {\n> -  msg_chunk *head;\n> -  head = chunk ;\n> -  while (chunk != NULL) {\n> -    send_data(sock_fd, chunk, sizeof(msg_chunk));\n> -#ifdef DBG\n> -    DEBUG(\"Chunk op_code: %d , Chunk payload: %s\\n\", (*chunk).op_code,\n> -      (*chunk).arg);\n> -#endif\n> -    chunk = chunk->next ;\n> -  }\n> -\n> -  /* done with this parameter - free all chunks*/\n> -  while (head != NULL) {\n> -    chunk = head;\n> -    head = chunk->next;\n> -    free(chunk);\n> -  }\n> -}\n> -\n> -int receive_chunk(int sock_fd, msg_chunk *chunk) {\n> -  return receive_data(sock_fd, chunk, sizeof(msg_chunk), 0, NULL);\n> -}\n> -\n> -void send_args(int sock_fd, char *params[]) {\n> -  int  i, j, num_chunks;\n> -  msg_chunk *new_chunk, *tail_chunk, *head_chunk ;\n> -\n> -  /* send all params in chunks of 20 chars*/\n> -  for(i = 0; i < KEY_ARR_SZ; i++) {\n> -    if (params[i] != NULL) {\n> -      new_chunk = calloc(1, sizeof(msg_chunk));\n> -      head_chunk = new_chunk;\n> -      tail_chunk = new_chunk;\n> -      num_chunks =  ceil((double) strlen(params[i]) /\n> -        (sizeof((*new_chunk).arg)-1));\n> -\n> -      for(j = 0; j < num_chunks; j++) {\n> -        (*tail_chunk).op_code = i;\n> -        if (j != 0) {\n> -          strncpy((*tail_chunk).arg,\n> params[i]+(j*sizeof((*tail_chunk).arg)-j),\n> -            sizeof((*tail_chunk).arg)-1);\n> -        } else {\n> -          strncpy((*tail_chunk).arg, params[i],\n> sizeof((*tail_chunk).arg)-1);\n> -        }\n> -\n> -        /* was this the last chunk*/\n> -        if ((j+1) != num_chunks) {\n> -          new_chunk = calloc(1, sizeof(msg_chunk));\n> -          tail_chunk->next = new_chunk;\n> -          tail_chunk = new_chunk;\n> -        }\n> -      }\n> -      /* this param is ready - send head chunk*/\n> -      send_chunk(sock_fd, head_chunk);\n> -    }\n> -  }\n> -\n> -  /* we are done with all params. Send EOM as an individual chunk*/\n> -  new_chunk = calloc(1, sizeof(msg_chunk));\n> -  (*new_chunk).op_code = -1;\n> -  strcpy((*new_chunk).arg, MSG_TERM);\n> -  send_chunk(sock_fd, new_chunk);\n> -}\n> -\n> -/* receive all params in chunks of 20 chars including terminator*/\n> -void receive_args(int sock_fd, char *params[]) {\n> -  msg_chunk param_chunk;\n> -  char *tmp;\n> -  do {\n> -    memset(&param_chunk, 0, sizeof(msg_chunk));\n> -    receive_chunk(sock_fd, &param_chunk);\n> -\n> -#ifdef DBG\n> -    DEBUG(\"Chunk op_code: %d , Chunk payload: %s\\n\", param_chunk.op_code,\n> -      &param_chunk.arg);\n> -#endif\n> -    if (param_chunk.op_code != -1) {\n> -      if (params[param_chunk.op_code] == NULL) {\n> -        tmp = calloc(1, sizeof(param_chunk.arg));\n> -      } else {\n> -        tmp = realloc(params[param_chunk.op_code],\n> strlen(params[param_chunk.op_code])+\n> -          sizeof(param_chunk.arg));\n> -      }\n> -\n> -      params[param_chunk.op_code] = tmp;\n> -      strcpy(params[param_chunk.op_code] +\n> strlen(params[param_chunk.op_code]),\n> -        param_chunk.arg);\n> -#ifdef DBG\n> -      DEBUG(\"Chunk op_code: %d , parameter: %s\\n\", param_chunk.op_code,\n> -        params[param_chunk.op_code]);\n> -#endif\n> -    }\n> -  }while(param_chunk.op_code != -1); /* not EOM chunk*/\n> -}\n> -\n> -struct addrinfo* connect_to_socket(char *ip_in, char *port_in, int*\n> sock_fd_out) {\n> -  int sock_fd, result;\n> -  struct addrinfo criteria, *srv_addr, *addr_p;\n> -\n> -#if defined(_WIN32)\n> -  WSADATA wsa_data;\n> -  int res = WSAStartup(MAKEWORD(2, 2), &wsa_data);\n> -  if (res != 0) {\n> -    ERR(\"WSAStartup failed: %d\\n\", res);\n> -  }\n> -#endif\n> -\n> -  /* connect to agent */\n> -  memset(&criteria, 0, sizeof(criteria));\n> -  criteria.ai_family = AF_INET;\n> -  criteria.ai_socktype = SOCK_STREAM;\n> -  criteria.ai_flags = 0;\n> -  criteria.ai_protocol = 0;\n> -\n> -  result = getaddrinfo(ip_in, port_in, &criteria,&srv_addr);\n> -\n> -  if(result != 0) {\n> -    ERR(\"Could not get address info list : %s\\n\", gai_strerror(result));\n> -  }\n> -\n> -  for(addr_p = srv_addr; addr_p != NULL; addr_p = addr_p->ai_next) {\n> -    *sock_fd_out = socket(addr_p->ai_family, addr_p->ai_socktype,\n> addr_p->ai_protocol);\n> -\n> -    if (*sock_fd_out == -1)\n> -\n> -      continue;\n> -\n> -    if (connect(*sock_fd_out, addr_p->ai_addr, addr_p->ai_addrlen) != -1)\n> -      break;  /* Connected */\n> -\n> -    close(*sock_fd_out);\n> -  }\n> -\n> -  return addr_p ;\n> -}\n> -\n> -\n> -struct addrinfo* bind_to_socket(char *ip_in, const char *port_in, int*\n> sock_fd_out) {\n> -  struct addrinfo criteria, *srv_addr;\n> -  struct addrinfo *addr_p;\n> -  int result, opt = 1;\n> -\n> -  memset(&criteria, 0, sizeof(criteria));\n> -  criteria.ai_family = AF_INET;\n> -  criteria.ai_socktype = SOCK_STREAM;\n> -  criteria.ai_flags = AI_PASSIVE;\n> -  criteria.ai_protocol = 0;\n> -  criteria.ai_canonname = NULL;\n> -  criteria.ai_addr = NULL;\n> -  criteria.ai_next = NULL;\n> -\n> -  result = getaddrinfo(NULL, port_in, &criteria, &srv_addr);\n> -\n> -  if (result != 0) {\n> -    ERR(\"Could not get address info list\\n\");\n> -  }\n> -\n> -  for (addr_p = srv_addr; addr_p != NULL; addr_p = addr_p->ai_next) {\n> -    *sock_fd_out = socket(addr_p->ai_family, addr_p->ai_socktype,\n> addr_p->ai_protocol);\n> -\n> -    if (*sock_fd_out == -1)\n> -      continue;\n> -\n> -    if (setsockopt(*sock_fd_out, SOL_SOCKET, SO_REUSEADDR,\n> -      (char *)&opt, sizeof(opt)) < 0) {\n> -\n> -      close(*sock_fd_out);\n> -      ERR(\"setsockopt failed\\n\");\n> -    }\n> -\n> -    if (bind(*sock_fd_out, addr_p->ai_addr, addr_p->ai_addrlen) == 0)\n> -      break;                  /* Success */\n> -\n> -      close(*sock_fd_out);\n> -  }\n> -\n> -  freeaddrinfo(srv_addr);\n> -  return addr_p;\n> -}\n> -\n> -void copy_params(char *in[], char *out[]) {\n> -  int i;\n> -  for (i = 0; i< KEY_ARR_SZ; i++){\n> -    if (in[i] != NULL) {\n> -      asprintf(&out[i],\"%s\",in[i]);\n> -    }\n> -  }\n> -}\n> -\n> -void free_params(char *params[]) {\n> -  int i;\n> -  for (i = 0; i< KEY_ARR_SZ; i++){\n> -    if (params[i] != NULL) {\n> -      free(params[i]);\n> -      params[i] = NULL ;\n> -    }\n> -  }\n> -}\n> diff --git a/utils.h b/utils.h\n> deleted file mode 100755\n> index b4cc534..0000000\n> --- a/utils.h\n> +++ /dev/null\n> @@ -1,30 +0,0 @@\n> -/*\n> - * Copyright (C) 2016 Intel Corporation\n> - *\n> - * Author: Todor Minchev <todor.minchev@linux.intel.com>\n> - *\n> - * This program is free software; you can redistribute it and/or modify it\n> - * under the terms and conditions of the GNU General Public License,\n> - * version 2, or (at your option) any later version, as published by\n> - * the Free Software Foundation.\n> - *\n> - * This program is distributed in the hope it will be useful, but WITHOUT\n> - * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n> - * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n> for\n> - * more details.\n> - */\n> -\n> -#ifndef UTILS_H\n> -#define UTILS_H\n> -\n> -int send_data(int sock_fd, const void *buf, size_t size);\n> -int receive_data(int sock_fd, void *buf, size_t size, int is_ceed, int\n> *done);\n> -void send_args(int sock_fd, char *params[]);\n> -void receive_args(int sock_fd, char *params[]);\n> -struct addrinfo* connect_to_socket(char *ip_in, char *port_in, int*\n> sock_fd_out);\n> -struct addrinfo* bind_to_socket(char *ip_in, const char *port_in, int*\n> sock_fd_out);\n> -int redirect_sockets(int in_sock, int out_sock);\n> -void free_params(char *params[]);\n> -void copy_params(char *in[], char *out[]);\n> -\n> -#endif\n> --\n> 2.25.1\n>\n>\n> -=-=-=-=-=-=-=-=-=-=-=-\n> Links: You receive all messages sent to this group.\n> View/Reply Online (#58970):\n> https://lists.yoctoproject.org/g/yocto/message/58970\n> Mute This Topic: https://lists.yoctoproject.org/mt/96222152/924729\n> Group Owner: yocto+owner@lists.yoctoproject.org\n> Unsubscribe: https://lists.yoctoproject.org/g/yocto/unsub [\n> ticotimo@gmail.com]\n> -=-=-=-=-=-=-=-=-=-=-=-\n>\n>\n\n[-- Attachment #2: Type: text/html, Size: 205286 bytes --]\n\n^ permalink raw reply\t[flat|nested] 2+ messages in thread",
    "end of thread, other threads:[~2023-10-19 21:42 UTC | newest]\n\nThread overview: 2+ messages (download: mbox.gz / follow: Atom feed)\n-- links below jump to the message on this page --\n2023-01-12 13:26 [CROPS][PATCH] crops: Archive crops repository Eilís 'pidge' Ní Fhlannagáin\n2023-10-19 21:42 ` [yocto] \" Tim Orling\n"
]